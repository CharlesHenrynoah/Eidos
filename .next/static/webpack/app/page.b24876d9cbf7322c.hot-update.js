"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Canvas3DVisualization.tsx":
/*!**********************************************!*\
  !*** ./components/Canvas3DVisualization.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Canvas3DVisualization; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.16_@opentelemetry+api@1.9.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.16_@opentelemetry+api@1.9.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=Code,TrendingUp,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/.pnpm/lucide-react@0.454.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/trending-up.js\");\n/* harmony import */ var _barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=Code,TrendingUp,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/.pnpm/lucide-react@0.454.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/code.js\");\n/* harmony import */ var _barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Code,TrendingUp,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/.pnpm/lucide-react@0.454.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/zap.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Canvas3DVisualization(param) {\n    let { data, columns, visualizationType, generatedConfig } = param;\n    _s();\n    const plotRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isV0Generated, setIsV0Generated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [plotlyLoaded, setPlotlyLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [dataMapping, setDataMapping] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentModel, setCurrentModel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"scatter3d\");\n    const [dataAnalysis, setDataAnalysis] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Fonction pour gérer la visualisation générée par l'API\n    const renderV0Visualization = async (config)=>{\n        const plotElement = plotRef.current;\n        if (!plotElement) return;\n        try {\n            // Utiliser la configuration générée par l'API\n            if (config.plotData && config.layout) {\n                await window.Plotly.newPlot(plotElement, config.plotData, config.layout, getPlotConfig());\n            } else {\n                // Fallback sur la configuration par défaut\n                const analysis = analyzeDataIntelligently();\n                if (!analysis) return;\n                renderModelSpecificVisualization();\n            }\n        } catch (error) {\n            console.error(\"Erreur lors du rendu V0:\", error);\n            const analysis = analyzeDataIntelligently();\n            if (!analysis) return;\n            renderClassicScatter(analysis);\n        }\n    };\n    // Charger Plotly.js\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if ( true && !window.Plotly) {\n            const script = document.createElement(\"script\");\n            script.src = \"https://cdn.plot.ly/plotly-2.35.2.min.js\";\n            script.onload = ()=>setPlotlyLoaded(true);\n            script.onerror = ()=>{\n                console.error(\"Erreur lors du chargement de Plotly.js\");\n                setPlotlyLoaded(false);\n            };\n            document.head.appendChild(script);\n        } else if (window.Plotly) {\n            setPlotlyLoaded(true);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!plotlyLoaded || !plotRef.current) return;\n        const updateVisualization = async ()=>{\n            const plotElement = plotRef.current;\n            if (!plotElement) return;\n            // Nettoyer le graphique précédent\n            if (plotElement.children.length > 0) {\n                window.Plotly.purge(plotElement);\n            }\n            setCurrentModel(visualizationType);\n            try {\n                if (generatedConfig) {\n                    await renderV0Visualization(generatedConfig);\n                    setIsV0Generated(true);\n                } else {\n                    await renderModelSpecificVisualization();\n                    setIsV0Generated(false);\n                }\n            } catch (error) {\n                console.error(\"Erreur lors de la mise \\xe0 jour de la visualisation:\", error);\n                // En cas d'erreur, on revient au nuage de points basique\n                renderClassicScatter(analyzeDataIntelligently() || {\n                    mapping: {\n                        xAxis: columns[0] || \"index\",\n                        yAxis: columns[1] || \"index\",\n                        zAxis: columns[2] || \"index\",\n                        colorBy: columns[0] || \"index\",\n                        sizeBy: columns[1] || \"index\"\n                    },\n                    numericColumns: columns,\n                    categoricalColumns: [],\n                    temporalColumns: [],\n                    dataRanges: {},\n                    categories: {},\n                    dataTypes: {}\n                });\n            }\n        };\n        updateVisualization();\n    }, [\n        plotlyLoaded,\n        data,\n        columns,\n        visualizationType,\n        generatedConfig\n    ]);\n    // Analyse complète et intelligente des données\n    const analyzeDataIntelligently = ()=>{\n        if (!data || data.length === 0 || !columns || columns.length === 0) {\n            return null;\n        }\n        const analysis = {\n            mapping: {},\n            numericColumns: [],\n            categoricalColumns: [],\n            temporalColumns: [],\n            dataRanges: {},\n            categories: {},\n            dataTypes: {}\n        };\n        // Analyser chaque colonne en détail\n        columns.forEach((col)=>{\n            const values = data.map((row)=>row[col]).filter((val)=>val != null && val !== \"\");\n            if (values.length === 0) {\n                analysis.dataTypes[col] = \"mixed\";\n                return;\n            }\n            // Test numérique\n            const numericValues = values.map((val)=>Number.parseFloat(val)).filter((val)=>!isNaN(val) && isFinite(val));\n            const numericRatio = numericValues.length / values.length;\n            // Test temporel\n            const dateValues = values.filter((val)=>{\n                const date = new Date(val);\n                return !isNaN(date.getTime()) && date.getFullYear() > 1900 && date.getFullYear() < 2100;\n            });\n            const temporalRatio = dateValues.length / values.length;\n            // Test catégoriel\n            const uniqueValues = [\n                ...new Set(values)\n            ];\n            const uniqueRatio = uniqueValues.length / values.length;\n            // Classification intelligente\n            if (temporalRatio > 0.7) {\n                analysis.dataTypes[col] = \"temporal\";\n                analysis.temporalColumns.push(col);\n                // Convertir en timestamps pour les calculs\n                const timestamps = dateValues.map((val)=>new Date(val).getTime());\n                analysis.dataRanges[col] = {\n                    min: Math.min(...timestamps),\n                    max: Math.max(...timestamps),\n                    values: timestamps\n                };\n            } else if (numericRatio > 0.7) {\n                analysis.dataTypes[col] = \"numeric\";\n                analysis.numericColumns.push(col);\n                analysis.dataRanges[col] = {\n                    min: Math.min(...numericValues),\n                    max: Math.max(...numericValues),\n                    values: numericValues\n                };\n            } else if (uniqueRatio < 0.3 || uniqueValues.length <= 20) {\n                analysis.dataTypes[col] = \"categorical\";\n                analysis.categoricalColumns.push(col);\n                analysis.categories[col] = uniqueValues.slice(0, 20) // Limiter à 20 catégories\n                ;\n            } else {\n                analysis.dataTypes[col] = \"mixed\";\n                if (numericValues.length > 0) {\n                    analysis.dataRanges[col] = {\n                        min: Math.min(...numericValues),\n                        max: Math.max(...numericValues),\n                        values: numericValues\n                    };\n                }\n            }\n        });\n        // Créer un mapping intelligent basé sur les types de données\n        const allNumericCols = [\n            ...analysis.numericColumns,\n            ...analysis.temporalColumns\n        ];\n        if (allNumericCols.length >= 3) {\n            analysis.mapping = {\n                xAxis: allNumericCols[0],\n                yAxis: allNumericCols[1],\n                zAxis: allNumericCols[2],\n                colorBy: allNumericCols[0],\n                sizeBy: allNumericCols.length > 3 ? allNumericCols[3] : allNumericCols[0],\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        } else if (allNumericCols.length === 2) {\n            analysis.mapping = {\n                xAxis: allNumericCols[0],\n                yAxis: allNumericCols[1],\n                zAxis: allNumericCols[0],\n                colorBy: allNumericCols[1],\n                sizeBy: allNumericCols[0],\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        } else if (allNumericCols.length === 1) {\n            analysis.mapping = {\n                xAxis: allNumericCols[0],\n                yAxis: \"index\",\n                zAxis: allNumericCols[0],\n                colorBy: allNumericCols[0],\n                sizeBy: allNumericCols[0],\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        } else {\n            // Utiliser les indices et catégories\n            analysis.mapping = {\n                xAxis: \"index\",\n                yAxis: analysis.categoricalColumns[0] || \"index\",\n                zAxis: \"count\",\n                colorBy: analysis.categoricalColumns[0] || \"index\",\n                sizeBy: \"count\",\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        }\n        return analysis;\n    };\n    // Fonction principale qui route vers la bonne visualisation selon le modèle\n    const renderModelSpecificVisualization = ()=>{\n        if (!data || data.length === 0) {\n            renderDemoVisualization();\n            return;\n        }\n        const analysis = analyzeDataIntelligently();\n        if (!analysis) {\n            renderDemoVisualization();\n            return;\n        }\n        setDataAnalysis(analysis);\n        setDataMapping(analysis.mapping);\n        // Router vers la fonction spécialisée selon le modèle exact\n        switch(visualizationType){\n            // NUAGES\n            case \"scatter3d\":\n                renderClassicScatter(analysis);\n                break;\n            case \"scatter_bubble\":\n                renderBubbleScatter(analysis);\n                break;\n            case \"scatter_animated\":\n                renderAnimatedScatter(analysis);\n                break;\n            case \"scatter_clustered\":\n                renderClusteredScatter(analysis);\n                break;\n            case \"scatter_density\":\n                renderDensityScatter(analysis);\n                break;\n            // SURFACES\n            case \"surface3d\":\n                renderClassicSurface(analysis);\n                break;\n            case \"surface_contour\":\n                renderContourSurface(analysis);\n                break;\n            case \"surface_mesh\":\n                renderMeshSurface(analysis);\n                break;\n            case \"surface_gradient\":\n                renderGradientSurface(analysis);\n                break;\n            // ARCHITECTURE\n            case \"bars3d\":\n                renderClassicBars(analysis);\n                break;\n            case \"bars_grouped\":\n                renderGroupedBars(analysis);\n                break;\n            case \"bars_cylindrical\":\n                renderCylindricalBars(analysis);\n                break;\n            case \"bars_pyramid\":\n                renderPyramidBars(analysis);\n                break;\n            // GÉOMÉTRIQUES\n            case \"sphere_pack\":\n                renderSpherePack(analysis);\n                break;\n            case \"cube_matrix\":\n                renderCubeMatrix(analysis);\n                break;\n            case \"cone_field\":\n                renderConeField(analysis);\n                break;\n            case \"helix_spiral\":\n                renderHelixSpiral(analysis);\n                break;\n            // ARTISTIQUES\n            case \"mandala_3d\":\n                renderMandala3D(analysis);\n                break;\n            case \"fractal_3d\":\n                renderFractal3D(analysis);\n                break;\n            case \"crystal_3d\":\n                renderCrystal3D(analysis);\n                break;\n            case \"galaxy_3d\":\n                renderGalaxy3D(analysis);\n                break;\n            case \"dna_helix\":\n                renderDNAHelix(analysis);\n                break;\n            // RÉSEAUX\n            case \"network_3d\":\n                renderNetwork3D(analysis);\n                break;\n            case \"tree_3d\":\n                renderTree3D(analysis);\n                break;\n            // TEMPORELS\n            case \"timeline_3d\":\n                renderTimeline3D(analysis);\n                break;\n            case \"wave_temporal\":\n                renderWaveTemporal(analysis);\n                break;\n            case \"spiral_time\":\n                renderSpiralTime(analysis);\n                break;\n            // GÉOGRAPHIQUES\n            case \"globe_3d\":\n                renderGlobe3D(analysis);\n                break;\n            case \"terrain_3d\":\n                renderTerrain3D(analysis);\n                break;\n            // SCIENTIFIQUES\n            case \"molecule_3d\":\n                renderMolecule3D(analysis);\n                break;\n            case \"vector_field\":\n                renderVectorField(analysis);\n                break;\n            // STATISTIQUES\n            case \"histogram_3d\":\n                renderHistogram3D(analysis);\n                break;\n            case \"box_plot_3d\":\n                renderBoxPlot3D(analysis);\n                break;\n            default:\n                renderClassicScatter(analysis);\n        }\n    };\n    // Fonction utilitaire pour extraire les valeurs avec l'analyse\n    const getValuesFromAnalysis = (analysis, key)=>{\n        const column = analysis.mapping[key];\n        if (column === \"index\") {\n            return data.map((_, i)=>i);\n        } else if (column === \"count\") {\n            return data.map(()=>1);\n        } else if (column && columns.includes(column)) {\n            if (analysis.dataRanges[column]) {\n                // Utiliser les valeurs pré-calculées pour les colonnes numériques/temporelles\n                const range = analysis.dataRanges[column];\n                return data.map((row, i)=>{\n                    const val = row[column];\n                    if (analysis.dataTypes[column] === \"temporal\") {\n                        const timestamp = new Date(val).getTime();\n                        return isNaN(timestamp) ? range.min : timestamp;\n                    } else {\n                        const numVal = Number.parseFloat(val);\n                        return !isNaN(numVal) && isFinite(numVal) ? numVal : range.min;\n                    }\n                });\n            } else if (analysis.categories[column]) {\n                // Convertir les catégories en indices numériques\n                const categories = analysis.categories[column];\n                return data.map((row)=>{\n                    const val = row[column];\n                    const index = categories.indexOf(val);\n                    return index >= 0 ? index : 0;\n                });\n            }\n        }\n        return data.map((_, i)=>i);\n    };\n    // VISUALISATIONS SPÉCIALISÉES AVEC DONNÉES DYNAMIQUES\n    // 1. NUAGE CLASSIQUE - Adapté aux données\n    const renderClassicScatter = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        // Adapter la taille des marqueurs selon la densité des données\n        const markerSize = Math.max(3, Math.min(12, 100 / Math.sqrt(data.length)));\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: xValues,\n                y: yValues,\n                z: zValues,\n                marker: {\n                    size: markerSize,\n                    color: colorValues,\n                    colorscale: \"Viridis\",\n                    opacity: Math.max(0.6, 1 - data.length / 1000),\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                text: data.map((row, i)=>{\n                    let tooltip = \"<b>Point \".concat(i + 1, \"</b><br>\");\n                    tooltip += \"<b>\".concat(analysis.mapping.xAxis, \":</b> \").concat(row[analysis.mapping.xAxis] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>\".concat(analysis.mapping.yAxis, \":</b> \").concat(row[analysis.mapping.yAxis] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>\".concat(analysis.mapping.zAxis, \":</b> \").concat(row[analysis.mapping.zAxis] || \"N/A\", \"<br>\");\n                    if (analysis.mapping.categoryBy && row[analysis.mapping.categoryBy]) {\n                        tooltip += \"<b>\".concat(analysis.mapping.categoryBy, \":</b> \").concat(row[analysis.mapping.categoryBy], \"<br>\");\n                    }\n                    return tooltip;\n                }),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Nuage 3D - \".concat(data.length, \" points\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Nuage 3D Classique\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 2. DENSITÉ 3D - Vraie densité basée sur les données réelles\n    const renderDensityScatter = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        // Adapter la résolution de la grille selon le nombre de données\n        const gridSize = Math.min(25, Math.max(10, Math.sqrt(data.length)));\n        const xRange = analysis.dataRanges[analysis.mapping.xAxis];\n        const yRange = analysis.dataRanges[analysis.mapping.yAxis];\n        const zRange = analysis.dataRanges[analysis.mapping.zAxis];\n        if (!xRange || !yRange || !zRange) {\n            renderClassicScatter(analysis);\n            return;\n        }\n        const densityX = [];\n        const densityY = [];\n        const densityZ = [];\n        const densityColors = [];\n        const densitySizes = [];\n        // Calculer le rayon adaptatif basé sur les vraies données\n        const xSpan = xRange.max - xRange.min;\n        const ySpan = yRange.max - yRange.min;\n        const zSpan = zRange.max - zRange.min;\n        const radius = Math.max(xSpan, ySpan, zSpan) / (gridSize * 0.8);\n        for(let i = 0; i < gridSize; i++){\n            for(let j = 0; j < gridSize; j++){\n                for(let k = 0; k < gridSize; k++){\n                    const x = xRange.min + i / (gridSize - 1) * xSpan;\n                    const y = yRange.min + j / (gridSize - 1) * ySpan;\n                    const z = zRange.min + k / (gridSize - 1) * zSpan;\n                    // Calculer la densité locale avec les vraies données\n                    let density = 0;\n                    for(let p = 0; p < data.length; p++){\n                        const dx = xValues[p] - x;\n                        const dy = yValues[p] - y;\n                        const dz = zValues[p] - z;\n                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                        if (distance < radius) {\n                            density += Math.exp(-(distance * distance) / (radius * radius));\n                        }\n                    }\n                    // Seuil adaptatif basé sur la densité moyenne\n                    const threshold = data.length / (gridSize * gridSize * gridSize) * 0.5;\n                    if (density > threshold) {\n                        densityX.push(x);\n                        densityY.push(y);\n                        densityZ.push(z);\n                        densityColors.push(density);\n                        densitySizes.push(Math.max(4, Math.min(20, density * 15)));\n                    }\n                }\n            }\n        }\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: densityX,\n                y: densityY,\n                z: densityZ,\n                marker: {\n                    size: densitySizes,\n                    color: densityColors,\n                    colorscale: \"Hot\",\n                    opacity: 0.7,\n                    colorbar: {\n                        title: \"Densit\\xe9 Locale\",\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                text: densityX.map((_, i)=>\"<b>Zone Dense \".concat(i + 1, \"</b><br>Densit\\xe9: \").concat(densityColors[i].toFixed(2), \"<br>Position: (\").concat(densityX[i].toFixed(1), \", \").concat(densityY[i].toFixed(1), \", \").concat(densityZ[i].toFixed(1), \")\")),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Densit\\xe9 3D - \".concat(densityX.length, \" zones\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Densit\\xe9 3D - Zones de Concentration\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 3. BULLES 3D - Tailles vraiment proportionnelles aux données\n    const renderBubbleScatter = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        // Adapter la taille des bulles selon les données\n        const minSize = 10;\n        const maxSize = 50;\n        const normalizedSizes = sizeValues.map((v)=>{\n            const min = Math.min(...sizeValues);\n            const max = Math.max(...sizeValues);\n            return minSize + (v - min) / (max - min) * (maxSize - minSize);\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: xValues,\n                y: yValues,\n                z: zValues,\n                marker: {\n                    size: normalizedSizes,\n                    color: colorValues,\n                    colorscale: \"Plasma\",\n                    opacity: 0.75,\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    },\n                    line: {\n                        color: \"rgba(255, 255, 255, 0.3)\",\n                        width: 1\n                    }\n                },\n                text: data.map((row, i)=>{\n                    let tooltip = \"<b>Bulle \".concat(i + 1, \"</b><br>\");\n                    tooltip += \"<b>Taille (\".concat(analysis.mapping.sizeBy, \"):</b> \").concat(row[analysis.mapping.sizeBy] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>Couleur (\".concat(analysis.mapping.colorBy, \"):</b> \").concat(row[analysis.mapping.colorBy] || \"N/A\", \"<br>\");\n                    if (analysis.mapping.categoryBy && row[analysis.mapping.categoryBy]) {\n                        tooltip += \"<b>Cat\\xe9gorie:</b> \".concat(row[analysis.mapping.categoryBy], \"<br>\");\n                    }\n                    return tooltip;\n                }),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Bulles 3D - \".concat(data.length, \" \\xe9l\\xe9ments\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Bulles 3D - Tailles Proportionnelles\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 4. MANDALA 3D - Basé sur les patterns des données\n    const renderMandala3D = (analysis)=>{\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        const mandalaX = [];\n        const mandalaY = [];\n        const mandalaZ = [];\n        const mandalaColors = [];\n        const mandalaSizes = [];\n        // Utiliser les vraies données pour créer les patterns\n        data.forEach((row, i)=>{\n            const normalizedIndex = i / data.length;\n            const colorVal = colorValues[i];\n            const sizeVal = sizeValues[i];\n            // Nombre de tours basé sur la variance des données\n            const colorRange = analysis.dataRanges[analysis.mapping.colorBy];\n            const tours = colorRange ? 4 + (colorVal - colorRange.min) / (colorRange.max - colorRange.min) * 4 : 6;\n            const angle = normalizedIndex * tours * Math.PI;\n            const radius = 1 + Math.sin(angle * 3) * 0.5;\n            const height = Math.sin(angle * 2) * 0.3;\n            // Point principal\n            mandalaX.push(Math.cos(angle) * radius);\n            mandalaY.push(Math.sin(angle) * radius);\n            mandalaZ.push(height);\n            mandalaColors.push(colorVal);\n            mandalaSizes.push(Math.max(3, Math.min(8, sizeVal / ((colorRange === null || colorRange === void 0 ? void 0 : colorRange.max) || 1) * 6 + 3)));\n            // Pétales basés sur les catégories\n            const numPetals = analysis.mapping.categoryBy && analysis.categories[analysis.mapping.categoryBy] ? Math.min(6, analysis.categories[analysis.mapping.categoryBy].length) : 5;\n            for(let j = 0; j < numPetals; j++){\n                const petalAngle = angle + j * 2 * Math.PI / numPetals;\n                const petalRadius = radius * 0.3;\n                mandalaX.push(Math.cos(angle) * radius + Math.cos(petalAngle) * petalRadius);\n                mandalaY.push(Math.sin(angle) * radius + Math.sin(petalAngle) * petalRadius);\n                mandalaZ.push(height + Math.sin(petalAngle * 2) * 0.1);\n                mandalaColors.push(colorVal * 0.8);\n                mandalaSizes.push(Math.max(2, mandalaSizes[mandalaSizes.length - 1] * 0.6));\n            }\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: mandalaX,\n                y: mandalaY,\n                z: mandalaZ,\n                marker: {\n                    size: mandalaSizes,\n                    color: mandalaColors,\n                    colorscale: \"Rainbow\",\n                    opacity: 0.8,\n                    colorbar: {\n                        title: \"Harmonie (\".concat(analysis.mapping.colorBy, \")\"),\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                name: \"Mandala 3D - \".concat(data.length, \" \\xe9l\\xe9ments source\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Mandala 3D - Motifs Sacr\\xe9s\", analysis);\n        layout.scene.camera = {\n            eye: {\n                x: 0,\n                y: 0,\n                z: 2.5\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 5. GALAXIE 3D - Structure basée sur les données\n    const renderGalaxy3D = (analysis)=>{\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        const galaxyX = [];\n        const galaxyY = [];\n        const galaxyZ = [];\n        const galaxyColors = [];\n        const galaxySizes = [];\n        // Analyser la distribution pour créer les bras galactiques\n        const colorRange = analysis.dataRanges[analysis.mapping.colorBy];\n        const sizeRange = analysis.dataRanges[analysis.mapping.sizeBy];\n        data.forEach((row, i)=>{\n            const t = i / data.length;\n            const colorVal = colorValues[i];\n            const sizeVal = sizeValues[i];\n            // Position dans la galaxie basée sur les valeurs des données\n            const normalizedColor = colorRange ? (colorVal - colorRange.min) / (colorRange.max - colorRange.min) : t;\n            const normalizedSize = sizeRange ? (sizeVal - sizeRange.min) / (sizeRange.max - sizeRange.min) : 0.5;\n            // Angle et rayon basés sur les données\n            const angle = normalizedColor * 6 * Math.PI + t * 2 * Math.PI;\n            const radius = normalizedSize * 3 + t * 0.5;\n            const height = (Math.random() - 0.5) * 0.2 * (1 - t // Plus plat vers l'extérieur\n            );\n            // Bras principal\n            galaxyX.push(Math.cos(angle) * radius);\n            galaxyY.push(Math.sin(angle) * radius);\n            galaxyZ.push(height);\n            galaxyColors.push(colorVal);\n            galaxySizes.push(Math.max(2, Math.min(12, (1 - normalizedSize) * 8 + 3)));\n            // Bras secondaire si assez de données\n            if (data.length > 20) {\n                const angle2 = angle + Math.PI * 0.8;\n                const radius2 = radius * 0.7;\n                galaxyX.push(Math.cos(angle2) * radius2);\n                galaxyY.push(Math.sin(angle2) * radius2);\n                galaxyZ.push(height * 0.5);\n                galaxyColors.push(colorVal * 0.8);\n                galaxySizes.push(Math.max(1, galaxySizes[galaxySizes.length - 1] * 0.7));\n            }\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: galaxyX,\n                y: galaxyY,\n                z: galaxyZ,\n                marker: {\n                    size: galaxySizes,\n                    color: galaxyColors,\n                    colorscale: \"Viridis\",\n                    opacity: 0.8,\n                    colorbar: {\n                        title: \"Luminosit\\xe9 (\".concat(analysis.mapping.colorBy, \")\"),\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                name: \"Galaxie 3D - \".concat(data.length, \" \\xe9toiles\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Galaxie 3D - Spirale Cosmique\", analysis);\n        layout.scene.bgcolor = \"rgba(0, 0, 20, 0.9)\";\n        layout.scene.camera = {\n            eye: {\n                x: 1.5,\n                y: 1.5,\n                z: 1\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 6. TIMELINE 3D - Pour données temporelles\n    const renderTimeline3D = (analysis)=>{\n        // Chercher une colonne temporelle\n        const timeColumn = analysis.temporalColumns[0] || analysis.mapping.xAxis;\n        const valueColumn = analysis.mapping.yAxis;\n        const colorColumn = analysis.mapping.colorBy;\n        const timeValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const values = getValuesFromAnalysis(analysis, \"yAxis\");\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        // Trier par temps si c'est temporel\n        const sortedIndices = timeValues.map((_, i)=>i).sort((a, b)=>timeValues[a] - timeValues[b]);\n        const timelineX = sortedIndices.map((i)=>timeValues[i]);\n        const timelineY = sortedIndices.map((i)=>values[i]);\n        const timelineZ = sortedIndices.map((_, i)=>i * 0.1) // Élévation progressive\n        ;\n        const timelineColors = sortedIndices.map((i)=>colorValues[i]);\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers+lines\",\n                x: timelineX,\n                y: timelineY,\n                z: timelineZ,\n                marker: {\n                    size: 6,\n                    color: timelineColors,\n                    colorscale: \"Viridis\",\n                    opacity: 0.8,\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                line: {\n                    color: \"rgba(100, 100, 100, 0.6)\",\n                    width: 3\n                },\n                text: sortedIndices.map((i)=>{\n                    const row = data[i];\n                    let tooltip = \"<b>Point temporel \".concat(i + 1, \"</b><br>\");\n                    tooltip += \"<b>Temps:</b> \".concat(row[timeColumn] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>Valeur:</b> \".concat(row[valueColumn] || \"N/A\", \"<br>\");\n                    return tooltip;\n                }),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Timeline 3D - \".concat(data.length, \" points\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Timeline 3D - \\xc9volution Temporelle\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // Fonctions de rendu simplifiées pour les autres modèles\n    const renderAnimatedScatter = (analysis)=>renderClassicScatter(analysis);\n    const renderClusteredScatter = (analysis)=>renderBubbleScatter(analysis);\n    const renderClassicSurface = (analysis)=>renderContourSurface(analysis);\n    const renderMeshSurface = (analysis)=>renderContourSurface(analysis);\n    const renderGradientSurface = (analysis)=>renderContourSurface(analysis);\n    const renderClassicBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderGroupedBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderCylindricalBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderPyramidBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderSpherePack = (analysis)=>renderBubbleScatter(analysis);\n    const renderCubeMatrix = (analysis)=>renderClassicScatter(analysis);\n    const renderConeField = (analysis)=>renderClassicScatter(analysis);\n    const renderHelixSpiral = (analysis)=>renderDNAHelix(analysis);\n    const renderFractal3D = (analysis)=>renderMandala3D(analysis);\n    const renderCrystal3D = (analysis)=>renderClassicScatter(analysis);\n    const renderNetwork3D = (analysis)=>renderClassicScatter(analysis);\n    const renderTree3D = (analysis)=>renderClassicScatter(analysis);\n    const renderWaveTemporal = (analysis)=>renderTimeline3D(analysis);\n    const renderSpiralTime = (analysis)=>renderTimeline3D(analysis);\n    const renderGlobe3D = (analysis)=>renderClassicScatter(analysis);\n    const renderTerrain3D = (analysis)=>renderContourSurface(analysis);\n    const renderMolecule3D = (analysis)=>renderClassicScatter(analysis);\n    const renderVectorField = (analysis)=>renderClassicScatter(analysis);\n    const renderHistogram3D = (analysis)=>renderBubbleScatter(analysis);\n    const renderBoxPlot3D = (analysis)=>renderBubbleScatter(analysis);\n    // 7. SURFACE AVEC CONTOURS - Basée sur les vraies données\n    const renderContourSurface = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        const xRange = analysis.dataRanges[analysis.mapping.xAxis];\n        const yRange = analysis.dataRanges[analysis.mapping.yAxis];\n        if (!xRange || !yRange) {\n            renderClassicScatter(analysis);\n            return;\n        }\n        // Adapter la résolution selon la densité des données\n        const size = Math.min(30, Math.max(15, Math.sqrt(data.length)));\n        const xMin = xRange.min;\n        const xMax = xRange.max;\n        const yMin = yRange.min;\n        const yMax = yRange.max;\n        const xGrid = Array.from({\n            length: size\n        }, (_, i)=>xMin + i / (size - 1) * (xMax - xMin));\n        const yGrid = Array.from({\n            length: size\n        }, (_, i)=>yMin + i / (size - 1) * (yMax - yMin));\n        const surface = [];\n        for(let i = 0; i < size; i++){\n            const row = [];\n            for(let j = 0; j < size; j++){\n                const targetX = xGrid[j];\n                const targetY = yGrid[i];\n                // Interpolation pondérée par la distance\n                let weightedSum = 0;\n                let totalWeight = 0;\n                const maxDistance = Math.sqrt((xMax - xMin) ** 2 + (yMax - yMin) ** 2) / 5;\n                for(let k = 0; k < data.length; k++){\n                    const dx = xValues[k] - targetX;\n                    const dy = yValues[k] - targetY;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    if (distance < maxDistance) {\n                        const weight = Math.exp(-(distance * distance) / (maxDistance * maxDistance));\n                        weightedSum += zValues[k] * weight;\n                        totalWeight += weight;\n                    }\n                }\n                row.push(totalWeight > 0 ? weightedSum / totalWeight : 0);\n            }\n            surface.push(row);\n        }\n        const plotData = [\n            {\n                type: \"surface\",\n                z: surface,\n                x: xGrid,\n                y: yGrid,\n                colorscale: \"Earth\",\n                contours: {\n                    z: {\n                        show: true,\n                        usecolormap: true,\n                        highlightcolor: \"#42f462\",\n                        project: {\n                            z: true\n                        },\n                        width: 2\n                    }\n                },\n                colorbar: {\n                    title: analysis.mapping.zAxis,\n                    titlefont: {\n                        size: 10\n                    }\n                },\n                name: \"Surface - \".concat(data.length, \" points source\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Surface 3D - Lignes de Niveau\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 8. HÉLICE ADN - Basée sur les séquences de données\n    const renderDNAHelix = (analysis)=>{\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        const dnaX1 = [];\n        const dnaY1 = [];\n        const dnaZ1 = [];\n        const dnaX2 = [];\n        const dnaY2 = [];\n        const dnaZ2 = [];\n        const dnaColors = [];\n        const dnaSizes = [];\n        // Utiliser les vraies données pour moduler l'hélice\n        const colorRange = analysis.dataRanges[analysis.mapping.colorBy];\n        const sizeRange = analysis.dataRanges[analysis.mapping.sizeBy];\n        data.forEach((row, i)=>{\n            const t = i / data.length * 8 * Math.PI;\n            const z = i / data.length * 4;\n            // Modulation basée sur les données\n            const colorVal = colorValues[i];\n            const sizeVal = sizeValues[i];\n            const radiusModulation = colorRange ? 1 + 0.3 * (colorVal - colorRange.min) / (colorRange.max - colorRange.min) : 1;\n            const heightModulation = sizeRange ? 0.1 * (sizeVal - sizeRange.min) / (sizeRange.max - sizeRange.min) : 0;\n            // Premier brin\n            dnaX1.push(Math.cos(t) * radiusModulation);\n            dnaY1.push(Math.sin(t) * radiusModulation);\n            dnaZ1.push(z + heightModulation);\n            // Deuxième brin (décalé de π)\n            dnaX2.push(Math.cos(t + Math.PI) * radiusModulation);\n            dnaY2.push(Math.sin(t + Math.PI) * radiusModulation);\n            dnaZ2.push(z + heightModulation);\n            dnaColors.push(colorVal);\n            dnaSizes.push(Math.max(4, Math.min(10, sizeVal / ((sizeRange === null || sizeRange === void 0 ? void 0 : sizeRange.max) || 1) * 6 + 4)));\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers+lines\",\n                x: dnaX1,\n                y: dnaY1,\n                z: dnaZ1,\n                marker: {\n                    size: dnaSizes,\n                    color: dnaColors,\n                    colorscale: \"RdYlBu\",\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                line: {\n                    color: \"rgba(255, 100, 100, 0.8)\",\n                    width: 4\n                },\n                name: \"Brin ADN 1 - \".concat(data.length, \" bases\")\n            },\n            {\n                type: \"scatter3d\",\n                mode: \"markers+lines\",\n                x: dnaX2,\n                y: dnaY2,\n                z: dnaZ2,\n                marker: {\n                    size: dnaSizes,\n                    color: dnaColors,\n                    colorscale: \"RdYlBu\"\n                },\n                line: {\n                    color: \"rgba(100, 100, 255, 0.8)\",\n                    width: 4\n                },\n                name: \"Brin ADN 2 - \".concat(data.length, \" bases\"),\n                showlegend: false\n            }\n        ];\n        const layout = createDynamicLayout(\"Double H\\xe9lice ADN\", analysis);\n        layout.scene.camera = {\n            eye: {\n                x: 2,\n                y: 0,\n                z: 1\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // Fonction pour créer un layout dynamique basé sur l'analyse\n    const createDynamicLayout = (title, analysis)=>{\n        const dataInfo = \"\".concat(data.length, \" entr\\xe9es • \").concat(analysis.numericColumns.length, \" num. • \").concat(analysis.categoricalColumns.length, \" cat.\");\n        return {\n            scene: {\n                xaxis: {\n                    title: {\n                        text: \"\".concat(analysis.mapping.xAxis, \" \").concat(analysis.dataTypes[analysis.mapping.xAxis] ? \"(\".concat(analysis.dataTypes[analysis.mapping.xAxis], \")\") : \"\"),\n                        font: {\n                            size: 12,\n                            color: \"#ea580c\"\n                        }\n                    },\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                yaxis: {\n                    title: {\n                        text: \"\".concat(analysis.mapping.yAxis, \" \").concat(analysis.dataTypes[analysis.mapping.yAxis] ? \"(\".concat(analysis.dataTypes[analysis.mapping.yAxis], \")\") : \"\"),\n                        font: {\n                            size: 12,\n                            color: \"#ea580c\"\n                        }\n                    },\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                zaxis: {\n                    title: {\n                        text: \"\".concat(analysis.mapping.zAxis, \" \").concat(analysis.dataTypes[analysis.mapping.zAxis] ? \"(\".concat(analysis.dataTypes[analysis.mapping.zAxis], \")\") : \"\"),\n                        font: {\n                            size: 12,\n                            color: \"#ea580c\"\n                        }\n                    },\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                camera: {\n                    eye: {\n                        x: 1.25,\n                        y: 1.25,\n                        z: 1.25\n                    }\n                }\n            },\n            title: {\n                text: title,\n                font: {\n                    size: 18,\n                    color: \"#ea580c\"\n                }\n            },\n            paper_bgcolor: \"rgba(0,0,0,0)\",\n            margin: {\n                l: 0,\n                r: 0,\n                t: 60,\n                b: 0\n            },\n            annotations: [\n                {\n                    text: \"<b>Mod\\xe8le:</b> \".concat(title, \"<br><b>Donn\\xe9es:</b> \").concat(dataInfo, \"<br><b>Mapping:</b><br>• X: \").concat(analysis.mapping.xAxis, \"<br>• Y: \").concat(analysis.mapping.yAxis, \"<br>• Z: \").concat(analysis.mapping.zAxis, \"<br>• Couleur: \").concat(analysis.mapping.colorBy, \"<br>• Taille: \").concat(analysis.mapping.sizeBy).concat(analysis.mapping.categoryBy ? \"<br>• Cat\\xe9gorie: \".concat(analysis.mapping.categoryBy) : \"\"),\n                    showarrow: false,\n                    xref: \"paper\",\n                    yref: \"paper\",\n                    x: -0.15,\n                    y: 0.95,\n                    xanchor: \"left\",\n                    yanchor: \"top\",\n                    bgcolor: \"rgba(255, 255, 255, 0.8)\",\n                    bordercolor: \"rgba(234, 88, 12, 0.3)\",\n                    borderwidth: 1,\n                    font: {\n                        size: 8,\n                        color: \"#666\"\n                    }\n                }\n            ]\n        };\n    };\n    const getPlotConfig = ()=>({\n            responsive: true,\n            displayModeBar: false,\n            staticPlot: false,\n            scrollZoom: true,\n            doubleClick: \"reset\"\n        });\n    // renderV0Visualization est maintenant défini au début du composant\n    const renderDemoVisualization = ()=>{\n        const demoData = Array.from({\n            length: 50\n        }, (_, i)=>({\n                x: Math.random() * 10,\n                y: Math.random() * 10,\n                z: Math.random() * 10,\n                value: Math.random() * 100,\n                category: \"Cat\".concat(Math.floor(Math.random() * 5) + 1)\n            }));\n        setDataMapping({\n            xAxis: \"Dimension X\",\n            yAxis: \"Dimension Y\",\n            zAxis: \"Dimension Z\",\n            colorBy: \"Valeur\",\n            sizeBy: \"Valeur\"\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: demoData.map((d)=>d.x),\n                y: demoData.map((d)=>d.y),\n                z: demoData.map((d)=>d.z),\n                marker: {\n                    size: 8,\n                    color: demoData.map((d)=>d.value),\n                    colorscale: \"Rainbow\",\n                    opacity: 0.8\n                },\n                name: \"D\\xe9monstration\"\n            }\n        ];\n        const layout = {\n            scene: {\n                xaxis: {\n                    title: \"Dimension X\",\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                yaxis: {\n                    title: \"Dimension Y\",\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                zaxis: {\n                    title: \"Dimension Z\",\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                camera: {\n                    eye: {\n                        x: 1.25,\n                        y: 1.25,\n                        z: 1.25\n                    }\n                }\n            },\n            title: {\n                text: \"D\\xe9monstration - \".concat(getModelName(visualizationType)),\n                font: {\n                    size: 18,\n                    color: \"#ea580c\"\n                }\n            },\n            paper_bgcolor: \"rgba(0,0,0,0)\",\n            margin: {\n                l: 0,\n                r: 0,\n                t: 60,\n                b: 0\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    const getModelName = (modelId)=>{\n        const names = {\n            scatter3d: \"Nuage 3D Classique\",\n            scatter_density: \"Densit\\xe9 3D\",\n            scatter_bubble: \"Bulles 3D\",\n            mandala_3d: \"Mandala 3D\",\n            galaxy_3d: \"Galaxie 3D\",\n            surface_contour: \"Surface Contours\",\n            dna_helix: \"H\\xe9lice ADN\",\n            timeline_3d: \"Timeline 3D\"\n        };\n        return names[modelId] || \"Visualisation 3D\";\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-full bg-gradient-to-br from-orange-50 to-white rounded-xl border-2 border-orange-200 overflow-hidden\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-6 border-b border-orange-200 bg-white\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-3\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-12 h-12 bg-gradient-to-br from-orange-600 to-orange-500 rounded-xl flex items-center justify-center\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                        className: \"w-6 h-6 text-white\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                        lineNumber: 1158,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1157,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                            className: \"text-xl font-bold text-gray-800\",\n                                            children: \"Canvas IA • Visualisation Dynamique\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1161,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-sm text-gray-600\",\n                                            children: data.length > 0 ? \"\".concat(data.length, \" \\xe9chantillons • \").concat(columns.length, \" variables • \").concat(getModelName(currentModel)) : \"Mode d\\xe9monstration • \".concat(getModelName(currentModel))\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1162,\n                                            columnNumber: 15\n                                        }, this),\n                                        dataAnalysis && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-xs text-gray-500\",\n                                            children: [\n                                                dataAnalysis.numericColumns.length,\n                                                \" num\\xe9riques • \",\n                                                dataAnalysis.categoricalColumns.length,\n                                                \" \",\n                                                \"cat\\xe9gorielles • \",\n                                                dataAnalysis.temporalColumns.length,\n                                                \" temporelles\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1168,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1160,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                            lineNumber: 1156,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: [\n                                isV0Generated && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                            className: \"w-3 h-3 mr-1\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1179,\n                                            columnNumber: 17\n                                        }, this),\n                                        \"G\\xe9n\\xe9r\\xe9 par v0\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1178,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-orange-100 text-orange-800\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                            className: \"w-3 h-3 mr-1\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1184,\n                                            columnNumber: 15\n                                        }, this),\n                                        \"Plotly v2.35\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1183,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800\",\n                                    children: \"Adaptatif Dynamique\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1187,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                            lineNumber: 1176,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                    lineNumber: 1155,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                lineNumber: 1154,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative h-[calc(100%-120px)]\",\n                children: !plotlyLoaded ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-center h-full\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-8 h-8 border-2 border-orange-500 border-t-transparent rounded-full animate-spin mx-auto mb-4\"\n                            }, void 0, false, {\n                                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                lineNumber: 1199,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-gray-600\",\n                                children: \"Chargement de Plotly.js v2.35...\"\n                            }, void 0, false, {\n                                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                lineNumber: 1200,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-gray-500 mt-2\",\n                                children: \"Analyse dynamique des donn\\xe9es en cours...\"\n                            }, void 0, false, {\n                                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                lineNumber: 1201,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                        lineNumber: 1198,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                    lineNumber: 1197,\n                    columnNumber: 11\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    ref: plotRef,\n                    className: \"w-full h-full\"\n                }, void 0, false, {\n                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                    lineNumber: 1205,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                lineNumber: 1195,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n        lineNumber: 1152,\n        columnNumber: 5\n    }, this);\n}\n_s(Canvas3DVisualization, \"eO0E6itovXilb3IAoe61XKZZfX8=\");\n_c = Canvas3DVisualization;\nvar _c;\n$RefreshReg$(_c, \"Canvas3DVisualization\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQ2FudmFzM0RWaXN1YWxpemF0aW9uLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDQztBQW1DckMsU0FBU00sc0JBQXNCLEtBS2pCO1FBTGlCLEVBQzVDQyxJQUFJLEVBQ0pDLE9BQU8sRUFDUEMsaUJBQWlCLEVBQ2pCQyxlQUFlLEVBQ1ksR0FMaUI7O0lBTTVDLE1BQU1DLFVBQVVWLDZDQUFNQSxDQUFpQjtJQUN2QyxNQUFNLENBQUNXLGVBQWVDLGlCQUFpQixHQUFHWCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNZLGNBQWNDLGdCQUFnQixHQUFHYiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNjLGFBQWFDLGVBQWUsR0FBR2YsK0NBQVFBLENBQXFCO0lBQ25FLE1BQU0sQ0FBQ2dCLGNBQWNDLGdCQUFnQixHQUFHakIsK0NBQVFBLENBQVM7SUFDekQsTUFBTSxDQUFDa0IsY0FBY0MsZ0JBQWdCLEdBQUduQiwrQ0FBUUEsQ0FBc0I7SUFFdEUseURBQXlEO0lBQ3pELE1BQU1vQix3QkFBd0IsT0FBT0M7UUFDbkMsTUFBTUMsY0FBY2IsUUFBUWMsT0FBTztRQUNuQyxJQUFJLENBQUNELGFBQWE7UUFFbEIsSUFBSTtZQUNGLDhDQUE4QztZQUM5QyxJQUFJRCxPQUFPRyxRQUFRLElBQUlILE9BQU9JLE1BQU0sRUFBRTtnQkFDcEMsTUFBTUMsT0FBT0MsTUFBTSxDQUFDQyxPQUFPLENBQUNOLGFBQWFELE9BQU9HLFFBQVEsRUFBRUgsT0FBT0ksTUFBTSxFQUFFSTtZQUMzRSxPQUFPO2dCQUNMLDJDQUEyQztnQkFDM0MsTUFBTUMsV0FBV0M7Z0JBQ2pCLElBQUksQ0FBQ0QsVUFBVTtnQkFDZkU7WUFDRjtRQUNGLEVBQUUsT0FBT0MsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtZQUMxQyxNQUFNSCxXQUFXQztZQUNqQixJQUFJLENBQUNELFVBQVU7WUFDZksscUJB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QUNmLDhEQUFDckk7Z0NBQUVxSSxXQUFVOzBDQUFnQjs7Ozs7OzBDQUM3Qiw4REFBQ3JJO2dDQUFFcUksV0FBVTswQ0FBNkI7Ozs7Ozs7Ozs7Ozs7Ozs7eUNBSTlDLDhEQUFDRDtvQkFBSUksS0FBSzdTO29CQUFTMFMsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLdkM7R0FucEN3Qi9TO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FudmFzM0RWaXN1YWxpemF0aW9uLnRzeD9kYzUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBUcmVuZGluZ1VwLCBaYXAsIENvZGUgfSBmcm9tIFwibHVjaWRlLXJlYWN0XCJcblxuLy8gw4l0ZW5kcmUgbCdpbnRlcmZhY2UgV2luZG93IHBvdXIgaW5jbHVyZSBQbG90bHlcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgUGxvdGx5OiBhbnlcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ2FudmFzM0RWaXN1YWxpemF0aW9uUHJvcHMge1xuICBkYXRhOiBhbnlbXVxuICBjb2x1bW5zOiBzdHJpbmdbXVxuICB2aXN1YWxpemF0aW9uVHlwZTogc3RyaW5nXG4gIGdlbmVyYXRlZENvbmZpZz86IGFueVxufVxuXG5pbnRlcmZhY2UgRGF0YU1hcHBpbmcge1xuICB4QXhpczogc3RyaW5nXG4gIHlBeGlzOiBzdHJpbmdcbiAgekF4aXM6IHN0cmluZ1xuICBjb2xvckJ5OiBzdHJpbmdcbiAgc2l6ZUJ5OiBzdHJpbmdcbiAgY2F0ZWdvcnlCeT86IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgRGF0YUFuYWx5c2lzIHtcbiAgbWFwcGluZzogRGF0YU1hcHBpbmdcbiAgbnVtZXJpY0NvbHVtbnM6IHN0cmluZ1tdXG4gIGNhdGVnb3JpY2FsQ29sdW1uczogc3RyaW5nW11cbiAgdGVtcG9yYWxDb2x1bW5zOiBzdHJpbmdbXVxuICBkYXRhUmFuZ2VzOiB7IFtrZXk6IHN0cmluZ106IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyOyB2YWx1ZXM6IG51bWJlcltdIH0gfVxuICBjYXRlZ29yaWVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIH1cbiAgZGF0YVR5cGVzOiB7IFtrZXk6IHN0cmluZ106IFwibnVtZXJpY1wiIHwgXCJjYXRlZ29yaWNhbFwiIHwgXCJ0ZW1wb3JhbFwiIHwgXCJtaXhlZFwiIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FudmFzM0RWaXN1YWxpemF0aW9uKHtcbiAgZGF0YSxcbiAgY29sdW1ucyxcbiAgdmlzdWFsaXphdGlvblR5cGUsXG4gIGdlbmVyYXRlZENvbmZpZyxcbn06IENhbnZhczNEVmlzdWFsaXphdGlvblByb3BzKSB7XG4gIGNvbnN0IHBsb3RSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IFtpc1YwR2VuZXJhdGVkLCBzZXRJc1YwR2VuZXJhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbcGxvdGx5TG9hZGVkLCBzZXRQbG90bHlMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtkYXRhTWFwcGluZywgc2V0RGF0YU1hcHBpbmddID0gdXNlU3RhdGU8RGF0YU1hcHBpbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBbY3VycmVudE1vZGVsLCBzZXRDdXJyZW50TW9kZWxdID0gdXNlU3RhdGU8c3RyaW5nPihcInNjYXR0ZXIzZFwiKVxuICBjb25zdCBbZGF0YUFuYWx5c2lzLCBzZXREYXRhQW5hbHlzaXNdID0gdXNlU3RhdGU8RGF0YUFuYWx5c2lzIHwgbnVsbD4obnVsbClcblxuICAvLyBGb25jdGlvbiBwb3VyIGfDqXJlciBsYSB2aXN1YWxpc2F0aW9uIGfDqW7DqXLDqWUgcGFyIGwnQVBJXG4gIGNvbnN0IHJlbmRlclYwVmlzdWFsaXphdGlvbiA9IGFzeW5jIChjb25maWc6IGFueSkgPT4ge1xuICAgIGNvbnN0IHBsb3RFbGVtZW50ID0gcGxvdFJlZi5jdXJyZW50XG4gICAgaWYgKCFwbG90RWxlbWVudCkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgLy8gVXRpbGlzZXIgbGEgY29uZmlndXJhdGlvbiBnw6luw6lyw6llIHBhciBsJ0FQSVxuICAgICAgaWYgKGNvbmZpZy5wbG90RGF0YSAmJiBjb25maWcubGF5b3V0KSB7XG4gICAgICAgIGF3YWl0IHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90RWxlbWVudCwgY29uZmlnLnBsb3REYXRhLCBjb25maWcubGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayBzdXIgbGEgY29uZmlndXJhdGlvbiBwYXIgZMOpZmF1dFxuICAgICAgICBjb25zdCBhbmFseXNpcyA9IGFuYWx5emVEYXRhSW50ZWxsaWdlbnRseSgpXG4gICAgICAgIGlmICghYW5hbHlzaXMpIHJldHVyblxuICAgICAgICByZW5kZXJNb2RlbFNwZWNpZmljVmlzdWFsaXphdGlvbigpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJldXIgbG9ycyBkdSByZW5kdSBWMDpcIiwgZXJyb3IpXG4gICAgICBjb25zdCBhbmFseXNpcyA9IGFuYWx5emVEYXRhSW50ZWxsaWdlbnRseSgpXG4gICAgICBpZiAoIWFuYWx5c2lzKSByZXR1cm5cbiAgICAgIHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICAgIH1cbiAgfVxuXG4gIC8vIENoYXJnZXIgUGxvdGx5LmpzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXdpbmRvdy5QbG90bHkpIHtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcbiAgICAgIHNjcmlwdC5zcmMgPSBcImh0dHBzOi8vY2RuLnBsb3QubHkvcGxvdGx5LTIuMzUuMi5taW4uanNcIlxuICAgICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHNldFBsb3RseUxvYWRlZCh0cnVlKVxuICAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJldXIgbG9ycyBkdSBjaGFyZ2VtZW50IGRlIFBsb3RseS5qc1wiKVxuICAgICAgICBzZXRQbG90bHlMb2FkZWQoZmFsc2UpXG4gICAgICB9XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5QbG90bHkpIHtcbiAgICAgIHNldFBsb3RseUxvYWRlZCh0cnVlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXBsb3RseUxvYWRlZCB8fCAhcGxvdFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgIGNvbnN0IHVwZGF0ZVZpc3VhbGl6YXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwbG90RWxlbWVudCA9IHBsb3RSZWYuY3VycmVudFxuICAgICAgaWYgKCFwbG90RWxlbWVudCkgcmV0dXJuXG5cbiAgICAgIC8vIE5ldHRveWVyIGxlIGdyYXBoaXF1ZSBwcsOpY8OpZGVudFxuICAgICAgaWYgKHBsb3RFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgd2luZG93LlBsb3RseS5wdXJnZShwbG90RWxlbWVudClcbiAgICAgIH1cblxuICAgICAgc2V0Q3VycmVudE1vZGVsKHZpc3VhbGl6YXRpb25UeXBlKVxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZ2VuZXJhdGVkQ29uZmlnKSB7XG4gICAgICAgICAgYXdhaXQgcmVuZGVyVjBWaXN1YWxpemF0aW9uKGdlbmVyYXRlZENvbmZpZylcbiAgICAgICAgICBzZXRJc1YwR2VuZXJhdGVkKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgcmVuZGVyTW9kZWxTcGVjaWZpY1Zpc3VhbGl6YXRpb24oKVxuICAgICAgICAgIHNldElzVjBHZW5lcmF0ZWQoZmFsc2UpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJldXIgbG9ycyBkZSBsYSBtaXNlIMOgIGpvdXIgZGUgbGEgdmlzdWFsaXNhdGlvbjpcIiwgZXJyb3IpXG4gICAgICAgIC8vIEVuIGNhcyBkJ2VycmV1ciwgb24gcmV2aWVudCBhdSBudWFnZSBkZSBwb2ludHMgYmFzaXF1ZVxuICAgICAgICByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXplRGF0YUludGVsbGlnZW50bHkoKSB8fCB7XG4gICAgICAgICAgbWFwcGluZzoge1xuICAgICAgICAgICAgeEF4aXM6IGNvbHVtbnNbMF0gfHwgXCJpbmRleFwiLFxuICAgICAgICAgICAgeUF4aXM6IGNvbHVtbnNbMV0gfHwgXCJpbmRleFwiLFxuICAgICAgICAgICAgekF4aXM6IGNvbHVtbnNbMl0gfHwgXCJpbmRleFwiLFxuICAgICAgICAgICAgY29sb3JCeTogY29sdW1uc1swXSB8fCBcImluZGV4XCIsXG4gICAgICAgICAgICBzaXplQnk6IGNvbHVtbnNbMV0gfHwgXCJpbmRleFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBudW1lcmljQ29sdW1uczogY29sdW1ucyxcbiAgICAgICAgICBjYXRlZ29yaWNhbENvbHVtbnM6IFtdLFxuICAgICAgICAgIHRlbXBvcmFsQ29sdW1uczogW10sXG4gICAgICAgICAgZGF0YVJhbmdlczoge30sXG4gICAgICAgICAgY2F0ZWdvcmllczoge30sXG4gICAgICAgICAgZGF0YVR5cGVzOiB7fVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVZpc3VhbGl6YXRpb24oKVxuICB9LCBbcGxvdGx5TG9hZGVkLCBkYXRhLCBjb2x1bW5zLCB2aXN1YWxpemF0aW9uVHlwZSwgZ2VuZXJhdGVkQ29uZmlnXSlcblxuICAvLyBBbmFseXNlIGNvbXBsw6h0ZSBldCBpbnRlbGxpZ2VudGUgZGVzIGRvbm7DqWVzXG4gIGNvbnN0IGFuYWx5emVEYXRhSW50ZWxsaWdlbnRseSA9ICgpOiBEYXRhQW5hbHlzaXMgfCBudWxsID0+IHtcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDAgfHwgIWNvbHVtbnMgfHwgY29sdW1ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgYW5hbHlzaXM6IERhdGFBbmFseXNpcyA9IHtcbiAgICAgIG1hcHBpbmc6IHt9IGFzIERhdGFNYXBwaW5nLFxuICAgICAgbnVtZXJpY0NvbHVtbnM6IFtdLFxuICAgICAgY2F0ZWdvcmljYWxDb2x1bW5zOiBbXSxcbiAgICAgIHRlbXBvcmFsQ29sdW1uczogW10sXG4gICAgICBkYXRhUmFuZ2VzOiB7fSxcbiAgICAgIGNhdGVnb3JpZXM6IHt9LFxuICAgICAgZGF0YVR5cGVzOiB7fSxcbiAgICB9XG5cbiAgICAvLyBBbmFseXNlciBjaGFxdWUgY29sb25uZSBlbiBkw6l0YWlsXG4gICAgY29sdW1ucy5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGRhdGEubWFwKChyb3cpID0+IHJvd1tjb2xdKS5maWx0ZXIoKHZhbCkgPT4gdmFsICE9IG51bGwgJiYgdmFsICE9PSBcIlwiKVxuXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhbmFseXNpcy5kYXRhVHlwZXNbY29sXSA9IFwibWl4ZWRcIlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVGVzdCBudW3DqXJpcXVlXG4gICAgICBjb25zdCBudW1lcmljVmFsdWVzID0gdmFsdWVzLm1hcCgodmFsKSA9PiBOdW1iZXIucGFyc2VGbG9hdCh2YWwpKS5maWx0ZXIoKHZhbCkgPT4gIWlzTmFOKHZhbCkgJiYgaXNGaW5pdGUodmFsKSlcbiAgICAgIGNvbnN0IG51bWVyaWNSYXRpbyA9IG51bWVyaWNWYWx1ZXMubGVuZ3RoIC8gdmFsdWVzLmxlbmd0aFxuXG4gICAgICAvLyBUZXN0IHRlbXBvcmVsXG4gICAgICBjb25zdCBkYXRlVmFsdWVzID0gdmFsdWVzLmZpbHRlcigodmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWwpXG4gICAgICAgIHJldHVybiAhaXNOYU4oZGF0ZS5nZXRUaW1lKCkpICYmIGRhdGUuZ2V0RnVsbFllYXIoKSA+IDE5MDAgJiYgZGF0ZS5nZXRGdWxsWWVhcigpIDwgMjEwMFxuICAgICAgfSlcbiAgICAgIGNvbnN0IHRlbXBvcmFsUmF0aW8gPSBkYXRlVmFsdWVzLmxlbmd0aCAvIHZhbHVlcy5sZW5ndGhcblxuICAgICAgLy8gVGVzdCBjYXTDqWdvcmllbFxuICAgICAgY29uc3QgdW5pcXVlVmFsdWVzID0gWy4uLm5ldyBTZXQodmFsdWVzKV1cbiAgICAgIGNvbnN0IHVuaXF1ZVJhdGlvID0gdW5pcXVlVmFsdWVzLmxlbmd0aCAvIHZhbHVlcy5sZW5ndGhcblxuICAgICAgLy8gQ2xhc3NpZmljYXRpb24gaW50ZWxsaWdlbnRlXG4gICAgICBpZiAodGVtcG9yYWxSYXRpbyA+IDAuNykge1xuICAgICAgICBhbmFseXNpcy5kYXRhVHlwZXNbY29sXSA9IFwidGVtcG9yYWxcIlxuICAgICAgICBhbmFseXNpcy50ZW1wb3JhbENvbHVtbnMucHVzaChjb2wpXG4gICAgICAgIC8vIENvbnZlcnRpciBlbiB0aW1lc3RhbXBzIHBvdXIgbGVzIGNhbGN1bHNcbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IGRhdGVWYWx1ZXMubWFwKCh2YWwpID0+IG5ldyBEYXRlKHZhbCkuZ2V0VGltZSgpKVxuICAgICAgICBhbmFseXNpcy5kYXRhUmFuZ2VzW2NvbF0gPSB7XG4gICAgICAgICAgbWluOiBNYXRoLm1pbiguLi50aW1lc3RhbXBzKSxcbiAgICAgICAgICBtYXg6IE1hdGgubWF4KC4uLnRpbWVzdGFtcHMpLFxuICAgICAgICAgIHZhbHVlczogdGltZXN0YW1wcyxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChudW1lcmljUmF0aW8gPiAwLjcpIHtcbiAgICAgICAgYW5hbHlzaXMuZGF0YVR5cGVzW2NvbF0gPSBcIm51bWVyaWNcIlxuICAgICAgICBhbmFseXNpcy5udW1lcmljQ29sdW1ucy5wdXNoKGNvbClcbiAgICAgICAgYW5hbHlzaXMuZGF0YVJhbmdlc1tjb2xdID0ge1xuICAgICAgICAgIG1pbjogTWF0aC5taW4oLi4ubnVtZXJpY1ZhbHVlcyksXG4gICAgICAgICAgbWF4OiBNYXRoLm1heCguLi5udW1lcmljVmFsdWVzKSxcbiAgICAgICAgICB2YWx1ZXM6IG51bWVyaWNWYWx1ZXMsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodW5pcXVlUmF0aW8gPCAwLjMgfHwgdW5pcXVlVmFsdWVzLmxlbmd0aCA8PSAyMCkge1xuICAgICAgICBhbmFseXNpcy5kYXRhVHlwZXNbY29sXSA9IFwiY2F0ZWdvcmljYWxcIlxuICAgICAgICBhbmFseXNpcy5jYXRlZ29yaWNhbENvbHVtbnMucHVzaChjb2wpXG4gICAgICAgIGFuYWx5c2lzLmNhdGVnb3JpZXNbY29sXSA9IHVuaXF1ZVZhbHVlcy5zbGljZSgwLCAyMCkgLy8gTGltaXRlciDDoCAyMCBjYXTDqWdvcmllc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5hbHlzaXMuZGF0YVR5cGVzW2NvbF0gPSBcIm1peGVkXCJcbiAgICAgICAgaWYgKG51bWVyaWNWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFuYWx5c2lzLmRhdGFSYW5nZXNbY29sXSA9IHtcbiAgICAgICAgICAgIG1pbjogTWF0aC5taW4oLi4ubnVtZXJpY1ZhbHVlcyksXG4gICAgICAgICAgICBtYXg6IE1hdGgubWF4KC4uLm51bWVyaWNWYWx1ZXMpLFxuICAgICAgICAgICAgdmFsdWVzOiBudW1lcmljVmFsdWVzLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBDcsOpZXIgdW4gbWFwcGluZyBpbnRlbGxpZ2VudCBiYXPDqSBzdXIgbGVzIHR5cGVzIGRlIGRvbm7DqWVzXG4gICAgY29uc3QgYWxsTnVtZXJpY0NvbHMgPSBbLi4uYW5hbHlzaXMubnVtZXJpY0NvbHVtbnMsIC4uLmFuYWx5c2lzLnRlbXBvcmFsQ29sdW1uc11cblxuICAgIGlmIChhbGxOdW1lcmljQ29scy5sZW5ndGggPj0gMykge1xuICAgICAgYW5hbHlzaXMubWFwcGluZyA9IHtcbiAgICAgICAgeEF4aXM6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICB5QXhpczogYWxsTnVtZXJpY0NvbHNbMV0sXG4gICAgICAgIHpBeGlzOiBhbGxOdW1lcmljQ29sc1syXSxcbiAgICAgICAgY29sb3JCeTogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIHNpemVCeTogYWxsTnVtZXJpY0NvbHMubGVuZ3RoID4gMyA/IGFsbE51bWVyaWNDb2xzWzNdIDogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIGNhdGVnb3J5Qnk6IGFuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1uc1swXSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFsbE51bWVyaWNDb2xzLmxlbmd0aCA9PT0gMikge1xuICAgICAgYW5hbHlzaXMubWFwcGluZyA9IHtcbiAgICAgICAgeEF4aXM6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICB5QXhpczogYWxsTnVtZXJpY0NvbHNbMV0sXG4gICAgICAgIHpBeGlzOiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgY29sb3JCeTogYWxsTnVtZXJpY0NvbHNbMV0sXG4gICAgICAgIHNpemVCeTogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIGNhdGVnb3J5Qnk6IGFuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1uc1swXSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFsbE51bWVyaWNDb2xzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgYW5hbHlzaXMubWFwcGluZyA9IHtcbiAgICAgICAgeEF4aXM6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICB5QXhpczogXCJpbmRleFwiLFxuICAgICAgICB6QXhpczogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIGNvbG9yQnk6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICBzaXplQnk6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICBjYXRlZ29yeUJ5OiBhbmFseXNpcy5jYXRlZ29yaWNhbENvbHVtbnNbMF0sXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFV0aWxpc2VyIGxlcyBpbmRpY2VzIGV0IGNhdMOpZ29yaWVzXG4gICAgICBhbmFseXNpcy5tYXBwaW5nID0ge1xuICAgICAgICB4QXhpczogXCJpbmRleFwiLFxuICAgICAgICB5QXhpczogYW5hbHlzaXMuY2F0ZWdvcmljYWxDb2x1bW5zWzBdIHx8IFwiaW5kZXhcIixcbiAgICAgICAgekF4aXM6IFwiY291bnRcIixcbiAgICAgICAgY29sb3JCeTogYW5hbHlzaXMuY2F0ZWdvcmljYWxDb2x1bW5zWzBdIHx8IFwiaW5kZXhcIixcbiAgICAgICAgc2l6ZUJ5OiBcImNvdW50XCIsXG4gICAgICAgIGNhdGVnb3J5Qnk6IGFuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1uc1swXSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5hbHlzaXNcbiAgfVxuXG4gIC8vIEZvbmN0aW9uIHByaW5jaXBhbGUgcXVpIHJvdXRlIHZlcnMgbGEgYm9ubmUgdmlzdWFsaXNhdGlvbiBzZWxvbiBsZSBtb2TDqGxlXG4gIGNvbnN0IHJlbmRlck1vZGVsU3BlY2lmaWNWaXN1YWxpemF0aW9uID0gKCkgPT4ge1xuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVuZGVyRGVtb1Zpc3VhbGl6YXRpb24oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYW5hbHlzaXMgPSBhbmFseXplRGF0YUludGVsbGlnZW50bHkoKVxuICAgIGlmICghYW5hbHlzaXMpIHtcbiAgICAgIHJlbmRlckRlbW9WaXN1YWxpemF0aW9uKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldERhdGFBbmFseXNpcyhhbmFseXNpcylcbiAgICBzZXREYXRhTWFwcGluZyhhbmFseXNpcy5tYXBwaW5nKVxuXG4gICAgLy8gUm91dGVyIHZlcnMgbGEgZm9uY3Rpb24gc3DDqWNpYWxpc8OpZSBzZWxvbiBsZSBtb2TDqGxlIGV4YWN0XG4gICAgc3dpdGNoICh2aXN1YWxpemF0aW9uVHlwZSkge1xuICAgICAgLy8gTlVBR0VTXG4gICAgICBjYXNlIFwic2NhdHRlcjNkXCI6XG4gICAgICAgIHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInNjYXR0ZXJfYnViYmxlXCI6XG4gICAgICAgIHJlbmRlckJ1YmJsZVNjYXR0ZXIoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhdHRlcl9hbmltYXRlZFwiOlxuICAgICAgICByZW5kZXJBbmltYXRlZFNjYXR0ZXIoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhdHRlcl9jbHVzdGVyZWRcIjpcbiAgICAgICAgcmVuZGVyQ2x1c3RlcmVkU2NhdHRlcihhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzY2F0dGVyX2RlbnNpdHlcIjpcbiAgICAgICAgcmVuZGVyRGVuc2l0eVNjYXR0ZXIoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIFNVUkZBQ0VTXG4gICAgICBjYXNlIFwic3VyZmFjZTNkXCI6XG4gICAgICAgIHJlbmRlckNsYXNzaWNTdXJmYWNlKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInN1cmZhY2VfY29udG91clwiOlxuICAgICAgICByZW5kZXJDb250b3VyU3VyZmFjZShhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzdXJmYWNlX21lc2hcIjpcbiAgICAgICAgcmVuZGVyTWVzaFN1cmZhY2UoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic3VyZmFjZV9ncmFkaWVudFwiOlxuICAgICAgICByZW5kZXJHcmFkaWVudFN1cmZhY2UoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIEFSQ0hJVEVDVFVSRVxuICAgICAgY2FzZSBcImJhcnMzZFwiOlxuICAgICAgICByZW5kZXJDbGFzc2ljQmFycyhhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJiYXJzX2dyb3VwZWRcIjpcbiAgICAgICAgcmVuZGVyR3JvdXBlZEJhcnMoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiYmFyc19jeWxpbmRyaWNhbFwiOlxuICAgICAgICByZW5kZXJDeWxpbmRyaWNhbEJhcnMoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiYmFyc19weXJhbWlkXCI6XG4gICAgICAgIHJlbmRlclB5cmFtaWRCYXJzKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBHw4lPTcOJVFJJUVVFU1xuICAgICAgY2FzZSBcInNwaGVyZV9wYWNrXCI6XG4gICAgICAgIHJlbmRlclNwaGVyZVBhY2soYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiY3ViZV9tYXRyaXhcIjpcbiAgICAgICAgcmVuZGVyQ3ViZU1hdHJpeChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJjb25lX2ZpZWxkXCI6XG4gICAgICAgIHJlbmRlckNvbmVGaWVsZChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJoZWxpeF9zcGlyYWxcIjpcbiAgICAgICAgcmVuZGVySGVsaXhTcGlyYWwoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIEFSVElTVElRVUVTXG4gICAgICBjYXNlIFwibWFuZGFsYV8zZFwiOlxuICAgICAgICByZW5kZXJNYW5kYWxhM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiZnJhY3RhbF8zZFwiOlxuICAgICAgICByZW5kZXJGcmFjdGFsM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiY3J5c3RhbF8zZFwiOlxuICAgICAgICByZW5kZXJDcnlzdGFsM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiZ2FsYXh5XzNkXCI6XG4gICAgICAgIHJlbmRlckdhbGF4eTNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImRuYV9oZWxpeFwiOlxuICAgICAgICByZW5kZXJETkFIZWxpeChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gUsOJU0VBVVhcbiAgICAgIGNhc2UgXCJuZXR3b3JrXzNkXCI6XG4gICAgICAgIHJlbmRlck5ldHdvcmszRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJ0cmVlXzNkXCI6XG4gICAgICAgIHJlbmRlclRyZWUzRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gVEVNUE9SRUxTXG4gICAgICBjYXNlIFwidGltZWxpbmVfM2RcIjpcbiAgICAgICAgcmVuZGVyVGltZWxpbmUzRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJ3YXZlX3RlbXBvcmFsXCI6XG4gICAgICAgIHJlbmRlcldhdmVUZW1wb3JhbChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzcGlyYWxfdGltZVwiOlxuICAgICAgICByZW5kZXJTcGlyYWxUaW1lKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBHw4lPR1JBUEhJUVVFU1xuICAgICAgY2FzZSBcImdsb2JlXzNkXCI6XG4gICAgICAgIHJlbmRlckdsb2JlM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwidGVycmFpbl8zZFwiOlxuICAgICAgICByZW5kZXJUZXJyYWluM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIFNDSUVOVElGSVFVRVNcbiAgICAgIGNhc2UgXCJtb2xlY3VsZV8zZFwiOlxuICAgICAgICByZW5kZXJNb2xlY3VsZTNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInZlY3Rvcl9maWVsZFwiOlxuICAgICAgICByZW5kZXJWZWN0b3JGaWVsZChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gU1RBVElTVElRVUVTXG4gICAgICBjYXNlIFwiaGlzdG9ncmFtXzNkXCI6XG4gICAgICAgIHJlbmRlckhpc3RvZ3JhbTNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImJveF9wbG90XzNkXCI6XG4gICAgICAgIHJlbmRlckJveFBsb3QzRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gICAgfVxuICB9XG5cbiAgLy8gRm9uY3Rpb24gdXRpbGl0YWlyZSBwb3VyIGV4dHJhaXJlIGxlcyB2YWxldXJzIGF2ZWMgbCdhbmFseXNlXG4gIGNvbnN0IGdldFZhbHVlc0Zyb21BbmFseXNpcyA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzLCBrZXk6IGtleW9mIERhdGFNYXBwaW5nKTogbnVtYmVyW10gPT4ge1xuICAgIGNvbnN0IGNvbHVtbiA9IGFuYWx5c2lzLm1hcHBpbmdba2V5XVxuXG4gICAgaWYgKGNvbHVtbiA9PT0gXCJpbmRleFwiKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoKF8sIGkpID0+IGkpXG4gICAgfSBlbHNlIGlmIChjb2x1bW4gPT09IFwiY291bnRcIikge1xuICAgICAgcmV0dXJuIGRhdGEubWFwKCgpID0+IDEpXG4gICAgfSBlbHNlIGlmIChjb2x1bW4gJiYgY29sdW1ucy5pbmNsdWRlcyhjb2x1bW4pKSB7XG4gICAgICBpZiAoYW5hbHlzaXMuZGF0YVJhbmdlc1tjb2x1bW5dKSB7XG4gICAgICAgIC8vIFV0aWxpc2VyIGxlcyB2YWxldXJzIHByw6ktY2FsY3Vsw6llcyBwb3VyIGxlcyBjb2xvbm5lcyBudW3DqXJpcXVlcy90ZW1wb3JlbGxlc1xuICAgICAgICBjb25zdCByYW5nZSA9IGFuYWx5c2lzLmRhdGFSYW5nZXNbY29sdW1uXVxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoKHJvdywgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IHJvd1tjb2x1bW5dXG4gICAgICAgICAgaWYgKGFuYWx5c2lzLmRhdGFUeXBlc1tjb2x1bW5dID09PSBcInRlbXBvcmFsXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKHZhbCkuZ2V0VGltZSgpXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4odGltZXN0YW1wKSA/IHJhbmdlLm1pbiA6IHRpbWVzdGFtcFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBudW1WYWwgPSBOdW1iZXIucGFyc2VGbG9hdCh2YWwpXG4gICAgICAgICAgICByZXR1cm4gIWlzTmFOKG51bVZhbCkgJiYgaXNGaW5pdGUobnVtVmFsKSA/IG51bVZhbCA6IHJhbmdlLm1pblxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYW5hbHlzaXMuY2F0ZWdvcmllc1tjb2x1bW5dKSB7XG4gICAgICAgIC8vIENvbnZlcnRpciBsZXMgY2F0w6lnb3JpZXMgZW4gaW5kaWNlcyBudW3DqXJpcXVlc1xuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gYW5hbHlzaXMuY2F0ZWdvcmllc1tjb2x1bW5dXG4gICAgICAgIHJldHVybiBkYXRhLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsID0gcm93W2NvbHVtbl1cbiAgICAgICAgICBjb25zdCBpbmRleCA9IGNhdGVnb3JpZXMuaW5kZXhPZih2YWwpXG4gICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IDBcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5tYXAoKF8sIGkpID0+IGkpXG4gIH1cblxuICAvLyBWSVNVQUxJU0FUSU9OUyBTUMOJQ0lBTElTw4lFUyBBVkVDIERPTk7DiUVTIERZTkFNSVFVRVNcblxuICAvLyAxLiBOVUFHRSBDTEFTU0lRVUUgLSBBZGFwdMOpIGF1eCBkb25uw6llc1xuICBjb25zdCByZW5kZXJDbGFzc2ljU2NhdHRlciA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgeFZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ4QXhpc1wiKVxuICAgIGNvbnN0IHlWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieUF4aXNcIilcbiAgICBjb25zdCB6VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInpBeGlzXCIpXG4gICAgY29uc3QgY29sb3JWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiY29sb3JCeVwiKVxuXG4gICAgLy8gQWRhcHRlciBsYSB0YWlsbGUgZGVzIG1hcnF1ZXVycyBzZWxvbiBsYSBkZW5zaXTDqSBkZXMgZG9ubsOpZXNcbiAgICBjb25zdCBtYXJrZXJTaXplID0gTWF0aC5tYXgoMywgTWF0aC5taW4oMTIsIDEwMCAvIE1hdGguc3FydChkYXRhLmxlbmd0aCkpKVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2Vyc1wiLFxuICAgICAgICB4OiB4VmFsdWVzLFxuICAgICAgICB5OiB5VmFsdWVzLFxuICAgICAgICB6OiB6VmFsdWVzLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBzaXplOiBtYXJrZXJTaXplLFxuICAgICAgICAgIGNvbG9yOiBjb2xvclZhbHVlcyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlZpcmlkaXNcIixcbiAgICAgICAgICBvcGFjaXR5OiBNYXRoLm1heCgwLjYsIDEgLSBkYXRhLmxlbmd0aCAvIDEwMDApLCAvLyBUcmFuc3BhcmVuY2UgYWRhcHTDqWVcbiAgICAgICAgICBjb2xvcmJhcjoge1xuICAgICAgICAgICAgdGl0bGU6IGFuYWx5c2lzLm1hcHBpbmcuY29sb3JCeSxcbiAgICAgICAgICAgIHRpdGxlZm9udDogeyBzaXplOiAxMCB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQ6IGRhdGEubWFwKChyb3csIGkpID0+IHtcbiAgICAgICAgICBsZXQgdG9vbHRpcCA9IGA8Yj5Qb2ludCAke2kgKyAxfTwvYj48YnI+YFxuICAgICAgICAgIHRvb2x0aXAgKz0gYDxiPiR7YW5hbHlzaXMubWFwcGluZy54QXhpc306PC9iPiAke3Jvd1thbmFseXNpcy5tYXBwaW5nLnhBeGlzXSB8fCBcIk4vQVwifTxicj5gXG4gICAgICAgICAgdG9vbHRpcCArPSBgPGI+JHthbmFseXNpcy5tYXBwaW5nLnlBeGlzfTo8L2I+ICR7cm93W2FuYWx5c2lzLm1hcHBpbmcueUF4aXNdIHx8IFwiTi9BXCJ9PGJyPmBcbiAgICAgICAgICB0b29sdGlwICs9IGA8Yj4ke2FuYWx5c2lzLm1hcHBpbmcuekF4aXN9OjwvYj4gJHtyb3dbYW5hbHlzaXMubWFwcGluZy56QXhpc10gfHwgXCJOL0FcIn08YnI+YFxuICAgICAgICAgIGlmIChhbmFseXNpcy5tYXBwaW5nLmNhdGVnb3J5QnkgJiYgcm93W2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeV0pIHtcbiAgICAgICAgICAgIHRvb2x0aXAgKz0gYDxiPiR7YW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5fTo8L2I+ICR7cm93W2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeV19PGJyPmBcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRvb2x0aXBcbiAgICAgICAgfSksXG4gICAgICAgIGhvdmVydGVtcGxhdGU6IFwiJXt0ZXh0fTxleHRyYT48L2V4dHJhPlwiLFxuICAgICAgICBuYW1lOiBgTnVhZ2UgM0QgLSAke2RhdGEubGVuZ3RofSBwb2ludHNgLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVEeW5hbWljTGF5b3V0KFwiTnVhZ2UgM0QgQ2xhc3NpcXVlXCIsIGFuYWx5c2lzKVxuICAgIHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90UmVmLmN1cnJlbnQsIHBsb3REYXRhLCBsYXlvdXQsIGdldFBsb3RDb25maWcoKSlcbiAgfVxuXG4gIC8vIDIuIERFTlNJVMOJIDNEIC0gVnJhaWUgZGVuc2l0w6kgYmFzw6llIHN1ciBsZXMgZG9ubsOpZXMgcsOpZWxsZXNcbiAgY29uc3QgcmVuZGVyRGVuc2l0eVNjYXR0ZXIgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4ge1xuICAgIGNvbnN0IHhWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieEF4aXNcIilcbiAgICBjb25zdCB5VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInlBeGlzXCIpXG4gICAgY29uc3QgelZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ6QXhpc1wiKVxuXG4gICAgLy8gQWRhcHRlciBsYSByw6lzb2x1dGlvbiBkZSBsYSBncmlsbGUgc2Vsb24gbGUgbm9tYnJlIGRlIGRvbm7DqWVzXG4gICAgY29uc3QgZ3JpZFNpemUgPSBNYXRoLm1pbigyNSwgTWF0aC5tYXgoMTAsIE1hdGguc3FydChkYXRhLmxlbmd0aCkpKVxuXG4gICAgY29uc3QgeFJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLnhBeGlzXVxuICAgIGNvbnN0IHlSYW5nZSA9IGFuYWx5c2lzLmRhdGFSYW5nZXNbYW5hbHlzaXMubWFwcGluZy55QXhpc11cbiAgICBjb25zdCB6UmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcuekF4aXNdXG5cbiAgICBpZiAoIXhSYW5nZSB8fCAheVJhbmdlIHx8ICF6UmFuZ2UpIHtcbiAgICAgIHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGVuc2l0eVg6IG51bWJlcltdID0gW11cbiAgICBjb25zdCBkZW5zaXR5WTogbnVtYmVyW10gPSBbXVxuICAgIGNvbnN0IGRlbnNpdHlaOiBudW1iZXJbXSA9IFtdXG4gICAgY29uc3QgZGVuc2l0eUNvbG9yczogbnVtYmVyW10gPSBbXVxuICAgIGNvbnN0IGRlbnNpdHlTaXplczogbnVtYmVyW10gPSBbXVxuXG4gICAgLy8gQ2FsY3VsZXIgbGUgcmF5b24gYWRhcHRhdGlmIGJhc8OpIHN1ciBsZXMgdnJhaWVzIGRvbm7DqWVzXG4gICAgY29uc3QgeFNwYW4gPSB4UmFuZ2UubWF4IC0geFJhbmdlLm1pblxuICAgIGNvbnN0IHlTcGFuID0geVJhbmdlLm1heCAtIHlSYW5nZS5taW5cbiAgICBjb25zdCB6U3BhbiA9IHpSYW5nZS5tYXggLSB6UmFuZ2UubWluXG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoeFNwYW4sIHlTcGFuLCB6U3BhbikgLyAoZ3JpZFNpemUgKiAwLjgpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWRTaXplOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JpZFNpemU7IGorKykge1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGdyaWRTaXplOyBrKyspIHtcbiAgICAgICAgICBjb25zdCB4ID0geFJhbmdlLm1pbiArIChpIC8gKGdyaWRTaXplIC0gMSkpICogeFNwYW5cbiAgICAgICAgICBjb25zdCB5ID0geVJhbmdlLm1pbiArIChqIC8gKGdyaWRTaXplIC0gMSkpICogeVNwYW5cbiAgICAgICAgICBjb25zdCB6ID0gelJhbmdlLm1pbiArIChrIC8gKGdyaWRTaXplIC0gMSkpICogelNwYW5cblxuICAgICAgICAgIC8vIENhbGN1bGVyIGxhIGRlbnNpdMOpIGxvY2FsZSBhdmVjIGxlcyB2cmFpZXMgZG9ubsOpZXNcbiAgICAgICAgICBsZXQgZGVuc2l0eSA9IDBcbiAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGRhdGEubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0geFZhbHVlc1twXSAtIHhcbiAgICAgICAgICAgIGNvbnN0IGR5ID0geVZhbHVlc1twXSAtIHlcbiAgICAgICAgICAgIGNvbnN0IGR6ID0gelZhbHVlc1twXSAtIHpcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeilcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IHJhZGl1cykge1xuICAgICAgICAgICAgICBkZW5zaXR5ICs9IE1hdGguZXhwKC0oZGlzdGFuY2UgKiBkaXN0YW5jZSkgLyAocmFkaXVzICogcmFkaXVzKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXVpbCBhZGFwdGF0aWYgYmFzw6kgc3VyIGxhIGRlbnNpdMOpIG1veWVubmVcbiAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSAoZGF0YS5sZW5ndGggLyAoZ3JpZFNpemUgKiBncmlkU2l6ZSAqIGdyaWRTaXplKSkgKiAwLjVcbiAgICAgICAgICBpZiAoZGVuc2l0eSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgZGVuc2l0eVgucHVzaCh4KVxuICAgICAgICAgICAgZGVuc2l0eVkucHVzaCh5KVxuICAgICAgICAgICAgZGVuc2l0eVoucHVzaCh6KVxuICAgICAgICAgICAgZGVuc2l0eUNvbG9ycy5wdXNoKGRlbnNpdHkpXG4gICAgICAgICAgICBkZW5zaXR5U2l6ZXMucHVzaChNYXRoLm1heCg0LCBNYXRoLm1pbigyMCwgZGVuc2l0eSAqIDE1KSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2Vyc1wiLFxuICAgICAgICB4OiBkZW5zaXR5WCxcbiAgICAgICAgeTogZGVuc2l0eVksXG4gICAgICAgIHo6IGRlbnNpdHlaLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBzaXplOiBkZW5zaXR5U2l6ZXMsXG4gICAgICAgICAgY29sb3I6IGRlbnNpdHlDb2xvcnMsXG4gICAgICAgICAgY29sb3JzY2FsZTogXCJIb3RcIixcbiAgICAgICAgICBvcGFjaXR5OiAwLjcsXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkRlbnNpdMOpIExvY2FsZVwiLFxuICAgICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogZGVuc2l0eVgubWFwKFxuICAgICAgICAgIChfLCBpKSA9PlxuICAgICAgICAgICAgYDxiPlpvbmUgRGVuc2UgJHtpICsgMX08L2I+PGJyPkRlbnNpdMOpOiAke2RlbnNpdHlDb2xvcnNbaV0udG9GaXhlZCgyKX08YnI+UG9zaXRpb246ICgke2RlbnNpdHlYW2ldLnRvRml4ZWQoMSl9LCAke2RlbnNpdHlZW2ldLnRvRml4ZWQoMSl9LCAke2RlbnNpdHlaW2ldLnRvRml4ZWQoMSl9KWAsXG4gICAgICAgICksXG4gICAgICAgIGhvdmVydGVtcGxhdGU6IFwiJXt0ZXh0fTxleHRyYT48L2V4dHJhPlwiLFxuICAgICAgICBuYW1lOiBgRGVuc2l0w6kgM0QgLSAke2RlbnNpdHlYLmxlbmd0aH0gem9uZXNgLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVEeW5hbWljTGF5b3V0KFwiRGVuc2l0w6kgM0QgLSBab25lcyBkZSBDb25jZW50cmF0aW9uXCIsIGFuYWx5c2lzKVxuICAgIHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90UmVmLmN1cnJlbnQsIHBsb3REYXRhLCBsYXlvdXQsIGdldFBsb3RDb25maWcoKSlcbiAgfVxuXG4gIC8vIDMuIEJVTExFUyAzRCAtIFRhaWxsZXMgdnJhaW1lbnQgcHJvcG9ydGlvbm5lbGxlcyBhdXggZG9ubsOpZXNcbiAgY29uc3QgcmVuZGVyQnViYmxlU2NhdHRlciA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgeFZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ4QXhpc1wiKVxuICAgIGNvbnN0IHlWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieUF4aXNcIilcbiAgICBjb25zdCB6VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInpBeGlzXCIpXG4gICAgY29uc3QgY29sb3JWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiY29sb3JCeVwiKVxuICAgIGNvbnN0IHNpemVWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwic2l6ZUJ5XCIpXG5cbiAgICAvLyBBZGFwdGVyIGxhIHRhaWxsZSBkZXMgYnVsbGVzIHNlbG9uIGxlcyBkb25uw6llc1xuICAgIGNvbnN0IG1pblNpemUgPSAxMFxuICAgIGNvbnN0IG1heFNpemUgPSA1MFxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTaXplcyA9IHNpemVWYWx1ZXMubWFwKHYgPT4ge1xuICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oLi4uc2l6ZVZhbHVlcylcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnNpemVWYWx1ZXMpXG4gICAgICByZXR1cm4gbWluU2l6ZSArICgodiAtIG1pbikgLyAobWF4IC0gbWluKSkgKiAobWF4U2l6ZSAtIG1pblNpemUpXG4gICAgfSlcblxuICAgIGNvbnN0IHBsb3REYXRhID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnNcIixcbiAgICAgICAgeDogeFZhbHVlcyxcbiAgICAgICAgeTogeVZhbHVlcyxcbiAgICAgICAgejogelZhbHVlcyxcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgc2l6ZTogbm9ybWFsaXplZFNpemVzLFxuICAgICAgICAgIGNvbG9yOiBjb2xvclZhbHVlcyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlBsYXNtYVwiLFxuICAgICAgICAgIG9wYWNpdHk6IDAuNzUsXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBhbmFseXNpcy5tYXBwaW5nLmNvbG9yQnksXG4gICAgICAgICAgICB0aXRsZWZvbnQ6IHsgc2l6ZTogMTAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxpbmU6IHsgY29sb3I6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpXCIsIHdpZHRoOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQ6IGRhdGEubWFwKChyb3csIGkpID0+IHtcbiAgICAgICAgICBsZXQgdG9vbHRpcCA9IGA8Yj5CdWxsZSAke2kgKyAxfTwvYj48YnI+YFxuICAgICAgICAgIHRvb2x0aXAgKz0gYDxiPlRhaWxsZSAoJHthbmFseXNpcy5tYXBwaW5nLnNpemVCeX0pOjwvYj4gJHtyb3dbYW5hbHlzaXMubWFwcGluZy5zaXplQnldIHx8IFwiTi9BXCJ9PGJyPmBcbiAgICAgICAgICB0b29sdGlwICs9IGA8Yj5Db3VsZXVyICgke2FuYWx5c2lzLm1hcHBpbmcuY29sb3JCeX0pOjwvYj4gJHtyb3dbYW5hbHlzaXMubWFwcGluZy5jb2xvckJ5XSB8fCBcIk4vQVwifTxicj5gXG4gICAgICAgICAgaWYgKGFuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeSAmJiByb3dbYW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5XSkge1xuICAgICAgICAgICAgdG9vbHRpcCArPSBgPGI+Q2F0w6lnb3JpZTo8L2I+ICR7cm93W2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeV19PGJyPmBcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRvb2x0aXBcbiAgICAgICAgfSksXG4gICAgICAgIGhvdmVydGVtcGxhdGU6IFwiJXt0ZXh0fTxleHRyYT48L2V4dHJhPlwiLFxuICAgICAgICBuYW1lOiBgQnVsbGVzIDNEIC0gJHtkYXRhLmxlbmd0aH0gw6lsw6ltZW50c2AsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZUR5bmFtaWNMYXlvdXQoXCJCdWxsZXMgM0QgLSBUYWlsbGVzIFByb3BvcnRpb25uZWxsZXNcIiwgYW5hbHlzaXMpXG4gICAgd2luZG93LlBsb3RseS5uZXdQbG90KHBsb3RSZWYuY3VycmVudCwgcGxvdERhdGEsIGxheW91dCwgZ2V0UGxvdENvbmZpZygpKVxuICB9XG5cbiAgLy8gNC4gTUFOREFMQSAzRCAtIEJhc8OpIHN1ciBsZXMgcGF0dGVybnMgZGVzIGRvbm7DqWVzXG4gIGNvbnN0IHJlbmRlck1hbmRhbGEzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgY29sb3JWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiY29sb3JCeVwiKVxuICAgIGNvbnN0IHNpemVWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwic2l6ZUJ5XCIpXG5cbiAgICBjb25zdCBtYW5kYWxhWDogbnVtYmVyW10gPSBbXVxuICAgIGNvbnN0IG1hbmRhbGFZOiBudW1iZXJbXSA9IFtdXG4gICAgY29uc3QgbWFuZGFsYVo6IG51bWJlcltdID0gW11cbiAgICBjb25zdCBtYW5kYWxhQ29sb3JzOiBudW1iZXJbXSA9IFtdXG4gICAgY29uc3QgbWFuZGFsYVNpemVzOiBudW1iZXJbXSA9IFtdXG5cbiAgICAvLyBVdGlsaXNlciBsZXMgdnJhaWVzIGRvbm7DqWVzIHBvdXIgY3LDqWVyIGxlcyBwYXR0ZXJuc1xuICAgIGRhdGEuZm9yRWFjaCgocm93LCBpKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkSW5kZXggPSBpIC8gZGF0YS5sZW5ndGhcbiAgICAgIGNvbnN0IGNvbG9yVmFsID0gY29sb3JWYWx1ZXNbaV1cbiAgICAgIGNvbnN0IHNpemVWYWwgPSBzaXplVmFsdWVzW2ldXG5cbiAgICAgIC8vIE5vbWJyZSBkZSB0b3VycyBiYXPDqSBzdXIgbGEgdmFyaWFuY2UgZGVzIGRvbm7DqWVzXG4gICAgICBjb25zdCBjb2xvclJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLmNvbG9yQnldXG4gICAgICBjb25zdCB0b3VycyA9IGNvbG9yUmFuZ2UgPyA0ICsgKChjb2xvclZhbCAtIGNvbG9yUmFuZ2UubWluKSAvIChjb2xvclJhbmdlLm1heCAtIGNvbG9yUmFuZ2UubWluKSkgKiA0IDogNlxuXG4gICAgICBjb25zdCBhbmdsZSA9IG5vcm1hbGl6ZWRJbmRleCAqIHRvdXJzICogTWF0aC5QSVxuICAgICAgY29uc3QgcmFkaXVzID0gMSArIE1hdGguc2luKGFuZ2xlICogMykgKiAwLjVcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguc2luKGFuZ2xlICogMikgKiAwLjNcblxuICAgICAgLy8gUG9pbnQgcHJpbmNpcGFsXG4gICAgICBtYW5kYWxhWC5wdXNoKE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cylcbiAgICAgIG1hbmRhbGFZLnB1c2goTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzKVxuICAgICAgbWFuZGFsYVoucHVzaChoZWlnaHQpXG4gICAgICBtYW5kYWxhQ29sb3JzLnB1c2goY29sb3JWYWwpXG4gICAgICBtYW5kYWxhU2l6ZXMucHVzaChNYXRoLm1heCgzLCBNYXRoLm1pbig4LCAoc2l6ZVZhbCAvIChjb2xvclJhbmdlPy5tYXggfHwgMSkpICogNiArIDMpKSlcblxuICAgICAgLy8gUMOpdGFsZXMgYmFzw6lzIHN1ciBsZXMgY2F0w6lnb3JpZXNcbiAgICAgIGNvbnN0IG51bVBldGFscyA9XG4gICAgICAgIGFuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeSAmJiBhbmFseXNpcy5jYXRlZ29yaWVzW2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeV1cbiAgICAgICAgICA/IE1hdGgubWluKDYsIGFuYWx5c2lzLmNhdGVnb3JpZXNbYW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5XS5sZW5ndGgpXG4gICAgICAgICAgOiA1XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtUGV0YWxzOyBqKyspIHtcbiAgICAgICAgY29uc3QgcGV0YWxBbmdsZSA9IGFuZ2xlICsgKGogKiAyICogTWF0aC5QSSkgLyBudW1QZXRhbHNcbiAgICAgICAgY29uc3QgcGV0YWxSYWRpdXMgPSByYWRpdXMgKiAwLjNcbiAgICAgICAgbWFuZGFsYVgucHVzaChNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKyBNYXRoLmNvcyhwZXRhbEFuZ2xlKSAqIHBldGFsUmFkaXVzKVxuICAgICAgICBtYW5kYWxhWS5wdXNoKE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyArIE1hdGguc2luKHBldGFsQW5nbGUpICogcGV0YWxSYWRpdXMpXG4gICAgICAgIG1hbmRhbGFaLnB1c2goaGVpZ2h0ICsgTWF0aC5zaW4ocGV0YWxBbmdsZSAqIDIpICogMC4xKVxuICAgICAgICBtYW5kYWxhQ29sb3JzLnB1c2goY29sb3JWYWwgKiAwLjgpXG4gICAgICAgIG1hbmRhbGFTaXplcy5wdXNoKE1hdGgubWF4KDIsIG1hbmRhbGFTaXplc1ttYW5kYWxhU2l6ZXMubGVuZ3RoIC0gMV0gKiAwLjYpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBwbG90RGF0YSA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzY2F0dGVyM2RcIixcbiAgICAgICAgbW9kZTogXCJtYXJrZXJzXCIsXG4gICAgICAgIHg6IG1hbmRhbGFYLFxuICAgICAgICB5OiBtYW5kYWxhWSxcbiAgICAgICAgejogbWFuZGFsYVosXG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgIHNpemU6IG1hbmRhbGFTaXplcyxcbiAgICAgICAgICBjb2xvcjogbWFuZGFsYUNvbG9ycyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlJhaW5ib3dcIixcbiAgICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBgSGFybW9uaWUgKCR7YW5hbHlzaXMubWFwcGluZy5jb2xvckJ5fSlgLFxuICAgICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogYE1hbmRhbGEgM0QgLSAke2RhdGEubGVuZ3RofSDDqWzDqW1lbnRzIHNvdXJjZWAsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZUR5bmFtaWNMYXlvdXQoXCJNYW5kYWxhIDNEIC0gTW90aWZzIFNhY3LDqXNcIiwgYW5hbHlzaXMpXG4gICAgbGF5b3V0LnNjZW5lLmNhbWVyYSA9IHsgZXllOiB7IHg6IDAsIHk6IDAsIHo6IDIuNSB9IH1cbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICAvLyA1LiBHQUxBWElFIDNEIC0gU3RydWN0dXJlIGJhc8OpZSBzdXIgbGVzIGRvbm7DqWVzXG4gIGNvbnN0IHJlbmRlckdhbGF4eTNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICBjb25zdCBjb2xvclZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJjb2xvckJ5XCIpXG4gICAgY29uc3Qgc2l6ZVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJzaXplQnlcIilcblxuICAgIGNvbnN0IGdhbGF4eVg6IG51bWJlcltdID0gW11cbiAgICBjb25zdCBnYWxheHlZOiBudW1iZXJbXSA9IFtdXG4gICAgY29uc3QgZ2FsYXh5WjogbnVtYmVyW10gPSBbXVxuICAgIGNvbnN0IGdhbGF4eUNvbG9yczogbnVtYmVyW10gPSBbXVxuICAgIGNvbnN0IGdhbGF4eVNpemVzOiBudW1iZXJbXSA9IFtdXG5cbiAgICAvLyBBbmFseXNlciBsYSBkaXN0cmlidXRpb24gcG91ciBjcsOpZXIgbGVzIGJyYXMgZ2FsYWN0aXF1ZXNcbiAgICBjb25zdCBjb2xvclJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLmNvbG9yQnldXG4gICAgY29uc3Qgc2l6ZVJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLnNpemVCeV1cblxuICAgIGRhdGEuZm9yRWFjaCgocm93LCBpKSA9PiB7XG4gICAgICBjb25zdCB0ID0gaSAvIGRhdGEubGVuZ3RoXG4gICAgICBjb25zdCBjb2xvclZhbCA9IGNvbG9yVmFsdWVzW2ldXG4gICAgICBjb25zdCBzaXplVmFsID0gc2l6ZVZhbHVlc1tpXVxuXG4gICAgICAvLyBQb3NpdGlvbiBkYW5zIGxhIGdhbGF4aWUgYmFzw6llIHN1ciBsZXMgdmFsZXVycyBkZXMgZG9ubsOpZXNcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IGNvbG9yUmFuZ2UgPyAoY29sb3JWYWwgLSBjb2xvclJhbmdlLm1pbikgLyAoY29sb3JSYW5nZS5tYXggLSBjb2xvclJhbmdlLm1pbikgOiB0XG4gICAgICBjb25zdCBub3JtYWxpemVkU2l6ZSA9IHNpemVSYW5nZSA/IChzaXplVmFsIC0gc2l6ZVJhbmdlLm1pbikgLyAoc2l6ZVJhbmdlLm1heCAtIHNpemVSYW5nZS5taW4pIDogMC41XG5cbiAgICAgIC8vIEFuZ2xlIGV0IHJheW9uIGJhc8OpcyBzdXIgbGVzIGRvbm7DqWVzXG4gICAgICBjb25zdCBhbmdsZSA9IG5vcm1hbGl6ZWRDb2xvciAqIDYgKiBNYXRoLlBJICsgdCAqIDIgKiBNYXRoLlBJXG4gICAgICBjb25zdCByYWRpdXMgPSBub3JtYWxpemVkU2l6ZSAqIDMgKyB0ICogMC41XG4gICAgICBjb25zdCBoZWlnaHQgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjIgKiAoMSAtIHQpIC8vIFBsdXMgcGxhdCB2ZXJzIGwnZXh0w6lyaWV1clxuXG4gICAgICAvLyBCcmFzIHByaW5jaXBhbFxuICAgICAgZ2FsYXh5WC5wdXNoKE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cylcbiAgICAgIGdhbGF4eVkucHVzaChNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMpXG4gICAgICBnYWxheHlaLnB1c2goaGVpZ2h0KVxuICAgICAgZ2FsYXh5Q29sb3JzLnB1c2goY29sb3JWYWwpXG4gICAgICBnYWxheHlTaXplcy5wdXNoKE1hdGgubWF4KDIsIE1hdGgubWluKDEyLCAoMSAtIG5vcm1hbGl6ZWRTaXplKSAqIDggKyAzKSkpXG5cbiAgICAgIC8vIEJyYXMgc2Vjb25kYWlyZSBzaSBhc3NleiBkZSBkb25uw6llc1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMjApIHtcbiAgICAgICAgY29uc3QgYW5nbGUyID0gYW5nbGUgKyBNYXRoLlBJICogMC44XG4gICAgICAgIGNvbnN0IHJhZGl1czIgPSByYWRpdXMgKiAwLjdcbiAgICAgICAgZ2FsYXh5WC5wdXNoKE1hdGguY29zKGFuZ2xlMikgKiByYWRpdXMyKVxuICAgICAgICBnYWxheHlZLnB1c2goTWF0aC5zaW4oYW5nbGUyKSAqIHJhZGl1czIpXG4gICAgICAgIGdhbGF4eVoucHVzaChoZWlnaHQgKiAwLjUpXG4gICAgICAgIGdhbGF4eUNvbG9ycy5wdXNoKGNvbG9yVmFsICogMC44KVxuICAgICAgICBnYWxheHlTaXplcy5wdXNoKE1hdGgubWF4KDEsIGdhbGF4eVNpemVzW2dhbGF4eVNpemVzLmxlbmd0aCAtIDFdICogMC43KSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2Vyc1wiLFxuICAgICAgICB4OiBnYWxheHlYLFxuICAgICAgICB5OiBnYWxheHlZLFxuICAgICAgICB6OiBnYWxheHlaLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBzaXplOiBnYWxheHlTaXplcyxcbiAgICAgICAgICBjb2xvcjogZ2FsYXh5Q29sb3JzLFxuICAgICAgICAgIGNvbG9yc2NhbGU6IFwiVmlyaWRpc1wiLFxuICAgICAgICAgIG9wYWNpdHk6IDAuOCxcbiAgICAgICAgICBjb2xvcmJhcjoge1xuICAgICAgICAgICAgdGl0bGU6IGBMdW1pbm9zaXTDqSAoJHthbmFseXNpcy5tYXBwaW5nLmNvbG9yQnl9KWAsXG4gICAgICAgICAgICB0aXRsZWZvbnQ6IHsgc2l6ZTogMTAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiBgR2FsYXhpZSAzRCAtICR7ZGF0YS5sZW5ndGh9IMOpdG9pbGVzYCxcbiAgICAgIH0sXG4gICAgXVxuXG4gICAgY29uc3QgbGF5b3V0ID0gY3JlYXRlRHluYW1pY0xheW91dChcIkdhbGF4aWUgM0QgLSBTcGlyYWxlIENvc21pcXVlXCIsIGFuYWx5c2lzKVxuICAgIGxheW91dC5zY2VuZS5iZ2NvbG9yID0gXCJyZ2JhKDAsIDAsIDIwLCAwLjkpXCJcbiAgICBsYXlvdXQuc2NlbmUuY2FtZXJhID0geyBleWU6IHsgeDogMS41LCB5OiAxLjUsIHo6IDEgfSB9XG4gICAgd2luZG93LlBsb3RseS5uZXdQbG90KHBsb3RSZWYuY3VycmVudCwgcGxvdERhdGEsIGxheW91dCwgZ2V0UGxvdENvbmZpZygpKVxuICB9XG5cbiAgLy8gNi4gVElNRUxJTkUgM0QgLSBQb3VyIGRvbm7DqWVzIHRlbXBvcmVsbGVzXG4gIGNvbnN0IHJlbmRlclRpbWVsaW5lM0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4ge1xuICAgIC8vIENoZXJjaGVyIHVuZSBjb2xvbm5lIHRlbXBvcmVsbGVcbiAgICBjb25zdCB0aW1lQ29sdW1uID0gYW5hbHlzaXMudGVtcG9yYWxDb2x1bW5zWzBdIHx8IGFuYWx5c2lzLm1hcHBpbmcueEF4aXNcbiAgICBjb25zdCB2YWx1ZUNvbHVtbiA9IGFuYWx5c2lzLm1hcHBpbmcueUF4aXNcbiAgICBjb25zdCBjb2xvckNvbHVtbiA9IGFuYWx5c2lzLm1hcHBpbmcuY29sb3JCeVxuXG4gICAgY29uc3QgdGltZVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ4QXhpc1wiKVxuICAgIGNvbnN0IHZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ5QXhpc1wiKVxuICAgIGNvbnN0IGNvbG9yVmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcImNvbG9yQnlcIilcblxuICAgIC8vIFRyaWVyIHBhciB0ZW1wcyBzaSBjJ2VzdCB0ZW1wb3JlbFxuICAgIGNvbnN0IHNvcnRlZEluZGljZXMgPSB0aW1lVmFsdWVzLm1hcCgoXywgaSkgPT4gaSkuc29ydCgoYSwgYikgPT4gdGltZVZhbHVlc1thXSAtIHRpbWVWYWx1ZXNbYl0pXG5cbiAgICBjb25zdCB0aW1lbGluZVggPSBzb3J0ZWRJbmRpY2VzLm1hcCgoaSkgPT4gdGltZVZhbHVlc1tpXSlcbiAgICBjb25zdCB0aW1lbGluZVkgPSBzb3J0ZWRJbmRpY2VzLm1hcCgoaSkgPT4gdmFsdWVzW2ldKVxuICAgIGNvbnN0IHRpbWVsaW5lWiA9IHNvcnRlZEluZGljZXMubWFwKChfLCBpKSA9PiBpICogMC4xKSAvLyDDiWzDqXZhdGlvbiBwcm9ncmVzc2l2ZVxuICAgIGNvbnN0IHRpbWVsaW5lQ29sb3JzID0gc29ydGVkSW5kaWNlcy5tYXAoKGkpID0+IGNvbG9yVmFsdWVzW2ldKVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2VycytsaW5lc1wiLFxuICAgICAgICB4OiB0aW1lbGluZVgsXG4gICAgICAgIHk6IHRpbWVsaW5lWSxcbiAgICAgICAgejogdGltZWxpbmVaLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBzaXplOiA2LFxuICAgICAgICAgIGNvbG9yOiB0aW1lbGluZUNvbG9ycyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlZpcmlkaXNcIixcbiAgICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBhbmFseXNpcy5tYXBwaW5nLmNvbG9yQnksXG4gICAgICAgICAgICB0aXRsZWZvbnQ6IHsgc2l6ZTogMTAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgY29sb3I6IFwicmdiYSgxMDAsIDEwMCwgMTAwLCAwLjYpXCIsXG4gICAgICAgICAgd2lkdGg6IDMsXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQ6IHNvcnRlZEluZGljZXMubWFwKChpKSA9PiB7XG4gICAgICAgICAgY29uc3Qgcm93ID0gZGF0YVtpXVxuICAgICAgICAgIGxldCB0b29sdGlwID0gYDxiPlBvaW50IHRlbXBvcmVsICR7aSArIDF9PC9iPjxicj5gXG4gICAgICAgICAgdG9vbHRpcCArPSBgPGI+VGVtcHM6PC9iPiAke3Jvd1t0aW1lQ29sdW1uXSB8fCBcIk4vQVwifTxicj5gXG4gICAgICAgICAgdG9vbHRpcCArPSBgPGI+VmFsZXVyOjwvYj4gJHtyb3dbdmFsdWVDb2x1bW5dIHx8IFwiTi9BXCJ9PGJyPmBcbiAgICAgICAgICByZXR1cm4gdG9vbHRpcFxuICAgICAgICB9KSxcbiAgICAgICAgaG92ZXJ0ZW1wbGF0ZTogXCIle3RleHR9PGV4dHJhPjwvZXh0cmE+XCIsXG4gICAgICAgIG5hbWU6IGBUaW1lbGluZSAzRCAtICR7ZGF0YS5sZW5ndGh9IHBvaW50c2AsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZUR5bmFtaWNMYXlvdXQoXCJUaW1lbGluZSAzRCAtIMOJdm9sdXRpb24gVGVtcG9yZWxsZVwiLCBhbmFseXNpcylcbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICAvLyBGb25jdGlvbnMgZGUgcmVuZHUgc2ltcGxpZmnDqWVzIHBvdXIgbGVzIGF1dHJlcyBtb2TDqGxlc1xuICBjb25zdCByZW5kZXJBbmltYXRlZFNjYXR0ZXIgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckNsdXN0ZXJlZFNjYXR0ZXIgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQnViYmxlU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyQ2xhc3NpY1N1cmZhY2UgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ29udG91clN1cmZhY2UoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlck1lc2hTdXJmYWNlID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNvbnRvdXJTdXJmYWNlKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJHcmFkaWVudFN1cmZhY2UgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ29udG91clN1cmZhY2UoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckNsYXNzaWNCYXJzID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckJ1YmJsZVNjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckdyb3VwZWRCYXJzID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckJ1YmJsZVNjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckN5bGluZHJpY2FsQmFycyA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJCdWJibGVTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJQeXJhbWlkQmFycyA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJCdWJibGVTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJTcGhlcmVQYWNrID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckJ1YmJsZVNjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckN1YmVNYXRyaXggPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckNvbmVGaWVsZCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVySGVsaXhTcGlyYWwgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyRE5BSGVsaXgoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckZyYWN0YWwzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJNYW5kYWxhM0QoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckNyeXN0YWwzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyTmV0d29yazNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJUcmVlM0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlcldhdmVUZW1wb3JhbCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJUaW1lbGluZTNEKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJTcGlyYWxUaW1lID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlclRpbWVsaW5lM0QoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckdsb2JlM0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlclRlcnJhaW4zRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDb250b3VyU3VyZmFjZShhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyTW9sZWN1bGUzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyVmVjdG9yRmllbGQgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckhpc3RvZ3JhbTNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckJ1YmJsZVNjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckJveFBsb3QzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJCdWJibGVTY2F0dGVyKGFuYWx5c2lzKVxuXG4gIC8vIDcuIFNVUkZBQ0UgQVZFQyBDT05UT1VSUyAtIEJhc8OpZSBzdXIgbGVzIHZyYWllcyBkb25uw6llc1xuICBjb25zdCByZW5kZXJDb250b3VyU3VyZmFjZSA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgeFZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ4QXhpc1wiKVxuICAgIGNvbnN0IHlWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieUF4aXNcIilcbiAgICBjb25zdCB6VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInpBeGlzXCIpXG5cbiAgICBjb25zdCB4UmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcueEF4aXNdXG4gICAgY29uc3QgeVJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLnlBeGlzXVxuXG4gICAgaWYgKCF4UmFuZ2UgfHwgIXlSYW5nZSkge1xuICAgICAgcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBBZGFwdGVyIGxhIHLDqXNvbHV0aW9uIHNlbG9uIGxhIGRlbnNpdMOpIGRlcyBkb25uw6llc1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbigzMCwgTWF0aC5tYXgoMTUsIE1hdGguc3FydChkYXRhLmxlbmd0aCkpKVxuICAgIGNvbnN0IHhNaW4gPSB4UmFuZ2UubWluXG4gICAgY29uc3QgeE1heCA9IHhSYW5nZS5tYXhcbiAgICBjb25zdCB5TWluID0geVJhbmdlLm1pblxuICAgIGNvbnN0IHlNYXggPSB5UmFuZ2UubWF4XG5cbiAgICBjb25zdCB4R3JpZCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHNpemUgfSwgKF8sIGkpID0+IHhNaW4gKyAoaSAvIChzaXplIC0gMSkpICogKHhNYXggLSB4TWluKSlcbiAgICBjb25zdCB5R3JpZCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHNpemUgfSwgKF8sIGkpID0+IHlNaW4gKyAoaSAvIChzaXplIC0gMSkpICogKHlNYXggLSB5TWluKSlcblxuICAgIGNvbnN0IHN1cmZhY2UgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCByb3cgPSBbXVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplOyBqKyspIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0WCA9IHhHcmlkW2pdXG4gICAgICAgIGNvbnN0IHRhcmdldFkgPSB5R3JpZFtpXVxuXG4gICAgICAgIC8vIEludGVycG9sYXRpb24gcG9uZMOpcsOpZSBwYXIgbGEgZGlzdGFuY2VcbiAgICAgICAgbGV0IHdlaWdodGVkU3VtID0gMFxuICAgICAgICBsZXQgdG90YWxXZWlnaHQgPSAwXG4gICAgICAgIGNvbnN0IG1heERpc3RhbmNlID0gTWF0aC5zcXJ0KCh4TWF4IC0geE1pbikgKiogMiArICh5TWF4IC0geU1pbikgKiogMikgLyA1XG5cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgY29uc3QgZHggPSB4VmFsdWVzW2tdIC0gdGFyZ2V0WFxuICAgICAgICAgIGNvbnN0IGR5ID0geVZhbHVlc1trXSAtIHRhcmdldFlcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSBNYXRoLmV4cCgtKGRpc3RhbmNlICogZGlzdGFuY2UpIC8gKG1heERpc3RhbmNlICogbWF4RGlzdGFuY2UpKVxuICAgICAgICAgICAgd2VpZ2h0ZWRTdW0gKz0gelZhbHVlc1trXSAqIHdlaWdodFxuICAgICAgICAgICAgdG90YWxXZWlnaHQgKz0gd2VpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcm93LnB1c2godG90YWxXZWlnaHQgPiAwID8gd2VpZ2h0ZWRTdW0gLyB0b3RhbFdlaWdodCA6IDApXG4gICAgICB9XG4gICAgICBzdXJmYWNlLnB1c2gocm93KVxuICAgIH1cblxuICAgIGNvbnN0IHBsb3REYXRhID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInN1cmZhY2VcIixcbiAgICAgICAgejogc3VyZmFjZSxcbiAgICAgICAgeDogeEdyaWQsXG4gICAgICAgIHk6IHlHcmlkLFxuICAgICAgICBjb2xvcnNjYWxlOiBcIkVhcnRoXCIsXG4gICAgICAgIGNvbnRvdXJzOiB7XG4gICAgICAgICAgejoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIHVzZWNvbG9ybWFwOiB0cnVlLFxuICAgICAgICAgICAgaGlnaGxpZ2h0Y29sb3I6IFwiIzQyZjQ2MlwiLFxuICAgICAgICAgICAgcHJvamVjdDogeyB6OiB0cnVlIH0sXG4gICAgICAgICAgICB3aWR0aDogMixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjb2xvcmJhcjoge1xuICAgICAgICAgIHRpdGxlOiBhbmFseXNpcy5tYXBwaW5nLnpBeGlzLFxuICAgICAgICAgIHRpdGxlZm9udDogeyBzaXplOiAxMCB9LFxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiBgU3VyZmFjZSAtICR7ZGF0YS5sZW5ndGh9IHBvaW50cyBzb3VyY2VgLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVEeW5hbWljTGF5b3V0KFwiU3VyZmFjZSAzRCAtIExpZ25lcyBkZSBOaXZlYXVcIiwgYW5hbHlzaXMpXG4gICAgd2luZG93LlBsb3RseS5uZXdQbG90KHBsb3RSZWYuY3VycmVudCwgcGxvdERhdGEsIGxheW91dCwgZ2V0UGxvdENvbmZpZygpKVxuICB9XG5cbiAgLy8gOC4gSMOJTElDRSBBRE4gLSBCYXPDqWUgc3VyIGxlcyBzw6lxdWVuY2VzIGRlIGRvbm7DqWVzXG4gIGNvbnN0IHJlbmRlckROQUhlbGl4ID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICBjb25zdCBjb2xvclZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJjb2xvckJ5XCIpXG4gICAgY29uc3Qgc2l6ZVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJzaXplQnlcIilcblxuICAgIGNvbnN0IGRuYVgxOiBudW1iZXJbXSA9IFtdXG4gICAgY29uc3QgZG5hWTE6IG51bWJlcltdID0gW11cbiAgICBjb25zdCBkbmFaMTogbnVtYmVyW10gPSBbXVxuICAgIGNvbnN0IGRuYVgyOiBudW1iZXJbXSA9IFtdXG4gICAgY29uc3QgZG5hWTI6IG51bWJlcltdID0gW11cbiAgICBjb25zdCBkbmFaMjogbnVtYmVyW10gPSBbXVxuICAgIGNvbnN0IGRuYUNvbG9yczogbnVtYmVyW10gPSBbXVxuICAgIGNvbnN0IGRuYVNpemVzOiBudW1iZXJbXSA9IFtdXG5cbiAgICAvLyBVdGlsaXNlciBsZXMgdnJhaWVzIGRvbm7DqWVzIHBvdXIgbW9kdWxlciBsJ2jDqWxpY2VcbiAgICBjb25zdCBjb2xvclJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLmNvbG9yQnldXG4gICAgY29uc3Qgc2l6ZVJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLnNpemVCeV1cblxuICAgIGRhdGEuZm9yRWFjaCgocm93LCBpKSA9PiB7XG4gICAgICBjb25zdCB0ID0gKGkgLyBkYXRhLmxlbmd0aCkgKiA4ICogTWF0aC5QSVxuICAgICAgY29uc3QgeiA9IChpIC8gZGF0YS5sZW5ndGgpICogNFxuXG4gICAgICAvLyBNb2R1bGF0aW9uIGJhc8OpZSBzdXIgbGVzIGRvbm7DqWVzXG4gICAgICBjb25zdCBjb2xvclZhbCA9IGNvbG9yVmFsdWVzW2ldXG4gICAgICBjb25zdCBzaXplVmFsID0gc2l6ZVZhbHVlc1tpXVxuXG4gICAgICBjb25zdCByYWRpdXNNb2R1bGF0aW9uID0gY29sb3JSYW5nZVxuICAgICAgICA/IDEgKyAoMC4zICogKGNvbG9yVmFsIC0gY29sb3JSYW5nZS5taW4pKSAvIChjb2xvclJhbmdlLm1heCAtIGNvbG9yUmFuZ2UubWluKVxuICAgICAgICA6IDFcbiAgICAgIGNvbnN0IGhlaWdodE1vZHVsYXRpb24gPSBzaXplUmFuZ2UgPyAoMC4xICogKHNpemVWYWwgLSBzaXplUmFuZ2UubWluKSkgLyAoc2l6ZVJhbmdlLm1heCAtIHNpemVSYW5nZS5taW4pIDogMFxuXG4gICAgICAvLyBQcmVtaWVyIGJyaW5cbiAgICAgIGRuYVgxLnB1c2goTWF0aC5jb3ModCkgKiByYWRpdXNNb2R1bGF0aW9uKVxuICAgICAgZG5hWTEucHVzaChNYXRoLnNpbih0KSAqIHJhZGl1c01vZHVsYXRpb24pXG4gICAgICBkbmFaMS5wdXNoKHogKyBoZWlnaHRNb2R1bGF0aW9uKVxuXG4gICAgICAvLyBEZXV4acOobWUgYnJpbiAoZMOpY2Fsw6kgZGUgz4ApXG4gICAgICBkbmFYMi5wdXNoKE1hdGguY29zKHQgKyBNYXRoLlBJKSAqIHJhZGl1c01vZHVsYXRpb24pXG4gICAgICBkbmFZMi5wdXNoKE1hdGguc2luKHQgKyBNYXRoLlBJKSAqIHJhZGl1c01vZHVsYXRpb24pXG4gICAgICBkbmFaMi5wdXNoKHogKyBoZWlnaHRNb2R1bGF0aW9uKVxuXG4gICAgICBkbmFDb2xvcnMucHVzaChjb2xvclZhbClcbiAgICAgIGRuYVNpemVzLnB1c2goTWF0aC5tYXgoNCwgTWF0aC5taW4oMTAsIChzaXplVmFsIC8gKHNpemVSYW5nZT8ubWF4IHx8IDEpKSAqIDYgKyA0KSkpXG4gICAgfSlcblxuICAgIGNvbnN0IHBsb3REYXRhID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnMrbGluZXNcIixcbiAgICAgICAgeDogZG5hWDEsXG4gICAgICAgIHk6IGRuYVkxLFxuICAgICAgICB6OiBkbmFaMSxcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgc2l6ZTogZG5hU2l6ZXMsXG4gICAgICAgICAgY29sb3I6IGRuYUNvbG9ycyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlJkWWxCdVwiLFxuICAgICAgICAgIGNvbG9yYmFyOiB7XG4gICAgICAgICAgICB0aXRsZTogYW5hbHlzaXMubWFwcGluZy5jb2xvckJ5LFxuICAgICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbGluZTogeyBjb2xvcjogXCJyZ2JhKDI1NSwgMTAwLCAxMDAsIDAuOClcIiwgd2lkdGg6IDQgfSxcbiAgICAgICAgbmFtZTogYEJyaW4gQUROIDEgLSAke2RhdGEubGVuZ3RofSBiYXNlc2AsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnMrbGluZXNcIixcbiAgICAgICAgeDogZG5hWDIsXG4gICAgICAgIHk6IGRuYVkyLFxuICAgICAgICB6OiBkbmFaMixcbiAgICAgICAgbWFya2VyOiB7IHNpemU6IGRuYVNpemVzLCBjb2xvcjogZG5hQ29sb3JzLCBjb2xvcnNjYWxlOiBcIlJkWWxCdVwiIH0sXG4gICAgICAgIGxpbmU6IHsgY29sb3I6IFwicmdiYSgxMDAsIDEwMCwgMjU1LCAwLjgpXCIsIHdpZHRoOiA0IH0sXG4gICAgICAgIG5hbWU6IGBCcmluIEFETiAyIC0gJHtkYXRhLmxlbmd0aH0gYmFzZXNgLFxuICAgICAgICBzaG93bGVnZW5kOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgXVxuXG4gICAgY29uc3QgbGF5b3V0ID0gY3JlYXRlRHluYW1pY0xheW91dChcIkRvdWJsZSBIw6lsaWNlIEFETlwiLCBhbmFseXNpcylcbiAgICBsYXlvdXQuc2NlbmUuY2FtZXJhID0geyBleWU6IHsgeDogMiwgeTogMCwgejogMSB9IH1cbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICAvLyBGb25jdGlvbiBwb3VyIGNyw6llciB1biBsYXlvdXQgZHluYW1pcXVlIGJhc8OpIHN1ciBsJ2FuYWx5c2VcbiAgY29uc3QgY3JlYXRlRHluYW1pY0xheW91dCA9ICh0aXRsZTogc3RyaW5nLCBhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgZGF0YUluZm8gPSBgJHtkYXRhLmxlbmd0aH0gZW50csOpZXMg4oCiICR7YW5hbHlzaXMubnVtZXJpY0NvbHVtbnMubGVuZ3RofSBudW0uIOKAoiAke2FuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1ucy5sZW5ndGh9IGNhdC5gXG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NlbmU6IHtcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgdGV4dDogYCR7YW5hbHlzaXMubWFwcGluZy54QXhpc30gJHthbmFseXNpcy5kYXRhVHlwZXNbYW5hbHlzaXMubWFwcGluZy54QXhpc10gPyBgKCR7YW5hbHlzaXMuZGF0YVR5cGVzW2FuYWx5c2lzLm1hcHBpbmcueEF4aXNdfSlgIDogXCJcIn1gLFxuICAgICAgICAgICAgZm9udDogeyBzaXplOiAxMiwgY29sb3I6IFwiI2VhNTgwY1wiIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaG93YmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICBiYWNrZ3JvdW5kY29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjQwLCAwLjgpXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIHRleHQ6IGAke2FuYWx5c2lzLm1hcHBpbmcueUF4aXN9ICR7YW5hbHlzaXMuZGF0YVR5cGVzW2FuYWx5c2lzLm1hcHBpbmcueUF4aXNdID8gYCgke2FuYWx5c2lzLmRhdGFUeXBlc1thbmFseXNpcy5tYXBwaW5nLnlBeGlzXX0pYCA6IFwiXCJ9YCxcbiAgICAgICAgICAgIGZvbnQ6IHsgc2l6ZTogMTIsIGNvbG9yOiBcIiNlYTU4MGNcIiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2hvd2JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgYmFja2dyb3VuZGNvbG9yOiBcInJnYmEoMjQwLCAyNDAsIDI0MCwgMC44KVwiLFxuICAgICAgICB9LFxuICAgICAgICB6YXhpczoge1xuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0ZXh0OiBgJHthbmFseXNpcy5tYXBwaW5nLnpBeGlzfSAke2FuYWx5c2lzLmRhdGFUeXBlc1thbmFseXNpcy5tYXBwaW5nLnpBeGlzXSA/IGAoJHthbmFseXNpcy5kYXRhVHlwZXNbYW5hbHlzaXMubWFwcGluZy56QXhpc119KWAgOiBcIlwifWAsXG4gICAgICAgICAgICBmb250OiB7IHNpemU6IDEyLCBjb2xvcjogXCIjZWE1ODBjXCIgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNob3diYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgIGJhY2tncm91bmRjb2xvcjogXCJyZ2JhKDI0MCwgMjQwLCAyNDAsIDAuOClcIixcbiAgICAgICAgfSxcbiAgICAgICAgY2FtZXJhOiB7IGV5ZTogeyB4OiAxLjI1LCB5OiAxLjI1LCB6OiAxLjI1IH0gfSxcbiAgICAgIH0sXG4gICAgICB0aXRsZTogeyB0ZXh0OiB0aXRsZSwgZm9udDogeyBzaXplOiAxOCwgY29sb3I6IFwiI2VhNTgwY1wiIH0gfSxcbiAgICAgIHBhcGVyX2JnY29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgbWFyZ2luOiB7IGw6IDAsIHI6IDAsIHQ6IDYwLCBiOiAwIH0sXG4gICAgICBhbm5vdGF0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgdGV4dDogYDxiPk1vZMOobGU6PC9iPiAke3RpdGxlfTxicj48Yj5Eb25uw6llczo8L2I+ICR7ZGF0YUluZm99PGJyPjxiPk1hcHBpbmc6PC9iPjxicj7igKIgWDogJHthbmFseXNpcy5tYXBwaW5nLnhBeGlzfTxicj7igKIgWTogJHthbmFseXNpcy5tYXBwaW5nLnlBeGlzfTxicj7igKIgWjogJHthbmFseXNpcy5tYXBwaW5nLnpBeGlzfTxicj7igKIgQ291bGV1cjogJHthbmFseXNpcy5tYXBwaW5nLmNvbG9yQnl9PGJyPuKAoiBUYWlsbGU6ICR7YW5hbHlzaXMubWFwcGluZy5zaXplQnl9JHthbmFseXNpcy5tYXBwaW5nLmNhdGVnb3J5QnkgPyBgPGJyPuKAoiBDYXTDqWdvcmllOiAke2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeX1gIDogXCJcIn1gLFxuICAgICAgICAgIHNob3dhcnJvdzogZmFsc2UsXG4gICAgICAgICAgeHJlZjogXCJwYXBlclwiLFxuICAgICAgICAgIHlyZWY6IFwicGFwZXJcIixcbiAgICAgICAgICB4OiAtMC4xNSxcbiAgICAgICAgICB5OiAwLjk1LFxuICAgICAgICAgIHhhbmNob3I6IFwibGVmdFwiLFxuICAgICAgICAgIHlhbmNob3I6IFwidG9wXCIsXG4gICAgICAgICAgYmdjb2xvcjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOClcIixcbiAgICAgICAgICBib3JkZXJjb2xvcjogXCJyZ2JhKDIzNCwgODgsIDEyLCAwLjMpXCIsXG4gICAgICAgICAgYm9yZGVyd2lkdGg6IDEsXG4gICAgICAgICAgZm9udDogeyBzaXplOiA4LCBjb2xvcjogXCIjNjY2XCIgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZ2V0UGxvdENvbmZpZyA9ICgpID0+ICh7XG4gICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICBkaXNwbGF5TW9kZUJhcjogZmFsc2UsXG4gICAgc3RhdGljUGxvdDogZmFsc2UsXG4gICAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgICBkb3VibGVDbGljazogXCJyZXNldFwiLFxuICB9KVxuXG4gIC8vIHJlbmRlclYwVmlzdWFsaXphdGlvbiBlc3QgbWFpbnRlbmFudCBkw6lmaW5pIGF1IGTDqWJ1dCBkdSBjb21wb3NhbnRcblxuICBjb25zdCByZW5kZXJEZW1vVmlzdWFsaXphdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCBkZW1vRGF0YSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgeDogTWF0aC5yYW5kb20oKSAqIDEwLFxuICAgICAgeTogTWF0aC5yYW5kb20oKSAqIDEwLFxuICAgICAgejogTWF0aC5yYW5kb20oKSAqIDEwLFxuICAgICAgdmFsdWU6IE1hdGgucmFuZG9tKCkgKiAxMDAsXG4gICAgICBjYXRlZ29yeTogYENhdCR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNSkgKyAxfWAsXG4gICAgfSkpXG5cbiAgICBzZXREYXRhTWFwcGluZyh7XG4gICAgICB4QXhpczogXCJEaW1lbnNpb24gWFwiLFxuICAgICAgeUF4aXM6IFwiRGltZW5zaW9uIFlcIixcbiAgICAgIHpBeGlzOiBcIkRpbWVuc2lvbiBaXCIsXG4gICAgICBjb2xvckJ5OiBcIlZhbGV1clwiLFxuICAgICAgc2l6ZUJ5OiBcIlZhbGV1clwiLFxuICAgIH0pXG5cbiAgICBjb25zdCBwbG90RGF0YSA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzY2F0dGVyM2RcIixcbiAgICAgICAgbW9kZTogXCJtYXJrZXJzXCIsXG4gICAgICAgIHg6IGRlbW9EYXRhLm1hcCgoZCkgPT4gZC54KSxcbiAgICAgICAgeTogZGVtb0RhdGEubWFwKChkKSA9PiBkLnkpLFxuICAgICAgICB6OiBkZW1vRGF0YS5tYXAoKGQpID0+IGQueiksXG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgIHNpemU6IDgsXG4gICAgICAgICAgY29sb3I6IGRlbW9EYXRhLm1hcCgoZCkgPT4gZC52YWx1ZSksXG4gICAgICAgICAgY29sb3JzY2FsZTogXCJSYWluYm93XCIsXG4gICAgICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiBcIkTDqW1vbnN0cmF0aW9uXCIsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IHtcbiAgICAgIHNjZW5lOiB7XG4gICAgICAgIHhheGlzOiB7IHRpdGxlOiBcIkRpbWVuc2lvbiBYXCIsIHNob3diYWNrZ3JvdW5kOiB0cnVlLCBiYWNrZ3JvdW5kY29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjQwLCAwLjgpXCIgfSxcbiAgICAgICAgeWF4aXM6IHsgdGl0bGU6IFwiRGltZW5zaW9uIFlcIiwgc2hvd2JhY2tncm91bmQ6IHRydWUsIGJhY2tncm91bmRjb2xvcjogXCJyZ2JhKDI0MCwgMjQwLCAyNDAsIDAuOClcIiB9LFxuICAgICAgICB6YXhpczogeyB0aXRsZTogXCJEaW1lbnNpb24gWlwiLCBzaG93YmFja2dyb3VuZDogdHJ1ZSwgYmFja2dyb3VuZGNvbG9yOiBcInJnYmEoMjQwLCAyNDAsIDI0MCwgMC44KVwiIH0sXG4gICAgICAgIGNhbWVyYTogeyBleWU6IHsgeDogMS4yNSwgeTogMS4yNSwgejogMS4yNSB9IH0sXG4gICAgICB9LFxuICAgICAgdGl0bGU6IHsgdGV4dDogYETDqW1vbnN0cmF0aW9uIC0gJHtnZXRNb2RlbE5hbWUodmlzdWFsaXphdGlvblR5cGUpfWAsIGZvbnQ6IHsgc2l6ZTogMTgsIGNvbG9yOiBcIiNlYTU4MGNcIiB9IH0sXG4gICAgICBwYXBlcl9iZ2NvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgIG1hcmdpbjogeyBsOiAwLCByOiAwLCB0OiA2MCwgYjogMCB9LFxuICAgIH1cblxuICAgIHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90UmVmLmN1cnJlbnQsIHBsb3REYXRhLCBsYXlvdXQsIGdldFBsb3RDb25maWcoKSlcbiAgfVxuXG4gIGNvbnN0IGdldE1vZGVsTmFtZSA9IChtb2RlbElkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBuYW1lczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICAgIHNjYXR0ZXIzZDogXCJOdWFnZSAzRCBDbGFzc2lxdWVcIixcbiAgICAgIHNjYXR0ZXJfZGVuc2l0eTogXCJEZW5zaXTDqSAzRFwiLFxuICAgICAgc2NhdHRlcl9idWJibGU6IFwiQnVsbGVzIDNEXCIsXG4gICAgICBtYW5kYWxhXzNkOiBcIk1hbmRhbGEgM0RcIixcbiAgICAgIGdhbGF4eV8zZDogXCJHYWxheGllIDNEXCIsXG4gICAgICBzdXJmYWNlX2NvbnRvdXI6IFwiU3VyZmFjZSBDb250b3Vyc1wiLFxuICAgICAgZG5hX2hlbGl4OiBcIkjDqWxpY2UgQUROXCIsXG4gICAgICB0aW1lbGluZV8zZDogXCJUaW1lbGluZSAzRFwiLFxuICAgIH1cbiAgICByZXR1cm4gbmFtZXNbbW9kZWxJZF0gfHwgXCJWaXN1YWxpc2F0aW9uIDNEXCJcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJoLWZ1bGwgYmctZ3JhZGllbnQtdG8tYnIgZnJvbS1vcmFuZ2UtNTAgdG8td2hpdGUgcm91bmRlZC14bCBib3JkZXItMiBib3JkZXItb3JhbmdlLTIwMCBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgIHsvKiBIZWFkZXIgKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNiBib3JkZXItYiBib3JkZXItb3JhbmdlLTIwMCBiZy13aGl0ZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0zXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctMTIgaC0xMiBiZy1ncmFkaWVudC10by1iciBmcm9tLW9yYW5nZS02MDAgdG8tb3JhbmdlLTUwMCByb3VuZGVkLXhsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgIDxUcmVuZGluZ1VwIGNsYXNzTmFtZT1cInctNiBoLTYgdGV4dC13aGl0ZVwiIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZCB0ZXh0LWdyYXktODAwXCI+Q2FudmFzIElBIOKAoiBWaXN1YWxpc2F0aW9uIER5bmFtaXF1ZTwvaDI+XG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTYwMFwiPlxuICAgICAgICAgICAgICAgIHtkYXRhLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgID8gYCR7ZGF0YS5sZW5ndGh9IMOpY2hhbnRpbGxvbnMg4oCiICR7Y29sdW1ucy5sZW5ndGh9IHZhcmlhYmxlcyDigKIgJHtnZXRNb2RlbE5hbWUoY3VycmVudE1vZGVsKX1gXG4gICAgICAgICAgICAgICAgICA6IGBNb2RlIGTDqW1vbnN0cmF0aW9uIOKAoiAke2dldE1vZGVsTmFtZShjdXJyZW50TW9kZWwpfWB9XG4gICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAge2RhdGFBbmFseXNpcyAmJiAoXG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNTAwXCI+XG4gICAgICAgICAgICAgICAgICB7ZGF0YUFuYWx5c2lzLm51bWVyaWNDb2x1bW5zLmxlbmd0aH0gbnVtw6lyaXF1ZXMg4oCiIHtkYXRhQW5hbHlzaXMuY2F0ZWdvcmljYWxDb2x1bW5zLmxlbmd0aH17XCIgXCJ9XG4gICAgICAgICAgICAgICAgICBjYXTDqWdvcmllbGxlcyDigKIge2RhdGFBbmFseXNpcy50ZW1wb3JhbENvbHVtbnMubGVuZ3RofSB0ZW1wb3JlbGxlc1xuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTJcIj5cbiAgICAgICAgICAgIHtpc1YwR2VuZXJhdGVkICYmIChcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIHB4LTMgcHktMSByb3VuZGVkLWZ1bGwgdGV4dC14cyBmb250LW1lZGl1bSBiZy1ibHVlLTEwMCB0ZXh0LWJsdWUtODAwXCI+XG4gICAgICAgICAgICAgICAgPENvZGUgY2xhc3NOYW1lPVwidy0zIGgtMyBtci0xXCIgLz5cbiAgICAgICAgICAgICAgICBHw6luw6lyw6kgcGFyIHYwXG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgcHgtMyBweS0xIHJvdW5kZWQtZnVsbCB0ZXh0LXhzIGZvbnQtbWVkaXVtIGJnLW9yYW5nZS0xMDAgdGV4dC1vcmFuZ2UtODAwXCI+XG4gICAgICAgICAgICAgIDxaYXAgY2xhc3NOYW1lPVwidy0zIGgtMyBtci0xXCIgLz5cbiAgICAgICAgICAgICAgUGxvdGx5IHYyLjM1XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgcHgtMyBweS0xIHJvdW5kZWQtZnVsbCB0ZXh0LXhzIGZvbnQtbWVkaXVtIGJnLWdyZWVuLTEwMCB0ZXh0LWdyZWVuLTgwMFwiPlxuICAgICAgICAgICAgICBBZGFwdGF0aWYgRHluYW1pcXVlXG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHsvKiBDYW52YXMgKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIGgtW2NhbGMoMTAwJS0xMjBweCldXCI+XG4gICAgICAgIHshcGxvdGx5TG9hZGVkID8gKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgaC1mdWxsXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy04IGgtOCBib3JkZXItMiBib3JkZXItb3JhbmdlLTUwMCBib3JkZXItdC10cmFuc3BhcmVudCByb3VuZGVkLWZ1bGwgYW5pbWF0ZS1zcGluIG14LWF1dG8gbWItNFwiPjwvZGl2PlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwXCI+Q2hhcmdlbWVudCBkZSBQbG90bHkuanMgdjIuMzUuLi48L3A+XG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTUwMCBtdC0yXCI+QW5hbHlzZSBkeW5hbWlxdWUgZGVzIGRvbm7DqWVzIGVuIGNvdXJzLi4uPC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPGRpdiByZWY9e3Bsb3RSZWZ9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIiAvPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlRyZW5kaW5nVXAiLCJaYXAiLCJDb2RlIiwiQ2FudmFzM0RWaXN1YWxpemF0aW9uIiwiZGF0YSIsImNvbHVtbnMiLCJ2aXN1YWxpemF0aW9uVHlwZSIsImdlbmVyYXRlZENvbmZpZyIsInBsb3RSZWYiLCJpc1YwR2VuZXJhdGVkIiwic2V0SXNWMEdlbmVyYXRlZCIsInBsb3RseUxvYWRlZCIsInNldFBsb3RseUxvYWRlZCIsImRhdGFNYXBwaW5nIiwic2V0RGF0YU1hcHBpbmciLCJjdXJyZW50TW9kZWwiLCJzZXRDdXJyZW50TW9kZWwiLCJkYXRhQW5hbHlzaXMiLCJzZXREYXRhQW5hbHlzaXMiLCJyZW5kZXJWMFZpc3VhbGl6YXRpb24iLCJjb25maWciLCJwbG90RWxlbWVudCIsImN1cnJlbnQiLCJwbG90RGF0YSIsImxheW91dCIsIndpbmRvdyIsIlBsb3RseSIsIm5ld1Bsb3QiLCJnZXRQbG90Q29uZmlnIiwiYW5hbHlzaXMiLCJhbmFseXplRGF0YUludGVsbGlnZW50bHkiLCJyZW5kZXJNb2RlbFNwZWNpZmljVmlzdWFsaXphdGlvbiIsImVycm9yIiwiY29uc29sZSIsInJlbmRlckNsYXNzaWNTY2F0dGVyIiwic2NyaXB0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwib25sb2FkIiwib25lcnJvciIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInVwZGF0ZVZpc3VhbGl6YXRpb24iLCJjaGlsZHJlbiIsImxlbmd0aCIsInB1cmdlIiwibWFwcGluZyIsInhBeGlzIiwieUF4aXMiLCJ6QXhpcyIsImNvbG9yQnkiLCJzaXplQnkiLCJudW1lcmljQ29sdW1ucyIsImNhdGVnb3JpY2FsQ29sdW1ucyIsInRlbXBvcmFsQ29sdW1ucyIsImRhdGFSYW5nZXMiLCJjYXRlZ29yaWVzIiwiZGF0YVR5cGVzIiwiZm9yRWFjaCIsImNvbCIsInZhbHVlcyIsIm1hcCIsInJvdyIsImZpbHRlciIsInZhbCIsIm51bWVyaWNWYWx1ZXMiLCJOdW1iZXIiLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJpc0Zpbml0ZSIsIm51bWVyaWNSYXRpbyIsImRhdGVWYWx1ZXMiLCJkYXRlIiwiRGF0ZSIsImdldFRpbWUiLCJnZXRGdWxsWWVhciIsInRlbXBvcmFsUmF0aW8iLCJ1bmlxdWVWYWx1ZXMiLCJTZXQiLCJ1bmlxdWVSYXRpbyIsInB1c2giLCJ0aW1lc3RhbXBzIiwibWluIiwiTWF0aCIsIm1heCIsInNsaWNlIiwiYWxsTnVtZXJpY0NvbHMiLCJjYXRlZ29yeUJ5IiwicmVuZGVyRGVtb1Zpc3VhbGl6YXRpb24iLCJyZW5kZXJCdWJibGVTY2F0dGVyIiwicmVuZGVyQW5pbWF0ZWRTY2F0dGVyIiwicmVuZGVyQ2x1c3RlcmVkU2NhdHRlciIsInJlbmRlckRlbnNpdHlTY2F0dGVyIiwicmVuZGVyQ2xhc3NpY1N1cmZhY2UiLCJyZW5kZXJDb250b3VyU3VyZmFjZSIsInJlbmRlck1lc2hTdXJmYWNlIiwicmVuZGVyR3JhZGllbnRTdXJmYWNlIiwicmVuZGVyQ2xhc3NpY0JhcnMiLCJyZW5kZXJHcm91cGVkQmFycyIsInJlbmRlckN5bGluZHJpY2FsQmFycyIsInJlbmRlclB5cmFtaWRCYXJzIiwicmVuZGVyU3BoZXJlUGFjayIsInJlbmRlckN1YmVNYXRyaXgiLCJyZW5kZXJDb25lRmllbGQiLCJyZW5kZXJIZWxpeFNwaXJhbCIsInJlbmRlck1hbmRhbGEzRCIsInJlbmRlckZyYWN0YWwzRCIsInJlbmRlckNyeXN0YWwzRCIsInJlbmRlckdhbGF4eTNEIiwicmVuZGVyRE5BSGVsaXgiLCJyZW5kZXJOZXR3b3JrM0QiLCJyZW5kZXJUcmVlM0QiLCJyZW5kZXJUaW1lbGluZTNEIiwicmVuZGVyV2F2ZVRlbXBvcmFsIiwicmVuZGVyU3BpcmFsVGltZSIsInJlbmRlckdsb2JlM0QiLCJyZW5kZXJUZXJyYWluM0QiLCJyZW5kZXJNb2xlY3VsZTNEIiwicmVuZGVyVmVjdG9yRmllbGQiLCJyZW5kZXJIaXN0b2dyYW0zRCIsInJlbmRlckJveFBsb3QzRCIsImdldFZhbHVlc0Zyb21BbmFseXNpcyIsImtleSIsImNvbHVtbiIsIl8iLCJpIiwiaW5jbHVkZXMiLCJyYW5nZSIsInRpbWVzdGFtcCIsIm51bVZhbCIsImluZGV4IiwiaW5kZXhPZiIsInhWYWx1ZXMiLCJ5VmFsdWVzIiwielZhbHVlcyIsImNvbG9yVmFsdWVzIiwibWFya2VyU2l6ZSIsInNxcnQiLCJ0eXBlIiwibW9kZSIsIngiLCJ5IiwieiIsIm1hcmtlciIsInNpemUiLCJjb2xvciIsImNvbG9yc2NhbGUiLCJvcGFjaXR5IiwiY29sb3JiYXIiLCJ0aXRsZSIsInRpdGxlZm9udCIsInRleHQiLCJ0b29sdGlwIiwiaG92ZXJ0ZW1wbGF0ZSIsIm5hbWUiLCJjcmVhdGVEeW5hbWljTGF5b3V0IiwiZ3JpZFNpemUiLCJ4UmFuZ2UiLCJ5UmFuZ2UiLCJ6UmFuZ2UiLCJkZW5zaXR5WCIsImRlbnNpdHlZIiwiZGVuc2l0eVoiLCJkZW5zaXR5Q29sb3JzIiwiZGVuc2l0eVNpemVzIiwieFNwYW4iLCJ5U3BhbiIsInpTcGFuIiwicmFkaXVzIiwiaiIsImsiLCJkZW5zaXR5IiwicCIsImR4IiwiZHkiLCJkeiIsImRpc3RhbmNlIiwiZXhwIiwidGhyZXNob2xkIiwidG9GaXhlZCIsInNpemVWYWx1ZXMiLCJtaW5TaXplIiwibWF4U2l6ZSIsIm5vcm1hbGl6ZWRTaXplcyIsInYiLCJsaW5lIiwid2lkdGgiLCJtYW5kYWxhWCIsIm1hbmRhbGFZIiwibWFuZGFsYVoiLCJtYW5kYWxhQ29sb3JzIiwibWFuZGFsYVNpemVzIiwibm9ybWFsaXplZEluZGV4IiwiY29sb3JWYWwiLCJzaXplVmFsIiwiY29sb3JSYW5nZSIsInRvdXJzIiwiYW5nbGUiLCJQSSIsInNpbiIsImhlaWdodCIsImNvcyIsIm51bVBldGFscyIsInBldGFsQW5nbGUiLCJwZXRhbFJhZGl1cyIsInNjZW5lIiwiY2FtZXJhIiwiZXllIiwiZ2FsYXh5WCIsImdhbGF4eVkiLCJnYWxheHlaIiwiZ2FsYXh5Q29sb3JzIiwiZ2FsYXh5U2l6ZXMiLCJzaXplUmFuZ2UiLCJ0Iiwibm9ybWFsaXplZENvbG9yIiwibm9ybWFsaXplZFNpemUiLCJyYW5kb20iLCJhbmdsZTIiLCJyYWRpdXMyIiwiYmdjb2xvciIsInRpbWVDb2x1bW4iLCJ2YWx1ZUNvbHVtbiIsImNvbG9yQ29sdW1uIiwidGltZVZhbHVlcyIsInNvcnRlZEluZGljZXMiLCJzb3J0IiwiYSIsImIiLCJ0aW1lbGluZVgiLCJ0aW1lbGluZVkiLCJ0aW1lbGluZVoiLCJ0aW1lbGluZUNvbG9ycyIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJ4R3JpZCIsIkFycmF5IiwiZnJvbSIsInlHcmlkIiwic3VyZmFjZSIsInRhcmdldFgiLCJ0YXJnZXRZIiwid2VpZ2h0ZWRTdW0iLCJ0b3RhbFdlaWdodCIsIm1heERpc3RhbmNlIiwid2VpZ2h0IiwiY29udG91cnMiLCJzaG93IiwidXNlY29sb3JtYXAiLCJoaWdobGlnaHRjb2xvciIsInByb2plY3QiLCJkbmFYMSIsImRuYVkxIiwiZG5hWjEiLCJkbmFYMiIsImRuYVkyIiwiZG5hWjIiLCJkbmFDb2xvcnMiLCJkbmFTaXplcyIsInJhZGl1c01vZHVsYXRpb24iLCJoZWlnaHRNb2R1bGF0aW9uIiwic2hvd2xlZ2VuZCIsImRhdGFJbmZvIiwieGF4aXMiLCJmb250Iiwic2hvd2JhY2tncm91bmQiLCJiYWNrZ3JvdW5kY29sb3IiLCJ5YXhpcyIsInpheGlzIiwicGFwZXJfYmdjb2xvciIsIm1hcmdpbiIsImwiLCJyIiwiYW5ub3RhdGlvbnMiLCJzaG93YXJyb3ciLCJ4cmVmIiwieXJlZiIsInhhbmNob3IiLCJ5YW5jaG9yIiwiYm9yZGVyY29sb3IiLCJib3JkZXJ3aWR0aCIsInJlc3BvbnNpdmUiLCJkaXNwbGF5TW9kZUJhciIsInN0YXRpY1Bsb3QiLCJzY3JvbGxab29tIiwiZG91YmxlQ2xpY2siLCJkZW1vRGF0YSIsInZhbHVlIiwiY2F0ZWdvcnkiLCJmbG9vciIsImQiLCJnZXRNb2RlbE5hbWUiLCJtb2RlbElkIiwibmFtZXMiLCJzY2F0dGVyM2QiLCJzY2F0dGVyX2RlbnNpdHkiLCJzY2F0dGVyX2J1YmJsZSIsIm1hbmRhbGFfM2QiLCJnYWxheHlfM2QiLCJzdXJmYWNlX2NvbnRvdXIiLCJkbmFfaGVsaXgiLCJ0aW1lbGluZV8zZCIsImRpdiIsImNsYXNzTmFtZSIsImgyIiwic3BhbiIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Canvas3DVisualization.tsx\n"));

/***/ })

});