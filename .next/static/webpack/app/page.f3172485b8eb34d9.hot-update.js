"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Canvas3DVisualization.tsx":
/*!**********************************************!*\
  !*** ./components/Canvas3DVisualization.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Canvas3DVisualization; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.16_@opentelemetry+api@1.9.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.16_@opentelemetry+api@1.9.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=Code,TrendingUp,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/.pnpm/lucide-react@0.454.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/trending-up.js\");\n/* harmony import */ var _barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=Code,TrendingUp,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/.pnpm/lucide-react@0.454.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/code.js\");\n/* harmony import */ var _barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Code,TrendingUp,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/.pnpm/lucide-react@0.454.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/zap.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Canvas3DVisualization(param) {\n    let { data, columns, visualizationType, generatedConfig } = param;\n    _s();\n    const plotRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isV0Generated, setIsV0Generated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [plotlyLoaded, setPlotlyLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [dataMapping, setDataMapping] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentModel, setCurrentModel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"scatter3d\");\n    const [dataAnalysis, setDataAnalysis] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Charger Plotly.js\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if ( true && !window.Plotly) {\n            const script = document.createElement(\"script\");\n            script.src = \"https://cdn.plot.ly/plotly-2.35.2.min.js\";\n            script.onload = ()=>setPlotlyLoaded(true);\n            script.onerror = ()=>{\n                console.error(\"Erreur lors du chargement de Plotly.js\");\n                setPlotlyLoaded(false);\n            };\n            document.head.appendChild(script);\n        } else if (window.Plotly) {\n            setPlotlyLoaded(true);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!plotlyLoaded || !plotRef.current) return;\n        // Nettoyer le graphique précédent\n        if (plotRef.current.children.length > 0) {\n            window.Plotly.purge(plotRef.current);\n        }\n        setCurrentModel(visualizationType);\n        // Toujours vérifier si generatedConfig existe et est associé au type actuel\n        if (generatedConfig && generatedConfig.type === visualizationType) {\n            console.log(\"Utilisation de la configuration g\\xe9n\\xe9r\\xe9e pour\", visualizationType);\n            renderV0Visualization(generatedConfig);\n            setIsV0Generated(true);\n        } else {\n            console.log(\"G\\xe9n\\xe9ration locale pour\", visualizationType);\n            // Si la config ne correspond pas au type actuel, on génère localement\n            renderModelSpecificVisualization();\n            setIsV0Generated(false);\n        }\n    }, [\n        plotlyLoaded,\n        data,\n        columns,\n        visualizationType,\n        generatedConfig\n    ]);\n    // Analyse complète et intelligente des données\n    const analyzeDataIntelligently = ()=>{\n        if (!data || data.length === 0 || !columns || columns.length === 0) {\n            return null;\n        }\n        const analysis = {\n            mapping: {},\n            numericColumns: [],\n            categoricalColumns: [],\n            temporalColumns: [],\n            dataRanges: {},\n            categories: {},\n            dataTypes: {}\n        };\n        // Analyser chaque colonne en détail\n        columns.forEach((col)=>{\n            const values = data.map((row)=>row[col]).filter((val)=>val != null && val !== \"\");\n            if (values.length === 0) {\n                analysis.dataTypes[col] = \"mixed\";\n                return;\n            }\n            // Test numérique\n            const numericValues = values.map((val)=>Number.parseFloat(val)).filter((val)=>!isNaN(val) && isFinite(val));\n            const numericRatio = numericValues.length / values.length;\n            // Test temporel\n            const dateValues = values.filter((val)=>{\n                const date = new Date(val);\n                return !isNaN(date.getTime()) && date.getFullYear() > 1900 && date.getFullYear() < 2100;\n            });\n            const temporalRatio = dateValues.length / values.length;\n            // Test catégoriel\n            const uniqueValues = [\n                ...new Set(values)\n            ];\n            const uniqueRatio = uniqueValues.length / values.length;\n            // Classification intelligente\n            if (temporalRatio > 0.7) {\n                analysis.dataTypes[col] = \"temporal\";\n                analysis.temporalColumns.push(col);\n                // Convertir en timestamps pour les calculs\n                const timestamps = dateValues.map((val)=>new Date(val).getTime());\n                analysis.dataRanges[col] = {\n                    min: Math.min(...timestamps),\n                    max: Math.max(...timestamps),\n                    values: timestamps\n                };\n            } else if (numericRatio > 0.7) {\n                analysis.dataTypes[col] = \"numeric\";\n                analysis.numericColumns.push(col);\n                analysis.dataRanges[col] = {\n                    min: Math.min(...numericValues),\n                    max: Math.max(...numericValues),\n                    values: numericValues\n                };\n            } else if (uniqueRatio < 0.3 || uniqueValues.length <= 20) {\n                analysis.dataTypes[col] = \"categorical\";\n                analysis.categoricalColumns.push(col);\n                analysis.categories[col] = uniqueValues.slice(0, 20) // Limiter à 20 catégories\n                ;\n            } else {\n                analysis.dataTypes[col] = \"mixed\";\n                if (numericValues.length > 0) {\n                    analysis.dataRanges[col] = {\n                        min: Math.min(...numericValues),\n                        max: Math.max(...numericValues),\n                        values: numericValues\n                    };\n                }\n            }\n        });\n        // Créer un mapping intelligent basé sur les types de données\n        const allNumericCols = [\n            ...analysis.numericColumns,\n            ...analysis.temporalColumns\n        ];\n        if (allNumericCols.length >= 3) {\n            analysis.mapping = {\n                xAxis: allNumericCols[0],\n                yAxis: allNumericCols[1],\n                zAxis: allNumericCols[2],\n                colorBy: allNumericCols[0],\n                sizeBy: allNumericCols.length > 3 ? allNumericCols[3] : allNumericCols[0],\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        } else if (allNumericCols.length === 2) {\n            analysis.mapping = {\n                xAxis: allNumericCols[0],\n                yAxis: allNumericCols[1],\n                zAxis: allNumericCols[0],\n                colorBy: allNumericCols[1],\n                sizeBy: allNumericCols[0],\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        } else if (allNumericCols.length === 1) {\n            analysis.mapping = {\n                xAxis: allNumericCols[0],\n                yAxis: \"index\",\n                zAxis: allNumericCols[0],\n                colorBy: allNumericCols[0],\n                sizeBy: allNumericCols[0],\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        } else {\n            // Utiliser les indices et catégories\n            analysis.mapping = {\n                xAxis: \"index\",\n                yAxis: analysis.categoricalColumns[0] || \"index\",\n                zAxis: \"count\",\n                colorBy: analysis.categoricalColumns[0] || \"index\",\n                sizeBy: \"count\",\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        }\n        return analysis;\n    };\n    // Fonction principale qui route vers la bonne visualisation selon le modèle\n    const renderModelSpecificVisualization = ()=>{\n        if (!data || data.length === 0) {\n            renderDemoVisualization();\n            return;\n        }\n        const analysis = analyzeDataIntelligently();\n        if (!analysis) {\n            renderDemoVisualization();\n            return;\n        }\n        setDataAnalysis(analysis);\n        setDataMapping(analysis.mapping);\n        // Router vers la fonction spécialisée selon le modèle exact\n        switch(visualizationType){\n            // NUAGES\n            case \"scatter3d\":\n                renderClassicScatter(analysis);\n                break;\n            case \"scatter_bubble\":\n                renderBubbleScatter(analysis);\n                break;\n            case \"scatter_animated\":\n                renderAnimatedScatter(analysis);\n                break;\n            case \"scatter_clustered\":\n                renderClusteredScatter(analysis);\n                break;\n            case \"scatter_density\":\n                renderDensityScatter(analysis);\n                break;\n            // SURFACES\n            case \"surface3d\":\n                renderClassicSurface(analysis);\n                break;\n            case \"surface_contour\":\n                renderContourSurface(analysis);\n                break;\n            case \"surface_mesh\":\n                renderMeshSurface(analysis);\n                break;\n            case \"surface_gradient\":\n                renderGradientSurface(analysis);\n                break;\n            // ARCHITECTURE\n            case \"bars3d\":\n                renderClassicBars(analysis);\n                break;\n            case \"bars_grouped\":\n                renderGroupedBars(analysis);\n                break;\n            case \"bars_cylindrical\":\n                renderCylindricalBars(analysis);\n                break;\n            case \"bars_pyramid\":\n                renderPyramidBars(analysis);\n                break;\n            // GÉOMÉTRIQUES\n            case \"sphere_pack\":\n                renderSpherePack(analysis);\n                break;\n            case \"cube_matrix\":\n                renderCubeMatrix(analysis);\n                break;\n            case \"cone_field\":\n                renderConeField(analysis);\n                break;\n            case \"helix_spiral\":\n                renderHelixSpiral(analysis);\n                break;\n            // ARTISTIQUES\n            case \"mandala_3d\":\n                renderMandala3D(analysis);\n                break;\n            case \"fractal_3d\":\n                renderFractal3D(analysis);\n                break;\n            case \"crystal_3d\":\n                renderCrystal3D(analysis);\n                break;\n            case \"galaxy_3d\":\n                renderGalaxy3D(analysis);\n                break;\n            case \"dna_helix\":\n                renderDNAHelix(analysis);\n                break;\n            // RÉSEAUX\n            case \"network_3d\":\n                renderNetwork3D(analysis);\n                break;\n            case \"tree_3d\":\n                renderTree3D(analysis);\n                break;\n            // TEMPORELS\n            case \"timeline_3d\":\n                renderTimeline3D(analysis);\n                break;\n            case \"wave_temporal\":\n                renderWaveTemporal(analysis);\n                break;\n            case \"spiral_time\":\n                renderSpiralTime(analysis);\n                break;\n            // GÉOGRAPHIQUES\n            case \"globe_3d\":\n                renderGlobe3D(analysis);\n                break;\n            case \"terrain_3d\":\n                renderTerrain3D(analysis);\n                break;\n            // SCIENTIFIQUES\n            case \"molecule_3d\":\n                renderMolecule3D(analysis);\n                break;\n            case \"vector_field\":\n                renderVectorField(analysis);\n                break;\n            // STATISTIQUES\n            case \"histogram_3d\":\n                renderHistogram3D(analysis);\n                break;\n            case \"box_plot_3d\":\n                renderBoxPlot3D(analysis);\n                break;\n            default:\n                renderClassicScatter(analysis);\n        }\n    };\n    // Fonction utilitaire pour extraire les valeurs avec l'analyse\n    const getValuesFromAnalysis = (analysis, key)=>{\n        const column = analysis.mapping[key];\n        if (column === \"index\") {\n            return data.map((_, i)=>i);\n        } else if (column === \"count\") {\n            return data.map(()=>1);\n        } else if (column && columns.includes(column)) {\n            if (analysis.dataRanges[column]) {\n                // Utiliser les valeurs pré-calculées pour les colonnes numériques/temporelles\n                const range = analysis.dataRanges[column];\n                return data.map((row, i)=>{\n                    const val = row[column];\n                    if (analysis.dataTypes[column] === \"temporal\") {\n                        const timestamp = new Date(val).getTime();\n                        return isNaN(timestamp) ? range.min : timestamp;\n                    } else {\n                        const numVal = Number.parseFloat(val);\n                        return !isNaN(numVal) && isFinite(numVal) ? numVal : range.min;\n                    }\n                });\n            } else if (analysis.categories[column]) {\n                // Convertir les catégories en indices numériques\n                const categories = analysis.categories[column];\n                return data.map((row)=>{\n                    const val = row[column];\n                    const index = categories.indexOf(val);\n                    return index >= 0 ? index : 0;\n                });\n            }\n        }\n        return data.map((_, i)=>i);\n    };\n    // VISUALISATIONS SPÉCIALISÉES AVEC DONNÉES DYNAMIQUES\n    // 1. NUAGE CLASSIQUE - Adapté aux données\n    const renderClassicScatter = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        // Adapter la taille des marqueurs selon la densité des données\n        const markerSize = Math.max(3, Math.min(12, 100 / Math.sqrt(data.length)));\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: xValues,\n                y: yValues,\n                z: zValues,\n                marker: {\n                    size: markerSize,\n                    color: colorValues,\n                    colorscale: \"Viridis\",\n                    opacity: Math.max(0.6, 1 - data.length / 1000),\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                text: data.map((row, i)=>{\n                    let tooltip = \"<b>Point \".concat(i + 1, \"</b><br>\");\n                    tooltip += \"<b>\".concat(analysis.mapping.xAxis, \":</b> \").concat(row[analysis.mapping.xAxis] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>\".concat(analysis.mapping.yAxis, \":</b> \").concat(row[analysis.mapping.yAxis] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>\".concat(analysis.mapping.zAxis, \":</b> \").concat(row[analysis.mapping.zAxis] || \"N/A\", \"<br>\");\n                    if (analysis.mapping.categoryBy && row[analysis.mapping.categoryBy]) {\n                        tooltip += \"<b>\".concat(analysis.mapping.categoryBy, \":</b> \").concat(row[analysis.mapping.categoryBy], \"<br>\");\n                    }\n                    return tooltip;\n                }),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Nuage 3D - \".concat(data.length, \" points\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Nuage 3D Classique\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 2. DENSITÉ 3D - Vraie densité basée sur les données réelles\n    const renderDensityScatter = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        // Adapter la résolution de la grille selon le nombre de données\n        const gridSize = Math.min(25, Math.max(10, Math.sqrt(data.length)));\n        const xRange = analysis.dataRanges[analysis.mapping.xAxis];\n        const yRange = analysis.dataRanges[analysis.mapping.yAxis];\n        const zRange = analysis.dataRanges[analysis.mapping.zAxis];\n        if (!xRange || !yRange || !zRange) {\n            renderClassicScatter(analysis);\n            return;\n        }\n        const densityX = [];\n        const densityY = [];\n        const densityZ = [];\n        const densityColors = [];\n        const densitySizes = [];\n        // Calculer le rayon adaptatif basé sur les vraies données\n        const xSpan = xRange.max - xRange.min;\n        const ySpan = yRange.max - yRange.min;\n        const zSpan = zRange.max - zRange.min;\n        const radius = Math.max(xSpan, ySpan, zSpan) / (gridSize * 0.8);\n        for(let i = 0; i < gridSize; i++){\n            for(let j = 0; j < gridSize; j++){\n                for(let k = 0; k < gridSize; k++){\n                    const x = xRange.min + i / (gridSize - 1) * xSpan;\n                    const y = yRange.min + j / (gridSize - 1) * ySpan;\n                    const z = zRange.min + k / (gridSize - 1) * zSpan;\n                    // Calculer la densité locale avec les vraies données\n                    let density = 0;\n                    for(let p = 0; p < data.length; p++){\n                        const dx = xValues[p] - x;\n                        const dy = yValues[p] - y;\n                        const dz = zValues[p] - z;\n                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                        if (distance < radius) {\n                            density += Math.exp(-(distance * distance) / (radius * radius));\n                        }\n                    }\n                    // Seuil adaptatif basé sur la densité moyenne\n                    const threshold = data.length / (gridSize * gridSize * gridSize) * 0.5;\n                    if (density > threshold) {\n                        densityX.push(x);\n                        densityY.push(y);\n                        densityZ.push(z);\n                        densityColors.push(density);\n                        densitySizes.push(Math.max(4, Math.min(20, density * 15)));\n                    }\n                }\n            }\n        }\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: densityX,\n                y: densityY,\n                z: densityZ,\n                marker: {\n                    size: densitySizes,\n                    color: densityColors,\n                    colorscale: \"Hot\",\n                    opacity: 0.7,\n                    colorbar: {\n                        title: \"Densit\\xe9 Locale\",\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                text: densityX.map((_, i)=>\"<b>Zone Dense \".concat(i + 1, \"</b><br>Densit\\xe9: \").concat(densityColors[i].toFixed(2), \"<br>Position: (\").concat(densityX[i].toFixed(1), \", \").concat(densityY[i].toFixed(1), \", \").concat(densityZ[i].toFixed(1), \")\")),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Densit\\xe9 3D - \".concat(densityX.length, \" zones\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Densit\\xe9 3D - Zones de Concentration\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 3. BULLES 3D - Tailles vraiment proportionnelles aux données\n    const renderBubbleScatter = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        // Normaliser les tailles basées sur les vraies données\n        const sizeRange = analysis.dataRanges[analysis.mapping.sizeBy];\n        const normalizedSizes = sizeRange ? sizeValues.map((val)=>{\n            const normalized = (val - sizeRange.min) / (sizeRange.max - sizeRange.min);\n            return Math.max(5, Math.min(25, normalized * 20 + 5));\n        }) : sizeValues.map(()=>10);\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: xValues,\n                y: yValues,\n                z: zValues,\n                marker: {\n                    size: normalizedSizes,\n                    color: colorValues,\n                    colorscale: \"Plasma\",\n                    opacity: 0.75,\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    },\n                    line: {\n                        color: \"rgba(255, 255, 255, 0.3)\",\n                        width: 1\n                    }\n                },\n                text: data.map((row, i)=>{\n                    let tooltip = \"<b>Bulle \".concat(i + 1, \"</b><br>\");\n                    tooltip += \"<b>Taille (\".concat(analysis.mapping.sizeBy, \"):</b> \").concat(row[analysis.mapping.sizeBy] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>Couleur (\".concat(analysis.mapping.colorBy, \"):</b> \").concat(row[analysis.mapping.colorBy] || \"N/A\", \"<br>\");\n                    if (analysis.mapping.categoryBy && row[analysis.mapping.categoryBy]) {\n                        tooltip += \"<b>Cat\\xe9gorie:</b> \".concat(row[analysis.mapping.categoryBy], \"<br>\");\n                    }\n                    return tooltip;\n                }),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Bulles 3D - \".concat(data.length, \" \\xe9l\\xe9ments\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Bulles 3D - Tailles Proportionnelles\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 4. MANDALA 3D - Basé sur les patterns des données\n    const renderMandala3D = (analysis)=>{\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        const mandalaX = [];\n        const mandalaY = [];\n        const mandalaZ = [];\n        const mandalaColors = [];\n        const mandalaSizes = [];\n        // Utiliser les vraies données pour créer les patterns\n        data.forEach((row, i)=>{\n            const normalizedIndex = i / data.length;\n            const colorVal = colorValues[i];\n            const sizeVal = sizeValues[i];\n            // Nombre de tours basé sur la variance des données\n            const colorRange = analysis.dataRanges[analysis.mapping.colorBy];\n            const tours = colorRange ? 4 + (colorVal - colorRange.min) / (colorRange.max - colorRange.min) * 4 : 6;\n            const angle = normalizedIndex * tours * Math.PI;\n            const radius = 1 + Math.sin(angle * 3) * 0.5;\n            const height = Math.sin(angle * 2) * 0.3;\n            // Point principal\n            mandalaX.push(Math.cos(angle) * radius);\n            mandalaY.push(Math.sin(angle) * radius);\n            mandalaZ.push(height);\n            mandalaColors.push(colorVal);\n            mandalaSizes.push(Math.max(3, Math.min(8, sizeVal / ((colorRange === null || colorRange === void 0 ? void 0 : colorRange.max) || 1) * 6 + 3)));\n            // Pétales basés sur les catégories\n            const numPetals = analysis.mapping.categoryBy && analysis.categories[analysis.mapping.categoryBy] ? Math.min(6, analysis.categories[analysis.mapping.categoryBy].length) : 5;\n            for(let j = 0; j < numPetals; j++){\n                const petalAngle = angle + j * 2 * Math.PI / numPetals;\n                const petalRadius = radius * 0.3;\n                mandalaX.push(Math.cos(angle) * radius + Math.cos(petalAngle) * petalRadius);\n                mandalaY.push(Math.sin(angle) * radius + Math.sin(petalAngle) * petalRadius);\n                mandalaZ.push(height + Math.sin(petalAngle * 2) * 0.1);\n                mandalaColors.push(colorVal * 0.8);\n                mandalaSizes.push(Math.max(2, mandalaSizes[mandalaSizes.length - 1] * 0.6));\n            }\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: mandalaX,\n                y: mandalaY,\n                z: mandalaZ,\n                marker: {\n                    size: mandalaSizes,\n                    color: mandalaColors,\n                    colorscale: \"Rainbow\",\n                    opacity: 0.8,\n                    colorbar: {\n                        title: \"Harmonie (\".concat(analysis.mapping.colorBy, \")\"),\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                name: \"Mandala 3D - \".concat(data.length, \" \\xe9l\\xe9ments source\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Mandala 3D - Motifs Sacr\\xe9s\", analysis);\n        layout.scene.camera = {\n            eye: {\n                x: 0,\n                y: 0,\n                z: 2.5\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 5. GALAXIE 3D - Structure basée sur les données\n    const renderGalaxy3D = (analysis)=>{\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        const galaxyX = [];\n        const galaxyY = [];\n        const galaxyZ = [];\n        const galaxyColors = [];\n        const galaxySizes = [];\n        // Analyser la distribution pour créer les bras galactiques\n        const colorRange = analysis.dataRanges[analysis.mapping.colorBy];\n        const sizeRange = analysis.dataRanges[analysis.mapping.sizeBy];\n        data.forEach((row, i)=>{\n            const t = i / data.length;\n            const colorVal = colorValues[i];\n            const sizeVal = sizeValues[i];\n            // Position dans la galaxie basée sur les valeurs des données\n            const normalizedColor = colorRange ? (colorVal - colorRange.min) / (colorRange.max - colorRange.min) : t;\n            const normalizedSize = sizeRange ? (sizeVal - sizeRange.min) / (sizeRange.max - sizeRange.min) : 0.5;\n            // Angle et rayon basés sur les données\n            const angle = normalizedColor * 6 * Math.PI + t * 2 * Math.PI;\n            const radius = normalizedSize * 3 + t * 0.5;\n            const height = (Math.random() - 0.5) * 0.2 * (1 - t // Plus plat vers l'extérieur\n            );\n            // Bras principal\n            galaxyX.push(Math.cos(angle) * radius);\n            galaxyY.push(Math.sin(angle) * radius);\n            galaxyZ.push(height);\n            galaxyColors.push(colorVal);\n            galaxySizes.push(Math.max(2, Math.min(12, (1 - normalizedSize) * 8 + 3)));\n            // Bras secondaire si assez de données\n            if (data.length > 20) {\n                const angle2 = angle + Math.PI * 0.8;\n                const radius2 = radius * 0.7;\n                galaxyX.push(Math.cos(angle2) * radius2);\n                galaxyY.push(Math.sin(angle2) * radius2);\n                galaxyZ.push(height * 0.5);\n                galaxyColors.push(colorVal * 0.8);\n                galaxySizes.push(Math.max(1, galaxySizes[galaxySizes.length - 1] * 0.7));\n            }\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: galaxyX,\n                y: galaxyY,\n                z: galaxyZ,\n                marker: {\n                    size: galaxySizes,\n                    color: galaxyColors,\n                    colorscale: \"Viridis\",\n                    opacity: 0.8,\n                    colorbar: {\n                        title: \"Luminosit\\xe9 (\".concat(analysis.mapping.colorBy, \")\"),\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                name: \"Galaxie 3D - \".concat(data.length, \" \\xe9toiles\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Galaxie 3D - Spirale Cosmique\", analysis);\n        layout.scene.bgcolor = \"rgba(0, 0, 20, 0.9)\";\n        layout.scene.camera = {\n            eye: {\n                x: 1.5,\n                y: 1.5,\n                z: 1\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 6. TIMELINE 3D - Pour données temporelles\n    const renderTimeline3D = (analysis)=>{\n        // Chercher une colonne temporelle\n        const timeColumn = analysis.temporalColumns[0] || analysis.mapping.xAxis;\n        const valueColumn = analysis.mapping.yAxis;\n        const colorColumn = analysis.mapping.colorBy;\n        const timeValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const values = getValuesFromAnalysis(analysis, \"yAxis\");\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        // Trier par temps si c'est temporel\n        const sortedIndices = timeValues.map((_, i)=>i).sort((a, b)=>timeValues[a] - timeValues[b]);\n        const timelineX = sortedIndices.map((i)=>timeValues[i]);\n        const timelineY = sortedIndices.map((i)=>values[i]);\n        const timelineZ = sortedIndices.map((_, i)=>i * 0.1) // Élévation progressive\n        ;\n        const timelineColors = sortedIndices.map((i)=>colorValues[i]);\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers+lines\",\n                x: timelineX,\n                y: timelineY,\n                z: timelineZ,\n                marker: {\n                    size: 6,\n                    color: timelineColors,\n                    colorscale: \"Viridis\",\n                    opacity: 0.8,\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                line: {\n                    color: \"rgba(100, 100, 100, 0.6)\",\n                    width: 3\n                },\n                text: sortedIndices.map((i)=>{\n                    const row = data[i];\n                    let tooltip = \"<b>Point temporel \".concat(i + 1, \"</b><br>\");\n                    tooltip += \"<b>Temps:</b> \".concat(row[timeColumn] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>Valeur:</b> \".concat(row[valueColumn] || \"N/A\", \"<br>\");\n                    return tooltip;\n                }),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Timeline 3D - \".concat(data.length, \" points\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Timeline 3D - \\xc9volution Temporelle\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // Fonctions de rendu simplifiées pour les autres modèles\n    const renderAnimatedScatter = (analysis)=>renderClassicScatter(analysis);\n    const renderClusteredScatter = (analysis)=>renderBubbleScatter(analysis);\n    const renderClassicSurface = (analysis)=>renderContourSurface(analysis);\n    const renderMeshSurface = (analysis)=>renderContourSurface(analysis);\n    const renderGradientSurface = (analysis)=>renderContourSurface(analysis);\n    const renderClassicBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderGroupedBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderCylindricalBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderPyramidBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderSpherePack = (analysis)=>renderBubbleScatter(analysis);\n    const renderCubeMatrix = (analysis)=>renderClassicScatter(analysis);\n    const renderConeField = (analysis)=>renderClassicScatter(analysis);\n    const renderHelixSpiral = (analysis)=>renderDNAHelix(analysis);\n    const renderFractal3D = (analysis)=>renderMandala3D(analysis);\n    const renderCrystal3D = (analysis)=>renderClassicScatter(analysis);\n    const renderNetwork3D = (analysis)=>renderClassicScatter(analysis);\n    const renderTree3D = (analysis)=>renderClassicScatter(analysis);\n    const renderWaveTemporal = (analysis)=>renderTimeline3D(analysis);\n    const renderSpiralTime = (analysis)=>renderTimeline3D(analysis);\n    const renderGlobe3D = (analysis)=>renderClassicScatter(analysis);\n    const renderTerrain3D = (analysis)=>renderContourSurface(analysis);\n    const renderMolecule3D = (analysis)=>renderClassicScatter(analysis);\n    const renderVectorField = (analysis)=>renderClassicScatter(analysis);\n    const renderHistogram3D = (analysis)=>renderBubbleScatter(analysis);\n    const renderBoxPlot3D = (analysis)=>renderBubbleScatter(analysis);\n    // 7. SURFACE AVEC CONTOURS - Basée sur les vraies données\n    const renderContourSurface = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        const xRange = analysis.dataRanges[analysis.mapping.xAxis];\n        const yRange = analysis.dataRanges[analysis.mapping.yAxis];\n        if (!xRange || !yRange) {\n            renderClassicScatter(analysis);\n            return;\n        }\n        // Adapter la résolution selon la densité des données\n        const size = Math.min(30, Math.max(15, Math.sqrt(data.length)));\n        const xMin = xRange.min;\n        const xMax = xRange.max;\n        const yMin = yRange.min;\n        const yMax = yRange.max;\n        const xGrid = Array.from({\n            length: size\n        }, (_, i)=>xMin + i / (size - 1) * (xMax - xMin));\n        const yGrid = Array.from({\n            length: size\n        }, (_, i)=>yMin + i / (size - 1) * (yMax - yMin));\n        const surface = [];\n        for(let i = 0; i < size; i++){\n            const row = [];\n            for(let j = 0; j < size; j++){\n                const targetX = xGrid[j];\n                const targetY = yGrid[i];\n                // Interpolation pondérée par la distance\n                let weightedSum = 0;\n                let totalWeight = 0;\n                const maxDistance = Math.sqrt((xMax - xMin) ** 2 + (yMax - yMin) ** 2) / 5;\n                for(let k = 0; k < data.length; k++){\n                    const dx = xValues[k] - targetX;\n                    const dy = yValues[k] - targetY;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    if (distance < maxDistance) {\n                        const weight = Math.exp(-(distance * distance) / (maxDistance * maxDistance));\n                        weightedSum += zValues[k] * weight;\n                        totalWeight += weight;\n                    }\n                }\n                row.push(totalWeight > 0 ? weightedSum / totalWeight : 0);\n            }\n            surface.push(row);\n        }\n        const plotData = [\n            {\n                type: \"surface\",\n                z: surface,\n                x: xGrid,\n                y: yGrid,\n                colorscale: \"Earth\",\n                contours: {\n                    z: {\n                        show: true,\n                        usecolormap: true,\n                        highlightcolor: \"#42f462\",\n                        project: {\n                            z: true\n                        },\n                        width: 2\n                    }\n                },\n                colorbar: {\n                    title: analysis.mapping.zAxis,\n                    titlefont: {\n                        size: 10\n                    }\n                },\n                name: \"Surface - \".concat(data.length, \" points source\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Surface 3D - Lignes de Niveau\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 8. HÉLICE ADN - Basée sur les séquences de données\n    const renderDNAHelix = (analysis)=>{\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        const dnaX1 = [];\n        const dnaY1 = [];\n        const dnaZ1 = [];\n        const dnaX2 = [];\n        const dnaY2 = [];\n        const dnaZ2 = [];\n        const dnaColors = [];\n        const dnaSizes = [];\n        // Utiliser les vraies données pour moduler l'hélice\n        const colorRange = analysis.dataRanges[analysis.mapping.colorBy];\n        const sizeRange = analysis.dataRanges[analysis.mapping.sizeBy];\n        data.forEach((row, i)=>{\n            const t = i / data.length * 8 * Math.PI;\n            const z = i / data.length * 4;\n            // Modulation basée sur les données\n            const colorVal = colorValues[i];\n            const sizeVal = sizeValues[i];\n            const radiusModulation = colorRange ? 1 + 0.3 * (colorVal - colorRange.min) / (colorRange.max - colorRange.min) : 1;\n            const heightModulation = sizeRange ? 0.1 * (sizeVal - sizeRange.min) / (sizeRange.max - sizeRange.min) : 0;\n            // Premier brin\n            dnaX1.push(Math.cos(t) * radiusModulation);\n            dnaY1.push(Math.sin(t) * radiusModulation);\n            dnaZ1.push(z + heightModulation);\n            // Deuxième brin (décalé de π)\n            dnaX2.push(Math.cos(t + Math.PI) * radiusModulation);\n            dnaY2.push(Math.sin(t + Math.PI) * radiusModulation);\n            dnaZ2.push(z + heightModulation);\n            dnaColors.push(colorVal);\n            dnaSizes.push(Math.max(4, Math.min(10, sizeVal / ((sizeRange === null || sizeRange === void 0 ? void 0 : sizeRange.max) || 1) * 6 + 4)));\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers+lines\",\n                x: dnaX1,\n                y: dnaY1,\n                z: dnaZ1,\n                marker: {\n                    size: dnaSizes,\n                    color: dnaColors,\n                    colorscale: \"RdYlBu\",\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                line: {\n                    color: \"rgba(255, 100, 100, 0.8)\",\n                    width: 4\n                },\n                name: \"Brin ADN 1 - \".concat(data.length, \" bases\")\n            },\n            {\n                type: \"scatter3d\",\n                mode: \"markers+lines\",\n                x: dnaX2,\n                y: dnaY2,\n                z: dnaZ2,\n                marker: {\n                    size: dnaSizes,\n                    color: dnaColors,\n                    colorscale: \"RdYlBu\"\n                },\n                line: {\n                    color: \"rgba(100, 100, 255, 0.8)\",\n                    width: 4\n                },\n                name: \"Brin ADN 2 - \".concat(data.length, \" bases\"),\n                showlegend: false\n            }\n        ];\n        const layout = createDynamicLayout(\"Double H\\xe9lice ADN\", analysis);\n        layout.scene.camera = {\n            eye: {\n                x: 2,\n                y: 0,\n                z: 1\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // Fonction pour créer un layout dynamique basé sur l'analyse\n    const createDynamicLayout = (title, analysis)=>{\n        const dataInfo = \"\".concat(data.length, \" entr\\xe9es • \").concat(analysis.numericColumns.length, \" num. • \").concat(analysis.categoricalColumns.length, \" cat.\");\n        return {\n            scene: {\n                xaxis: {\n                    title: {\n                        text: \"\".concat(analysis.mapping.xAxis, \" \").concat(analysis.dataTypes[analysis.mapping.xAxis] ? \"(\".concat(analysis.dataTypes[analysis.mapping.xAxis], \")\") : \"\"),\n                        font: {\n                            size: 12,\n                            color: \"#ea580c\"\n                        }\n                    },\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                yaxis: {\n                    title: {\n                        text: \"\".concat(analysis.mapping.yAxis, \" \").concat(analysis.dataTypes[analysis.mapping.yAxis] ? \"(\".concat(analysis.dataTypes[analysis.mapping.yAxis], \")\") : \"\"),\n                        font: {\n                            size: 12,\n                            color: \"#ea580c\"\n                        }\n                    },\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                zaxis: {\n                    title: {\n                        text: \"\".concat(analysis.mapping.zAxis, \" \").concat(analysis.dataTypes[analysis.mapping.zAxis] ? \"(\".concat(analysis.dataTypes[analysis.mapping.zAxis], \")\") : \"\"),\n                        font: {\n                            size: 12,\n                            color: \"#ea580c\"\n                        }\n                    },\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                camera: {\n                    eye: {\n                        x: 1.25,\n                        y: 1.25,\n                        z: 1.25\n                    }\n                }\n            },\n            title: {\n                text: title,\n                font: {\n                    size: 18,\n                    color: \"#ea580c\"\n                }\n            },\n            paper_bgcolor: \"rgba(0,0,0,0)\",\n            margin: {\n                l: 0,\n                r: 0,\n                t: 60,\n                b: 0\n            },\n            annotations: [\n                {\n                    text: \"<b>Mod\\xe8le:</b> \".concat(title, \"<br><b>Donn\\xe9es:</b> \").concat(dataInfo, \"<br><b>Mapping:</b><br>• X: \").concat(analysis.mapping.xAxis, \"<br>• Y: \").concat(analysis.mapping.yAxis, \"<br>• Z: \").concat(analysis.mapping.zAxis, \"<br>• Couleur: \").concat(analysis.mapping.colorBy, \"<br>• Taille: \").concat(analysis.mapping.sizeBy).concat(analysis.mapping.categoryBy ? \"<br>• Cat\\xe9gorie: \".concat(analysis.mapping.categoryBy) : \"\"),\n                    showarrow: false,\n                    xref: \"paper\",\n                    yref: \"paper\",\n                    x: -0.15,\n                    y: 0.95,\n                    xanchor: \"left\",\n                    yanchor: \"top\",\n                    bgcolor: \"rgba(255, 255, 255, 0.8)\",\n                    bordercolor: \"rgba(234, 88, 12, 0.3)\",\n                    borderwidth: 1,\n                    font: {\n                        size: 8,\n                        color: \"#666\"\n                    }\n                }\n            ]\n        };\n    };\n    const getPlotConfig = ()=>({\n            responsive: true,\n            displayModeBar: false,\n            staticPlot: false,\n            scrollZoom: true,\n            doubleClick: \"reset\"\n        });\n    const renderV0Visualization = (config)=>{\n        try {\n            window.Plotly.newPlot(plotRef.current, config.config.data, config.config.layout, getPlotConfig());\n        } catch (error) {\n            console.error(\"Erreur rendu v0:\", error);\n            renderModelSpecificVisualization();\n        }\n    };\n    const renderDemoVisualization = ()=>{\n        const demoData = Array.from({\n            length: 50\n        }, (_, i)=>({\n                x: Math.random() * 10,\n                y: Math.random() * 10,\n                z: Math.random() * 10,\n                value: Math.random() * 100,\n                category: \"Cat\".concat(Math.floor(Math.random() * 5) + 1)\n            }));\n        setDataMapping({\n            xAxis: \"Dimension X\",\n            yAxis: \"Dimension Y\",\n            zAxis: \"Dimension Z\",\n            colorBy: \"Valeur\",\n            sizeBy: \"Valeur\"\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: demoData.map((d)=>d.x),\n                y: demoData.map((d)=>d.y),\n                z: demoData.map((d)=>d.z),\n                marker: {\n                    size: 8,\n                    color: demoData.map((d)=>d.value),\n                    colorscale: \"Rainbow\",\n                    opacity: 0.8\n                },\n                name: \"D\\xe9monstration\"\n            }\n        ];\n        const layout = {\n            scene: {\n                xaxis: {\n                    title: \"Dimension X\",\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                yaxis: {\n                    title: \"Dimension Y\",\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                zaxis: {\n                    title: \"Dimension Z\",\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                camera: {\n                    eye: {\n                        x: 1.25,\n                        y: 1.25,\n                        z: 1.25\n                    }\n                }\n            },\n            title: {\n                text: \"D\\xe9monstration - \".concat(getModelName(visualizationType)),\n                font: {\n                    size: 18,\n                    color: \"#ea580c\"\n                }\n            },\n            paper_bgcolor: \"rgba(0,0,0,0)\",\n            margin: {\n                l: 0,\n                r: 0,\n                t: 60,\n                b: 0\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    const getModelName = (modelId)=>{\n        const names = {\n            scatter3d: \"Nuage 3D Classique\",\n            scatter_density: \"Densit\\xe9 3D\",\n            scatter_bubble: \"Bulles 3D\",\n            mandala_3d: \"Mandala 3D\",\n            galaxy_3d: \"Galaxie 3D\",\n            surface_contour: \"Surface Contours\",\n            dna_helix: \"H\\xe9lice ADN\",\n            timeline_3d: \"Timeline 3D\"\n        };\n        return names[modelId] || \"Visualisation 3D\";\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-full bg-gradient-to-br from-orange-50 to-white rounded-xl border-2 border-orange-200 overflow-hidden\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-6 border-b border-orange-200 bg-white\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-3\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-12 h-12 bg-gradient-to-br from-orange-600 to-orange-500 rounded-xl flex items-center justify-center\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                        className: \"w-6 h-6 text-white\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                        lineNumber: 1119,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1118,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                            className: \"text-xl font-bold text-gray-800\",\n                                            children: \"Canvas IA • Visualisation Dynamique\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1122,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-sm text-gray-600\",\n                                            children: data.length > 0 ? \"\".concat(data.length, \" \\xe9chantillons • \").concat(columns.length, \" variables • \").concat(getModelName(currentModel)) : \"Mode d\\xe9monstration • \".concat(getModelName(currentModel))\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1123,\n                                            columnNumber: 15\n                                        }, this),\n                                        dataAnalysis && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-xs text-gray-500\",\n                                            children: [\n                                                dataAnalysis.numericColumns.length,\n                                                \" num\\xe9riques • \",\n                                                dataAnalysis.categoricalColumns.length,\n                                                \" \",\n                                                \"cat\\xe9gorielles • \",\n                                                dataAnalysis.temporalColumns.length,\n                                                \" temporelles\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1129,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1121,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                            lineNumber: 1117,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: [\n                                isV0Generated && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                            className: \"w-3 h-3 mr-1\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1140,\n                                            columnNumber: 17\n                                        }, this),\n                                        \"G\\xe9n\\xe9r\\xe9 par v0\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1139,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-orange-100 text-orange-800\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                            className: \"w-3 h-3 mr-1\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1145,\n                                            columnNumber: 15\n                                        }, this),\n                                        \"Plotly v2.35\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1144,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800\",\n                                    children: \"Adaptatif Dynamique\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1148,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                            lineNumber: 1137,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                    lineNumber: 1116,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                lineNumber: 1115,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative h-[calc(100%-120px)]\",\n                children: !plotlyLoaded ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-center h-full\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-8 h-8 border-2 border-orange-500 border-t-transparent rounded-full animate-spin mx-auto mb-4\"\n                            }, void 0, false, {\n                                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                lineNumber: 1160,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-gray-600\",\n                                children: \"Chargement de Plotly.js v2.35...\"\n                            }, void 0, false, {\n                                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                lineNumber: 1161,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-gray-500 mt-2\",\n                                children: \"Analyse dynamique des donn\\xe9es en cours...\"\n                            }, void 0, false, {\n                                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                lineNumber: 1162,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                        lineNumber: 1159,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                    lineNumber: 1158,\n                    columnNumber: 11\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    ref: plotRef,\n                    className: \"w-full h-full\"\n                }, void 0, false, {\n                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                    lineNumber: 1166,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                lineNumber: 1156,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n        lineNumber: 1113,\n        columnNumber: 5\n    }, this);\n}\n_s(Canvas3DVisualization, \"eO0E6itovXilb3IAoe61XKZZfX8=\");\n_c = Canvas3DVisualization;\nvar _c;\n$RefreshReg$(_c, \"Canvas3DVisualization\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQ2FudmFzM0RWaXN1YWxpemF0aW9uLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDQztBQW1DckMsU0FBU00sc0JBQXNCLEtBS2pCO1FBTGlCLEVBQzVDQyxJQUFJLEVBQ0pDLE9BQU8sRUFDUEMsaUJBQWlCLEVBQ2pCQyxlQUFlLEVBQ1ksR0FMaUI7O0lBTTVDLE1BQU1DLFVBQVVWLDZDQUFNQSxDQUFpQjtJQUN2QyxNQUFNLENBQUNXLGVBQWVDLGlCQUFpQixHQUFHWCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNZLGNBQWNDLGdCQUFnQixHQUFHYiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNjLGFBQWFDLGVBQWUsR0FBR2YsK0NBQVFBLENBQXFCO0lBQ25FLE1BQU0sQ0FBQ2dCLGNBQWNDLGdCQUFnQixHQUFHakIsK0NBQVFBLENBQVM7SUFDekQsTUFBTSxDQUFDa0IsY0FBY0MsZ0JBQWdCLEdBQUduQiwrQ0FBUUEsQ0FBc0I7SUFFdEUsb0JBQW9CO0lBQ3BCRixnREFBU0EsQ0FBQztRQUNSLElBQUksS0FBNkIsSUFBSSxDQUFDc0IsT0FBT0MsTUFBTSxFQUFFO1lBQ25ELE1BQU1DLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztZQUN0Q0YsT0FBT0csR0FBRyxHQUFHO1lBQ2JILE9BQU9JLE1BQU0sR0FBRyxJQUFNYixnQkFBZ0I7WUFDdENTLE9BQU9LLE9BQU8sR0FBRztnQkFDZkMsUUFBUUMsS0FBSyxDQUFDO2dCQUNkaEIsZ0JBQWdCO1lBQ2xCO1lBQ0FVLFNBQVNPLElBQUksQ0FBQ0MsV0FBVyxDQUFDVDtRQUM1QixPQUFPLElBQUlGLE9BQU9DLE1BQU0sRUFBRTtZQUN4QlIsZ0JBQWdCO1FBQ2xCO0lBQ0YsR0FBRyxFQUFFO0lBRUxmLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDYyxnQkFBZ0IsQ0FBQ0gsUUFBUXVCLE9BQU8sRUFBRTtRQUV2QyxrQ0FBa0M7UUFD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d0NBQWlCOzs7Ozs7OzhDQUlyQyw4REFBQ0U7b0NBQUtGLFdBQVU7O3NEQUNkLDhEQUFDOVMsK0ZBQUdBOzRDQUFDOFMsV0FBVTs7Ozs7O3dDQUFpQjs7Ozs7Ozs4Q0FHbEMsOERBQUNFO29DQUFLRixXQUFVOzhDQUFrRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBUXhILDhEQUFDRDtnQkFBSUMsV0FBVTswQkFDWixDQUFDcFMsNkJBQ0EsOERBQUNtUztvQkFBSUMsV0FBVTs4QkFDYiw0RUFBQ0Q7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDRDtnQ0FBSUMsV0FBVTs7Ozs7OzBDQUNmLDhEQUFDcEk7Z0NBQUVvSSxXQUFVOzBDQUFnQjs7Ozs7OzBDQUM3Qiw4REFBQ3BJO2dDQUFFb0ksV0FBVTswQ0FBNkI7Ozs7Ozs7Ozs7Ozs7Ozs7eUNBSTlDLDhEQUFDRDtvQkFBSUksS0FBSzFTO29CQUFTdVMsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLdkM7R0E1bUN3QjVTO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FudmFzM0RWaXN1YWxpemF0aW9uLnRzeD9kYzUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBUcmVuZGluZ1VwLCBaYXAsIENvZGUgfSBmcm9tIFwibHVjaWRlLXJlYWN0XCJcblxuLy8gRMOpY2xhcmF0aW9uIHBvdXIgVHlwZVNjcmlwdCAtIFBsb3RseVxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBQbG90bHk6IGFueVxuICB9XG59XG5cbmludGVyZmFjZSBDYW52YXMzRFZpc3VhbGl6YXRpb25Qcm9wcyB7XG4gIGRhdGE6IGFueVtdXG4gIGNvbHVtbnM6IHN0cmluZ1tdXG4gIHZpc3VhbGl6YXRpb25UeXBlOiBzdHJpbmdcbiAgZ2VuZXJhdGVkQ29uZmlnPzogYW55XG59XG5cbmludGVyZmFjZSBEYXRhTWFwcGluZyB7XG4gIHhBeGlzOiBzdHJpbmdcbiAgeUF4aXM6IHN0cmluZ1xuICB6QXhpczogc3RyaW5nXG4gIGNvbG9yQnk6IHN0cmluZ1xuICBzaXplQnk6IHN0cmluZ1xuICBjYXRlZ29yeUJ5Pzogc3RyaW5nXG59XG5cbmludGVyZmFjZSBEYXRhQW5hbHlzaXMge1xuICBtYXBwaW5nOiBEYXRhTWFwcGluZ1xuICBudW1lcmljQ29sdW1uczogc3RyaW5nW11cbiAgY2F0ZWdvcmljYWxDb2x1bW5zOiBzdHJpbmdbXVxuICB0ZW1wb3JhbENvbHVtbnM6IHN0cmluZ1tdXG4gIGRhdGFSYW5nZXM6IHsgW2tleTogc3RyaW5nXTogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXI7IHZhbHVlczogbnVtYmVyW10gfSB9XG4gIGNhdGVnb3JpZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nW10gfVxuICBkYXRhVHlwZXM6IHsgW2tleTogc3RyaW5nXTogXCJudW1lcmljXCIgfCBcImNhdGVnb3JpY2FsXCIgfCBcInRlbXBvcmFsXCIgfCBcIm1peGVkXCIgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDYW52YXMzRFZpc3VhbGl6YXRpb24oe1xuICBkYXRhLFxuICBjb2x1bW5zLFxuICB2aXN1YWxpemF0aW9uVHlwZSxcbiAgZ2VuZXJhdGVkQ29uZmlnLFxufTogQ2FudmFzM0RWaXN1YWxpemF0aW9uUHJvcHMpIHtcbiAgY29uc3QgcGxvdFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbClcbiAgY29uc3QgW2lzVjBHZW5lcmF0ZWQsIHNldElzVjBHZW5lcmF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtwbG90bHlMb2FkZWQsIHNldFBsb3RseUxvYWRlZF0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2RhdGFNYXBwaW5nLCBzZXREYXRhTWFwcGluZ10gPSB1c2VTdGF0ZTxEYXRhTWFwcGluZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtjdXJyZW50TW9kZWwsIHNldEN1cnJlbnRNb2RlbF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwic2NhdHRlcjNkXCIpXG4gIGNvbnN0IFtkYXRhQW5hbHlzaXMsIHNldERhdGFBbmFseXNpc10gPSB1c2VTdGF0ZTxEYXRhQW5hbHlzaXMgfCBudWxsPihudWxsKVxuXG4gIC8vIENoYXJnZXIgUGxvdGx5LmpzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXdpbmRvdy5QbG90bHkpIHtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcbiAgICAgIHNjcmlwdC5zcmMgPSBcImh0dHBzOi8vY2RuLnBsb3QubHkvcGxvdGx5LTIuMzUuMi5taW4uanNcIlxuICAgICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHNldFBsb3RseUxvYWRlZCh0cnVlKVxuICAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJldXIgbG9ycyBkdSBjaGFyZ2VtZW50IGRlIFBsb3RseS5qc1wiKVxuICAgICAgICBzZXRQbG90bHlMb2FkZWQoZmFsc2UpXG4gICAgICB9XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5QbG90bHkpIHtcbiAgICAgIHNldFBsb3RseUxvYWRlZCh0cnVlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXBsb3RseUxvYWRlZCB8fCAhcGxvdFJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgIC8vIE5ldHRveWVyIGxlIGdyYXBoaXF1ZSBwcsOpY8OpZGVudFxuICAgIGlmIChwbG90UmVmLmN1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgd2luZG93LlBsb3RseS5wdXJnZShwbG90UmVmLmN1cnJlbnQpXG4gICAgfVxuXG4gICAgc2V0Q3VycmVudE1vZGVsKHZpc3VhbGl6YXRpb25UeXBlKVxuXG4gICAgLy8gVG91am91cnMgdsOpcmlmaWVyIHNpIGdlbmVyYXRlZENvbmZpZyBleGlzdGUgZXQgZXN0IGFzc29jacOpIGF1IHR5cGUgYWN0dWVsXG4gICAgaWYgKGdlbmVyYXRlZENvbmZpZyAmJiBnZW5lcmF0ZWRDb25maWcudHlwZSA9PT0gdmlzdWFsaXphdGlvblR5cGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXRpbGlzYXRpb24gZGUgbGEgY29uZmlndXJhdGlvbiBnw6luw6lyw6llIHBvdXJcIiwgdmlzdWFsaXphdGlvblR5cGUpXG4gICAgICByZW5kZXJWMFZpc3VhbGl6YXRpb24oZ2VuZXJhdGVkQ29uZmlnKVxuICAgICAgc2V0SXNWMEdlbmVyYXRlZCh0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkfDqW7DqXJhdGlvbiBsb2NhbGUgcG91clwiLCB2aXN1YWxpemF0aW9uVHlwZSlcbiAgICAgIC8vIFNpIGxhIGNvbmZpZyBuZSBjb3JyZXNwb25kIHBhcyBhdSB0eXBlIGFjdHVlbCwgb24gZ8OpbsOocmUgbG9jYWxlbWVudFxuICAgICAgcmVuZGVyTW9kZWxTcGVjaWZpY1Zpc3VhbGl6YXRpb24oKVxuICAgICAgc2V0SXNWMEdlbmVyYXRlZChmYWxzZSlcbiAgICB9XG4gIH0sIFtwbG90bHlMb2FkZWQsIGRhdGEsIGNvbHVtbnMsIHZpc3VhbGl6YXRpb25UeXBlLCBnZW5lcmF0ZWRDb25maWddKVxuXG4gIC8vIEFuYWx5c2UgY29tcGzDqHRlIGV0IGludGVsbGlnZW50ZSBkZXMgZG9ubsOpZXNcbiAgY29uc3QgYW5hbHl6ZURhdGFJbnRlbGxpZ2VudGx5ID0gKCk6IERhdGFBbmFseXNpcyB8IG51bGwgPT4ge1xuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCB8fCAhY29sdW1ucyB8fCBjb2x1bW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBhbmFseXNpczogRGF0YUFuYWx5c2lzID0ge1xuICAgICAgbWFwcGluZzoge30gYXMgRGF0YU1hcHBpbmcsXG4gICAgICBudW1lcmljQ29sdW1uczogW10sXG4gICAgICBjYXRlZ29yaWNhbENvbHVtbnM6IFtdLFxuICAgICAgdGVtcG9yYWxDb2x1bW5zOiBbXSxcbiAgICAgIGRhdGFSYW5nZXM6IHt9LFxuICAgICAgY2F0ZWdvcmllczoge30sXG4gICAgICBkYXRhVHlwZXM6IHt9LFxuICAgIH1cblxuICAgIC8vIEFuYWx5c2VyIGNoYXF1ZSBjb2xvbm5lIGVuIGTDqXRhaWxcbiAgICBjb2x1bW5zLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gZGF0YS5tYXAoKHJvdykgPT4gcm93W2NvbF0pLmZpbHRlcigodmFsKSA9PiB2YWwgIT0gbnVsbCAmJiB2YWwgIT09IFwiXCIpXG5cbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFuYWx5c2lzLmRhdGFUeXBlc1tjb2xdID0gXCJtaXhlZFwiXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IG51bcOpcmlxdWVcbiAgICAgIGNvbnN0IG51bWVyaWNWYWx1ZXMgPSB2YWx1ZXMubWFwKCh2YWwpID0+IE51bWJlci5wYXJzZUZsb2F0KHZhbCkpLmZpbHRlcigodmFsKSA9PiAhaXNOYU4odmFsKSAmJiBpc0Zpbml0ZSh2YWwpKVxuICAgICAgY29uc3QgbnVtZXJpY1JhdGlvID0gbnVtZXJpY1ZhbHVlcy5sZW5ndGggLyB2YWx1ZXMubGVuZ3RoXG5cbiAgICAgIC8vIFRlc3QgdGVtcG9yZWxcbiAgICAgIGNvbnN0IGRhdGVWYWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKCh2YWwpID0+IHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbClcbiAgICAgICAgcmV0dXJuICFpc05hTihkYXRlLmdldFRpbWUoKSkgJiYgZGF0ZS5nZXRGdWxsWWVhcigpID4gMTkwMCAmJiBkYXRlLmdldEZ1bGxZZWFyKCkgPCAyMTAwXG4gICAgICB9KVxuICAgICAgY29uc3QgdGVtcG9yYWxSYXRpbyA9IGRhdGVWYWx1ZXMubGVuZ3RoIC8gdmFsdWVzLmxlbmd0aFxuXG4gICAgICAvLyBUZXN0IGNhdMOpZ29yaWVsXG4gICAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBbLi4ubmV3IFNldCh2YWx1ZXMpXVxuICAgICAgY29uc3QgdW5pcXVlUmF0aW8gPSB1bmlxdWVWYWx1ZXMubGVuZ3RoIC8gdmFsdWVzLmxlbmd0aFxuXG4gICAgICAvLyBDbGFzc2lmaWNhdGlvbiBpbnRlbGxpZ2VudGVcbiAgICAgIGlmICh0ZW1wb3JhbFJhdGlvID4gMC43KSB7XG4gICAgICAgIGFuYWx5c2lzLmRhdGFUeXBlc1tjb2xdID0gXCJ0ZW1wb3JhbFwiXG4gICAgICAgIGFuYWx5c2lzLnRlbXBvcmFsQ29sdW1ucy5wdXNoKGNvbClcbiAgICAgICAgLy8gQ29udmVydGlyIGVuIHRpbWVzdGFtcHMgcG91ciBsZXMgY2FsY3Vsc1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBzID0gZGF0ZVZhbHVlcy5tYXAoKHZhbCkgPT4gbmV3IERhdGUodmFsKS5nZXRUaW1lKCkpXG4gICAgICAgIGFuYWx5c2lzLmRhdGFSYW5nZXNbY29sXSA9IHtcbiAgICAgICAgICBtaW46IE1hdGgubWluKC4uLnRpbWVzdGFtcHMpLFxuICAgICAgICAgIG1heDogTWF0aC5tYXgoLi4udGltZXN0YW1wcyksXG4gICAgICAgICAgdmFsdWVzOiB0aW1lc3RhbXBzLFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG51bWVyaWNSYXRpbyA+IDAuNykge1xuICAgICAgICBhbmFseXNpcy5kYXRhVHlwZXNbY29sXSA9IFwibnVtZXJpY1wiXG4gICAgICAgIGFuYWx5c2lzLm51bWVyaWNDb2x1bW5zLnB1c2goY29sKVxuICAgICAgICBhbmFseXNpcy5kYXRhUmFuZ2VzW2NvbF0gPSB7XG4gICAgICAgICAgbWluOiBNYXRoLm1pbiguLi5udW1lcmljVmFsdWVzKSxcbiAgICAgICAgICBtYXg6IE1hdGgubWF4KC4uLm51bWVyaWNWYWx1ZXMpLFxuICAgICAgICAgIHZhbHVlczogbnVtZXJpY1ZhbHVlcyxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1bmlxdWVSYXRpbyA8IDAuMyB8fCB1bmlxdWVWYWx1ZXMubGVuZ3RoIDw9IDIwKSB7XG4gICAgICAgIGFuYWx5c2lzLmRhdGFUeXBlc1tjb2xdID0gXCJjYXRlZ29yaWNhbFwiXG4gICAgICAgIGFuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1ucy5wdXNoKGNvbClcbiAgICAgICAgYW5hbHlzaXMuY2F0ZWdvcmllc1tjb2xdID0gdW5pcXVlVmFsdWVzLnNsaWNlKDAsIDIwKSAvLyBMaW1pdGVyIMOgIDIwIGNhdMOpZ29yaWVzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmFseXNpcy5kYXRhVHlwZXNbY29sXSA9IFwibWl4ZWRcIlxuICAgICAgICBpZiAobnVtZXJpY1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYW5hbHlzaXMuZGF0YVJhbmdlc1tjb2xdID0ge1xuICAgICAgICAgICAgbWluOiBNYXRoLm1pbiguLi5udW1lcmljVmFsdWVzKSxcbiAgICAgICAgICAgIG1heDogTWF0aC5tYXgoLi4ubnVtZXJpY1ZhbHVlcyksXG4gICAgICAgICAgICB2YWx1ZXM6IG51bWVyaWNWYWx1ZXMsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIENyw6llciB1biBtYXBwaW5nIGludGVsbGlnZW50IGJhc8OpIHN1ciBsZXMgdHlwZXMgZGUgZG9ubsOpZXNcbiAgICBjb25zdCBhbGxOdW1lcmljQ29scyA9IFsuLi5hbmFseXNpcy5udW1lcmljQ29sdW1ucywgLi4uYW5hbHlzaXMudGVtcG9yYWxDb2x1bW5zXVxuXG4gICAgaWYgKGFsbE51bWVyaWNDb2xzLmxlbmd0aCA+PSAzKSB7XG4gICAgICBhbmFseXNpcy5tYXBwaW5nID0ge1xuICAgICAgICB4QXhpczogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIHlBeGlzOiBhbGxOdW1lcmljQ29sc1sxXSxcbiAgICAgICAgekF4aXM6IGFsbE51bWVyaWNDb2xzWzJdLFxuICAgICAgICBjb2xvckJ5OiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgc2l6ZUJ5OiBhbGxOdW1lcmljQ29scy5sZW5ndGggPiAzID8gYWxsTnVtZXJpY0NvbHNbM10gOiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgY2F0ZWdvcnlCeTogYW5hbHlzaXMuY2F0ZWdvcmljYWxDb2x1bW5zWzBdLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWxsTnVtZXJpY0NvbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBhbmFseXNpcy5tYXBwaW5nID0ge1xuICAgICAgICB4QXhpczogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIHlBeGlzOiBhbGxOdW1lcmljQ29sc1sxXSxcbiAgICAgICAgekF4aXM6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICBjb2xvckJ5OiBhbGxOdW1lcmljQ29sc1sxXSxcbiAgICAgICAgc2l6ZUJ5OiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgY2F0ZWdvcnlCeTogYW5hbHlzaXMuY2F0ZWdvcmljYWxDb2x1bW5zWzBdLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWxsTnVtZXJpY0NvbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBhbmFseXNpcy5tYXBwaW5nID0ge1xuICAgICAgICB4QXhpczogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIHlBeGlzOiBcImluZGV4XCIsXG4gICAgICAgIHpBeGlzOiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgY29sb3JCeTogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIHNpemVCeTogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIGNhdGVnb3J5Qnk6IGFuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1uc1swXSxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXRpbGlzZXIgbGVzIGluZGljZXMgZXQgY2F0w6lnb3JpZXNcbiAgICAgIGFuYWx5c2lzLm1hcHBpbmcgPSB7XG4gICAgICAgIHhBeGlzOiBcImluZGV4XCIsXG4gICAgICAgIHlBeGlzOiBhbmFseXNpcy5jYXRlZ29yaWNhbENvbHVtbnNbMF0gfHwgXCJpbmRleFwiLFxuICAgICAgICB6QXhpczogXCJjb3VudFwiLFxuICAgICAgICBjb2xvckJ5OiBhbmFseXNpcy5jYXRlZ29yaWNhbENvbHVtbnNbMF0gfHwgXCJpbmRleFwiLFxuICAgICAgICBzaXplQnk6IFwiY291bnRcIixcbiAgICAgICAgY2F0ZWdvcnlCeTogYW5hbHlzaXMuY2F0ZWdvcmljYWxDb2x1bW5zWzBdLFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbmFseXNpc1xuICB9XG5cbiAgLy8gRm9uY3Rpb24gcHJpbmNpcGFsZSBxdWkgcm91dGUgdmVycyBsYSBib25uZSB2aXN1YWxpc2F0aW9uIHNlbG9uIGxlIG1vZMOobGVcbiAgY29uc3QgcmVuZGVyTW9kZWxTcGVjaWZpY1Zpc3VhbGl6YXRpb24gPSAoKSA9PiB7XG4gICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZW5kZXJEZW1vVmlzdWFsaXphdGlvbigpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhbmFseXNpcyA9IGFuYWx5emVEYXRhSW50ZWxsaWdlbnRseSgpXG4gICAgaWYgKCFhbmFseXNpcykge1xuICAgICAgcmVuZGVyRGVtb1Zpc3VhbGl6YXRpb24oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2V0RGF0YUFuYWx5c2lzKGFuYWx5c2lzKVxuICAgIHNldERhdGFNYXBwaW5nKGFuYWx5c2lzLm1hcHBpbmcpXG5cbiAgICAvLyBSb3V0ZXIgdmVycyBsYSBmb25jdGlvbiBzcMOpY2lhbGlzw6llIHNlbG9uIGxlIG1vZMOobGUgZXhhY3RcbiAgICBzd2l0Y2ggKHZpc3VhbGl6YXRpb25UeXBlKSB7XG4gICAgICAvLyBOVUFHRVNcbiAgICAgIGNhc2UgXCJzY2F0dGVyM2RcIjpcbiAgICAgICAgcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhdHRlcl9idWJibGVcIjpcbiAgICAgICAgcmVuZGVyQnViYmxlU2NhdHRlcihhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzY2F0dGVyX2FuaW1hdGVkXCI6XG4gICAgICAgIHJlbmRlckFuaW1hdGVkU2NhdHRlcihhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzY2F0dGVyX2NsdXN0ZXJlZFwiOlxuICAgICAgICByZW5kZXJDbHVzdGVyZWRTY2F0dGVyKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInNjYXR0ZXJfZGVuc2l0eVwiOlxuICAgICAgICByZW5kZXJEZW5zaXR5U2NhdHRlcihhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gU1VSRkFDRVNcbiAgICAgIGNhc2UgXCJzdXJmYWNlM2RcIjpcbiAgICAgICAgcmVuZGVyQ2xhc3NpY1N1cmZhY2UoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic3VyZmFjZV9jb250b3VyXCI6XG4gICAgICAgIHJlbmRlckNvbnRvdXJTdXJmYWNlKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInN1cmZhY2VfbWVzaFwiOlxuICAgICAgICByZW5kZXJNZXNoU3VyZmFjZShhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzdXJmYWNlX2dyYWRpZW50XCI6XG4gICAgICAgIHJlbmRlckdyYWRpZW50U3VyZmFjZShhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gQVJDSElURUNUVVJFXG4gICAgICBjYXNlIFwiYmFyczNkXCI6XG4gICAgICAgIHJlbmRlckNsYXNzaWNCYXJzKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImJhcnNfZ3JvdXBlZFwiOlxuICAgICAgICByZW5kZXJHcm91cGVkQmFycyhhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJiYXJzX2N5bGluZHJpY2FsXCI6XG4gICAgICAgIHJlbmRlckN5bGluZHJpY2FsQmFycyhhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJiYXJzX3B5cmFtaWRcIjpcbiAgICAgICAgcmVuZGVyUHlyYW1pZEJhcnMoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIEfDiU9Nw4lUUklRVUVTXG4gICAgICBjYXNlIFwic3BoZXJlX3BhY2tcIjpcbiAgICAgICAgcmVuZGVyU3BoZXJlUGFjayhhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJjdWJlX21hdHJpeFwiOlxuICAgICAgICByZW5kZXJDdWJlTWF0cml4KGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImNvbmVfZmllbGRcIjpcbiAgICAgICAgcmVuZGVyQ29uZUZpZWxkKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImhlbGl4X3NwaXJhbFwiOlxuICAgICAgICByZW5kZXJIZWxpeFNwaXJhbChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gQVJUSVNUSVFVRVNcbiAgICAgIGNhc2UgXCJtYW5kYWxhXzNkXCI6XG4gICAgICAgIHJlbmRlck1hbmRhbGEzRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJmcmFjdGFsXzNkXCI6XG4gICAgICAgIHJlbmRlckZyYWN0YWwzRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJjcnlzdGFsXzNkXCI6XG4gICAgICAgIHJlbmRlckNyeXN0YWwzRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJnYWxheHlfM2RcIjpcbiAgICAgICAgcmVuZGVyR2FsYXh5M0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiZG5hX2hlbGl4XCI6XG4gICAgICAgIHJlbmRlckROQUhlbGl4KGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBSw4lTRUFVWFxuICAgICAgY2FzZSBcIm5ldHdvcmtfM2RcIjpcbiAgICAgICAgcmVuZGVyTmV0d29yazNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInRyZWVfM2RcIjpcbiAgICAgICAgcmVuZGVyVHJlZTNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBURU1QT1JFTFNcbiAgICAgIGNhc2UgXCJ0aW1lbGluZV8zZFwiOlxuICAgICAgICByZW5kZXJUaW1lbGluZTNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcIndhdmVfdGVtcG9yYWxcIjpcbiAgICAgICAgcmVuZGVyV2F2ZVRlbXBvcmFsKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInNwaXJhbF90aW1lXCI6XG4gICAgICAgIHJlbmRlclNwaXJhbFRpbWUoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIEfDiU9HUkFQSElRVUVTXG4gICAgICBjYXNlIFwiZ2xvYmVfM2RcIjpcbiAgICAgICAgcmVuZGVyR2xvYmUzRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJ0ZXJyYWluXzNkXCI6XG4gICAgICAgIHJlbmRlclRlcnJhaW4zRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gU0NJRU5USUZJUVVFU1xuICAgICAgY2FzZSBcIm1vbGVjdWxlXzNkXCI6XG4gICAgICAgIHJlbmRlck1vbGVjdWxlM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwidmVjdG9yX2ZpZWxkXCI6XG4gICAgICAgIHJlbmRlclZlY3RvckZpZWxkKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBTVEFUSVNUSVFVRVNcbiAgICAgIGNhc2UgXCJoaXN0b2dyYW1fM2RcIjpcbiAgICAgICAgcmVuZGVySGlzdG9ncmFtM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiYm94X3Bsb3RfM2RcIjpcbiAgICAgICAgcmVuZGVyQm94UGxvdDNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgICB9XG4gIH1cblxuICAvLyBGb25jdGlvbiB1dGlsaXRhaXJlIHBvdXIgZXh0cmFpcmUgbGVzIHZhbGV1cnMgYXZlYyBsJ2FuYWx5c2VcbiAgY29uc3QgZ2V0VmFsdWVzRnJvbUFuYWx5c2lzID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMsIGtleToga2V5b2YgRGF0YU1hcHBpbmcpOiBudW1iZXJbXSA9PiB7XG4gICAgY29uc3QgY29sdW1uID0gYW5hbHlzaXMubWFwcGluZ1trZXldXG5cbiAgICBpZiAoY29sdW1uID09PSBcImluZGV4XCIpIHtcbiAgICAgIHJldHVybiBkYXRhLm1hcCgoXywgaSkgPT4gaSlcbiAgICB9IGVsc2UgaWYgKGNvbHVtbiA9PT0gXCJjb3VudFwiKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoKCkgPT4gMSlcbiAgICB9IGVsc2UgaWYgKGNvbHVtbiAmJiBjb2x1bW5zLmluY2x1ZGVzKGNvbHVtbikpIHtcbiAgICAgIGlmIChhbmFseXNpcy5kYXRhUmFuZ2VzW2NvbHVtbl0pIHtcbiAgICAgICAgLy8gVXRpbGlzZXIgbGVzIHZhbGV1cnMgcHLDqS1jYWxjdWzDqWVzIHBvdXIgbGVzIGNvbG9ubmVzIG51bcOpcmlxdWVzL3RlbXBvcmVsbGVzXG4gICAgICAgIGNvbnN0IHJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1tjb2x1bW5dXG4gICAgICAgIHJldHVybiBkYXRhLm1hcCgocm93LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsID0gcm93W2NvbHVtbl1cbiAgICAgICAgICBpZiAoYW5hbHlzaXMuZGF0YVR5cGVzW2NvbHVtbl0gPT09IFwidGVtcG9yYWxcIikge1xuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUodmFsKS5nZXRUaW1lKClcbiAgICAgICAgICAgIHJldHVybiBpc05hTih0aW1lc3RhbXApID8gcmFuZ2UubWluIDogdGltZXN0YW1wXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG51bVZhbCA9IE51bWJlci5wYXJzZUZsb2F0KHZhbClcbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4obnVtVmFsKSAmJiBpc0Zpbml0ZShudW1WYWwpID8gbnVtVmFsIDogcmFuZ2UubWluXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChhbmFseXNpcy5jYXRlZ29yaWVzW2NvbHVtbl0pIHtcbiAgICAgICAgLy8gQ29udmVydGlyIGxlcyBjYXTDqWdvcmllcyBlbiBpbmRpY2VzIG51bcOpcmlxdWVzXG4gICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBhbmFseXNpcy5jYXRlZ29yaWVzW2NvbHVtbl1cbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChyb3cpID0+IHtcbiAgICAgICAgICBjb25zdCB2YWwgPSByb3dbY29sdW1uXVxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2F0ZWdvcmllcy5pbmRleE9mKHZhbClcbiAgICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogMFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhLm1hcCgoXywgaSkgPT4gaSlcbiAgfVxuXG4gIC8vIFZJU1VBTElTQVRJT05TIFNQw4lDSUFMSVPDiUVTIEFWRUMgRE9OTsOJRVMgRFlOQU1JUVVFU1xuXG4gIC8vIDEuIE5VQUdFIENMQVNTSVFVRSAtIEFkYXB0w6kgYXV4IGRvbm7DqWVzXG4gIGNvbnN0IHJlbmRlckNsYXNzaWNTY2F0dGVyID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICBjb25zdCB4VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInhBeGlzXCIpXG4gICAgY29uc3QgeVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ5QXhpc1wiKVxuICAgIGNvbnN0IHpWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiekF4aXNcIilcbiAgICBjb25zdCBjb2xvclZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJjb2xvckJ5XCIpXG5cbiAgICAvLyBBZGFwdGVyIGxhIHRhaWxsZSBkZXMgbWFycXVldXJzIHNlbG9uIGxhIGRlbnNpdMOpIGRlcyBkb25uw6llc1xuICAgIGNvbnN0IG1hcmtlclNpemUgPSBNYXRoLm1heCgzLCBNYXRoLm1pbigxMiwgMTAwIC8gTWF0aC5zcXJ0KGRhdGEubGVuZ3RoKSkpXG5cbiAgICBjb25zdCBwbG90RGF0YSA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzY2F0dGVyM2RcIixcbiAgICAgICAgbW9kZTogXCJtYXJrZXJzXCIsXG4gICAgICAgIHg6IHhWYWx1ZXMsXG4gICAgICAgIHk6IHlWYWx1ZXMsXG4gICAgICAgIHo6IHpWYWx1ZXMsXG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgIHNpemU6IG1hcmtlclNpemUsXG4gICAgICAgICAgY29sb3I6IGNvbG9yVmFsdWVzLFxuICAgICAgICAgIGNvbG9yc2NhbGU6IFwiVmlyaWRpc1wiLFxuICAgICAgICAgIG9wYWNpdHk6IE1hdGgubWF4KDAuNiwgMSAtIGRhdGEubGVuZ3RoIC8gMTAwMCksIC8vIFRyYW5zcGFyZW5jZSBhZGFwdMOpZVxuICAgICAgICAgIGNvbG9yYmFyOiB7XG4gICAgICAgICAgICB0aXRsZTogYW5hbHlzaXMubWFwcGluZy5jb2xvckJ5LFxuICAgICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogZGF0YS5tYXAoKHJvdywgaSkgPT4ge1xuICAgICAgICAgIGxldCB0b29sdGlwID0gYDxiPlBvaW50ICR7aSArIDF9PC9iPjxicj5gXG4gICAgICAgICAgdG9vbHRpcCArPSBgPGI+JHthbmFseXNpcy5tYXBwaW5nLnhBeGlzfTo8L2I+ICR7cm93W2FuYWx5c2lzLm1hcHBpbmcueEF4aXNdIHx8IFwiTi9BXCJ9PGJyPmBcbiAgICAgICAgICB0b29sdGlwICs9IGA8Yj4ke2FuYWx5c2lzLm1hcHBpbmcueUF4aXN9OjwvYj4gJHtyb3dbYW5hbHlzaXMubWFwcGluZy55QXhpc10gfHwgXCJOL0FcIn08YnI+YFxuICAgICAgICAgIHRvb2x0aXAgKz0gYDxiPiR7YW5hbHlzaXMubWFwcGluZy56QXhpc306PC9iPiAke3Jvd1thbmFseXNpcy5tYXBwaW5nLnpBeGlzXSB8fCBcIk4vQVwifTxicj5gXG4gICAgICAgICAgaWYgKGFuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeSAmJiByb3dbYW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5XSkge1xuICAgICAgICAgICAgdG9vbHRpcCArPSBgPGI+JHthbmFseXNpcy5tYXBwaW5nLmNhdGVnb3J5Qnl9OjwvYj4gJHtyb3dbYW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5XX08YnI+YFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9vbHRpcFxuICAgICAgICB9KSxcbiAgICAgICAgaG92ZXJ0ZW1wbGF0ZTogXCIle3RleHR9PGV4dHJhPjwvZXh0cmE+XCIsXG4gICAgICAgIG5hbWU6IGBOdWFnZSAzRCAtICR7ZGF0YS5sZW5ndGh9IHBvaW50c2AsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZUR5bmFtaWNMYXlvdXQoXCJOdWFnZSAzRCBDbGFzc2lxdWVcIiwgYW5hbHlzaXMpXG4gICAgd2luZG93LlBsb3RseS5uZXdQbG90KHBsb3RSZWYuY3VycmVudCwgcGxvdERhdGEsIGxheW91dCwgZ2V0UGxvdENvbmZpZygpKVxuICB9XG5cbiAgLy8gMi4gREVOU0lUw4kgM0QgLSBWcmFpZSBkZW5zaXTDqSBiYXPDqWUgc3VyIGxlcyBkb25uw6llcyByw6llbGxlc1xuICBjb25zdCByZW5kZXJEZW5zaXR5U2NhdHRlciA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgeFZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ4QXhpc1wiKVxuICAgIGNvbnN0IHlWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieUF4aXNcIilcbiAgICBjb25zdCB6VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInpBeGlzXCIpXG5cbiAgICAvLyBBZGFwdGVyIGxhIHLDqXNvbHV0aW9uIGRlIGxhIGdyaWxsZSBzZWxvbiBsZSBub21icmUgZGUgZG9ubsOpZXNcbiAgICBjb25zdCBncmlkU2l6ZSA9IE1hdGgubWluKDI1LCBNYXRoLm1heCgxMCwgTWF0aC5zcXJ0KGRhdGEubGVuZ3RoKSkpXG5cbiAgICBjb25zdCB4UmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcueEF4aXNdXG4gICAgY29uc3QgeVJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLnlBeGlzXVxuICAgIGNvbnN0IHpSYW5nZSA9IGFuYWx5c2lzLmRhdGFSYW5nZXNbYW5hbHlzaXMubWFwcGluZy56QXhpc11cblxuICAgIGlmICgheFJhbmdlIHx8ICF5UmFuZ2UgfHwgIXpSYW5nZSkge1xuICAgICAgcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkZW5zaXR5WCA9IFtdXG4gICAgY29uc3QgZGVuc2l0eVkgPSBbXVxuICAgIGNvbnN0IGRlbnNpdHlaID0gW11cbiAgICBjb25zdCBkZW5zaXR5Q29sb3JzID0gW11cbiAgICBjb25zdCBkZW5zaXR5U2l6ZXMgPSBbXVxuXG4gICAgLy8gQ2FsY3VsZXIgbGUgcmF5b24gYWRhcHRhdGlmIGJhc8OpIHN1ciBsZXMgdnJhaWVzIGRvbm7DqWVzXG4gICAgY29uc3QgeFNwYW4gPSB4UmFuZ2UubWF4IC0geFJhbmdlLm1pblxuICAgIGNvbnN0IHlTcGFuID0geVJhbmdlLm1heCAtIHlSYW5nZS5taW5cbiAgICBjb25zdCB6U3BhbiA9IHpSYW5nZS5tYXggLSB6UmFuZ2UubWluXG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoeFNwYW4sIHlTcGFuLCB6U3BhbikgLyAoZ3JpZFNpemUgKiAwLjgpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWRTaXplOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JpZFNpemU7IGorKykge1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGdyaWRTaXplOyBrKyspIHtcbiAgICAgICAgICBjb25zdCB4ID0geFJhbmdlLm1pbiArIChpIC8gKGdyaWRTaXplIC0gMSkpICogeFNwYW5cbiAgICAgICAgICBjb25zdCB5ID0geVJhbmdlLm1pbiArIChqIC8gKGdyaWRTaXplIC0gMSkpICogeVNwYW5cbiAgICAgICAgICBjb25zdCB6ID0gelJhbmdlLm1pbiArIChrIC8gKGdyaWRTaXplIC0gMSkpICogelNwYW5cblxuICAgICAgICAgIC8vIENhbGN1bGVyIGxhIGRlbnNpdMOpIGxvY2FsZSBhdmVjIGxlcyB2cmFpZXMgZG9ubsOpZXNcbiAgICAgICAgICBsZXQgZGVuc2l0eSA9IDBcbiAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGRhdGEubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0geFZhbHVlc1twXSAtIHhcbiAgICAgICAgICAgIGNvbnN0IGR5ID0geVZhbHVlc1twXSAtIHlcbiAgICAgICAgICAgIGNvbnN0IGR6ID0gelZhbHVlc1twXSAtIHpcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeilcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IHJhZGl1cykge1xuICAgICAgICAgICAgICBkZW5zaXR5ICs9IE1hdGguZXhwKC0oZGlzdGFuY2UgKiBkaXN0YW5jZSkgLyAocmFkaXVzICogcmFkaXVzKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXVpbCBhZGFwdGF0aWYgYmFzw6kgc3VyIGxhIGRlbnNpdMOpIG1veWVubmVcbiAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSAoZGF0YS5sZW5ndGggLyAoZ3JpZFNpemUgKiBncmlkU2l6ZSAqIGdyaWRTaXplKSkgKiAwLjVcbiAgICAgICAgICBpZiAoZGVuc2l0eSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgZGVuc2l0eVgucHVzaCh4KVxuICAgICAgICAgICAgZGVuc2l0eVkucHVzaCh5KVxuICAgICAgICAgICAgZGVuc2l0eVoucHVzaCh6KVxuICAgICAgICAgICAgZGVuc2l0eUNvbG9ycy5wdXNoKGRlbnNpdHkpXG4gICAgICAgICAgICBkZW5zaXR5U2l6ZXMucHVzaChNYXRoLm1heCg0LCBNYXRoLm1pbigyMCwgZGVuc2l0eSAqIDE1KSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2Vyc1wiLFxuICAgICAgICB4OiBkZW5zaXR5WCxcbiAgICAgICAgeTogZGVuc2l0eVksXG4gICAgICAgIHo6IGRlbnNpdHlaLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBzaXplOiBkZW5zaXR5U2l6ZXMsXG4gICAgICAgICAgY29sb3I6IGRlbnNpdHlDb2xvcnMsXG4gICAgICAgICAgY29sb3JzY2FsZTogXCJIb3RcIixcbiAgICAgICAgICBvcGFjaXR5OiAwLjcsXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkRlbnNpdMOpIExvY2FsZVwiLFxuICAgICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogZGVuc2l0eVgubWFwKFxuICAgICAgICAgIChfLCBpKSA9PlxuICAgICAgICAgICAgYDxiPlpvbmUgRGVuc2UgJHtpICsgMX08L2I+PGJyPkRlbnNpdMOpOiAke2RlbnNpdHlDb2xvcnNbaV0udG9GaXhlZCgyKX08YnI+UG9zaXRpb246ICgke2RlbnNpdHlYW2ldLnRvRml4ZWQoMSl9LCAke2RlbnNpdHlZW2ldLnRvRml4ZWQoMSl9LCAke2RlbnNpdHlaW2ldLnRvRml4ZWQoMSl9KWAsXG4gICAgICAgICksXG4gICAgICAgIGhvdmVydGVtcGxhdGU6IFwiJXt0ZXh0fTxleHRyYT48L2V4dHJhPlwiLFxuICAgICAgICBuYW1lOiBgRGVuc2l0w6kgM0QgLSAke2RlbnNpdHlYLmxlbmd0aH0gem9uZXNgLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVEeW5hbWljTGF5b3V0KFwiRGVuc2l0w6kgM0QgLSBab25lcyBkZSBDb25jZW50cmF0aW9uXCIsIGFuYWx5c2lzKVxuICAgIHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90UmVmLmN1cnJlbnQsIHBsb3REYXRhLCBsYXlvdXQsIGdldFBsb3RDb25maWcoKSlcbiAgfVxuXG4gIC8vIDMuIEJVTExFUyAzRCAtIFRhaWxsZXMgdnJhaW1lbnQgcHJvcG9ydGlvbm5lbGxlcyBhdXggZG9ubsOpZXNcbiAgY29uc3QgcmVuZGVyQnViYmxlU2NhdHRlciA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgeFZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ4QXhpc1wiKVxuICAgIGNvbnN0IHlWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieUF4aXNcIilcbiAgICBjb25zdCB6VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInpBeGlzXCIpXG4gICAgY29uc3QgY29sb3JWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiY29sb3JCeVwiKVxuICAgIGNvbnN0IHNpemVWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwic2l6ZUJ5XCIpXG5cbiAgICAvLyBOb3JtYWxpc2VyIGxlcyB0YWlsbGVzIGJhc8OpZXMgc3VyIGxlcyB2cmFpZXMgZG9ubsOpZXNcbiAgICBjb25zdCBzaXplUmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcuc2l6ZUJ5XVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTaXplcyA9IHNpemVSYW5nZVxuICAgICAgPyBzaXplVmFsdWVzLm1hcCgodmFsKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9ICh2YWwgLSBzaXplUmFuZ2UubWluKSAvIChzaXplUmFuZ2UubWF4IC0gc2l6ZVJhbmdlLm1pbilcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoNSwgTWF0aC5taW4oMjUsIG5vcm1hbGl6ZWQgKiAyMCArIDUpKVxuICAgICAgICB9KVxuICAgICAgOiBzaXplVmFsdWVzLm1hcCgoKSA9PiAxMClcblxuICAgIGNvbnN0IHBsb3REYXRhID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnNcIixcbiAgICAgICAgeDogeFZhbHVlcyxcbiAgICAgICAgeTogeVZhbHVlcyxcbiAgICAgICAgejogelZhbHVlcyxcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgc2l6ZTogbm9ybWFsaXplZFNpemVzLFxuICAgICAgICAgIGNvbG9yOiBjb2xvclZhbHVlcyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlBsYXNtYVwiLFxuICAgICAgICAgIG9wYWNpdHk6IDAuNzUsXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBhbmFseXNpcy5tYXBwaW5nLmNvbG9yQnksXG4gICAgICAgICAgICB0aXRsZWZvbnQ6IHsgc2l6ZTogMTAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxpbmU6IHsgY29sb3I6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpXCIsIHdpZHRoOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQ6IGRhdGEubWFwKChyb3csIGkpID0+IHtcbiAgICAgICAgICBsZXQgdG9vbHRpcCA9IGA8Yj5CdWxsZSAke2kgKyAxfTwvYj48YnI+YFxuICAgICAgICAgIHRvb2x0aXAgKz0gYDxiPlRhaWxsZSAoJHthbmFseXNpcy5tYXBwaW5nLnNpemVCeX0pOjwvYj4gJHtyb3dbYW5hbHlzaXMubWFwcGluZy5zaXplQnldIHx8IFwiTi9BXCJ9PGJyPmBcbiAgICAgICAgICB0b29sdGlwICs9IGA8Yj5Db3VsZXVyICgke2FuYWx5c2lzLm1hcHBpbmcuY29sb3JCeX0pOjwvYj4gJHtyb3dbYW5hbHlzaXMubWFwcGluZy5jb2xvckJ5XSB8fCBcIk4vQVwifTxicj5gXG4gICAgICAgICAgaWYgKGFuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeSAmJiByb3dbYW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5XSkge1xuICAgICAgICAgICAgdG9vbHRpcCArPSBgPGI+Q2F0w6lnb3JpZTo8L2I+ICR7cm93W2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeV19PGJyPmBcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRvb2x0aXBcbiAgICAgICAgfSksXG4gICAgICAgIGhvdmVydGVtcGxhdGU6IFwiJXt0ZXh0fTxleHRyYT48L2V4dHJhPlwiLFxuICAgICAgICBuYW1lOiBgQnVsbGVzIDNEIC0gJHtkYXRhLmxlbmd0aH0gw6lsw6ltZW50c2AsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZUR5bmFtaWNMYXlvdXQoXCJCdWxsZXMgM0QgLSBUYWlsbGVzIFByb3BvcnRpb25uZWxsZXNcIiwgYW5hbHlzaXMpXG4gICAgd2luZG93LlBsb3RseS5uZXdQbG90KHBsb3RSZWYuY3VycmVudCwgcGxvdERhdGEsIGxheW91dCwgZ2V0UGxvdENvbmZpZygpKVxuICB9XG5cbiAgLy8gNC4gTUFOREFMQSAzRCAtIEJhc8OpIHN1ciBsZXMgcGF0dGVybnMgZGVzIGRvbm7DqWVzXG4gIGNvbnN0IHJlbmRlck1hbmRhbGEzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgY29sb3JWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiY29sb3JCeVwiKVxuICAgIGNvbnN0IHNpemVWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwic2l6ZUJ5XCIpXG5cbiAgICBjb25zdCBtYW5kYWxhWCA9IFtdXG4gICAgY29uc3QgbWFuZGFsYVkgPSBbXVxuICAgIGNvbnN0IG1hbmRhbGFaID0gW11cbiAgICBjb25zdCBtYW5kYWxhQ29sb3JzID0gW11cbiAgICBjb25zdCBtYW5kYWxhU2l6ZXMgPSBbXVxuXG4gICAgLy8gVXRpbGlzZXIgbGVzIHZyYWllcyBkb25uw6llcyBwb3VyIGNyw6llciBsZXMgcGF0dGVybnNcbiAgICBkYXRhLmZvckVhY2goKHJvdywgaSkgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEluZGV4ID0gaSAvIGRhdGEubGVuZ3RoXG4gICAgICBjb25zdCBjb2xvclZhbCA9IGNvbG9yVmFsdWVzW2ldXG4gICAgICBjb25zdCBzaXplVmFsID0gc2l6ZVZhbHVlc1tpXVxuXG4gICAgICAvLyBOb21icmUgZGUgdG91cnMgYmFzw6kgc3VyIGxhIHZhcmlhbmNlIGRlcyBkb25uw6llc1xuICAgICAgY29uc3QgY29sb3JSYW5nZSA9IGFuYWx5c2lzLmRhdGFSYW5nZXNbYW5hbHlzaXMubWFwcGluZy5jb2xvckJ5XVxuICAgICAgY29uc3QgdG91cnMgPSBjb2xvclJhbmdlID8gNCArICgoY29sb3JWYWwgLSBjb2xvclJhbmdlLm1pbikgLyAoY29sb3JSYW5nZS5tYXggLSBjb2xvclJhbmdlLm1pbikpICogNCA6IDZcblxuICAgICAgY29uc3QgYW5nbGUgPSBub3JtYWxpemVkSW5kZXggKiB0b3VycyAqIE1hdGguUElcbiAgICAgIGNvbnN0IHJhZGl1cyA9IDEgKyBNYXRoLnNpbihhbmdsZSAqIDMpICogMC41XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnNpbihhbmdsZSAqIDIpICogMC4zXG5cbiAgICAgIC8vIFBvaW50IHByaW5jaXBhbFxuICAgICAgbWFuZGFsYVgucHVzaChNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMpXG4gICAgICBtYW5kYWxhWS5wdXNoKE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cylcbiAgICAgIG1hbmRhbGFaLnB1c2goaGVpZ2h0KVxuICAgICAgbWFuZGFsYUNvbG9ycy5wdXNoKGNvbG9yVmFsKVxuICAgICAgbWFuZGFsYVNpemVzLnB1c2goTWF0aC5tYXgoMywgTWF0aC5taW4oOCwgKHNpemVWYWwgLyAoY29sb3JSYW5nZT8ubWF4IHx8IDEpKSAqIDYgKyAzKSkpXG5cbiAgICAgIC8vIFDDqXRhbGVzIGJhc8OpcyBzdXIgbGVzIGNhdMOpZ29yaWVzXG4gICAgICBjb25zdCBudW1QZXRhbHMgPVxuICAgICAgICBhbmFseXNpcy5tYXBwaW5nLmNhdGVnb3J5QnkgJiYgYW5hbHlzaXMuY2F0ZWdvcmllc1thbmFseXNpcy5tYXBwaW5nLmNhdGVnb3J5QnldXG4gICAgICAgICAgPyBNYXRoLm1pbig2LCBhbmFseXNpcy5jYXRlZ29yaWVzW2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeV0ubGVuZ3RoKVxuICAgICAgICAgIDogNVxuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVBldGFsczsgaisrKSB7XG4gICAgICAgIGNvbnN0IHBldGFsQW5nbGUgPSBhbmdsZSArIChqICogMiAqIE1hdGguUEkpIC8gbnVtUGV0YWxzXG4gICAgICAgIGNvbnN0IHBldGFsUmFkaXVzID0gcmFkaXVzICogMC4zXG4gICAgICAgIG1hbmRhbGFYLnB1c2goTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzICsgTWF0aC5jb3MocGV0YWxBbmdsZSkgKiBwZXRhbFJhZGl1cylcbiAgICAgICAgbWFuZGFsYVkucHVzaChNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMgKyBNYXRoLnNpbihwZXRhbEFuZ2xlKSAqIHBldGFsUmFkaXVzKVxuICAgICAgICBtYW5kYWxhWi5wdXNoKGhlaWdodCArIE1hdGguc2luKHBldGFsQW5nbGUgKiAyKSAqIDAuMSlcbiAgICAgICAgbWFuZGFsYUNvbG9ycy5wdXNoKGNvbG9yVmFsICogMC44KVxuICAgICAgICBtYW5kYWxhU2l6ZXMucHVzaChNYXRoLm1heCgyLCBtYW5kYWxhU2l6ZXNbbWFuZGFsYVNpemVzLmxlbmd0aCAtIDFdICogMC42KSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2Vyc1wiLFxuICAgICAgICB4OiBtYW5kYWxhWCxcbiAgICAgICAgeTogbWFuZGFsYVksXG4gICAgICAgIHo6IG1hbmRhbGFaLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBzaXplOiBtYW5kYWxhU2l6ZXMsXG4gICAgICAgICAgY29sb3I6IG1hbmRhbGFDb2xvcnMsXG4gICAgICAgICAgY29sb3JzY2FsZTogXCJSYWluYm93XCIsXG4gICAgICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgICAgIGNvbG9yYmFyOiB7XG4gICAgICAgICAgICB0aXRsZTogYEhhcm1vbmllICgke2FuYWx5c2lzLm1hcHBpbmcuY29sb3JCeX0pYCxcbiAgICAgICAgICAgIHRpdGxlZm9udDogeyBzaXplOiAxMCB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6IGBNYW5kYWxhIDNEIC0gJHtkYXRhLmxlbmd0aH0gw6lsw6ltZW50cyBzb3VyY2VgLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVEeW5hbWljTGF5b3V0KFwiTWFuZGFsYSAzRCAtIE1vdGlmcyBTYWNyw6lzXCIsIGFuYWx5c2lzKVxuICAgIGxheW91dC5zY2VuZS5jYW1lcmEgPSB7IGV5ZTogeyB4OiAwLCB5OiAwLCB6OiAyLjUgfSB9XG4gICAgd2luZG93LlBsb3RseS5uZXdQbG90KHBsb3RSZWYuY3VycmVudCwgcGxvdERhdGEsIGxheW91dCwgZ2V0UGxvdENvbmZpZygpKVxuICB9XG5cbiAgLy8gNS4gR0FMQVhJRSAzRCAtIFN0cnVjdHVyZSBiYXPDqWUgc3VyIGxlcyBkb25uw6llc1xuICBjb25zdCByZW5kZXJHYWxheHkzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgY29sb3JWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiY29sb3JCeVwiKVxuICAgIGNvbnN0IHNpemVWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwic2l6ZUJ5XCIpXG5cbiAgICBjb25zdCBnYWxheHlYID0gW11cbiAgICBjb25zdCBnYWxheHlZID0gW11cbiAgICBjb25zdCBnYWxheHlaID0gW11cbiAgICBjb25zdCBnYWxheHlDb2xvcnMgPSBbXVxuICAgIGNvbnN0IGdhbGF4eVNpemVzID0gW11cblxuICAgIC8vIEFuYWx5c2VyIGxhIGRpc3RyaWJ1dGlvbiBwb3VyIGNyw6llciBsZXMgYnJhcyBnYWxhY3RpcXVlc1xuICAgIGNvbnN0IGNvbG9yUmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcuY29sb3JCeV1cbiAgICBjb25zdCBzaXplUmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcuc2l6ZUJ5XVxuXG4gICAgZGF0YS5mb3JFYWNoKChyb3csIGkpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBpIC8gZGF0YS5sZW5ndGhcbiAgICAgIGNvbnN0IGNvbG9yVmFsID0gY29sb3JWYWx1ZXNbaV1cbiAgICAgIGNvbnN0IHNpemVWYWwgPSBzaXplVmFsdWVzW2ldXG5cbiAgICAgIC8vIFBvc2l0aW9uIGRhbnMgbGEgZ2FsYXhpZSBiYXPDqWUgc3VyIGxlcyB2YWxldXJzIGRlcyBkb25uw6llc1xuICAgICAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gY29sb3JSYW5nZSA/IChjb2xvclZhbCAtIGNvbG9yUmFuZ2UubWluKSAvIChjb2xvclJhbmdlLm1heCAtIGNvbG9yUmFuZ2UubWluKSA6IHRcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTaXplID0gc2l6ZVJhbmdlID8gKHNpemVWYWwgLSBzaXplUmFuZ2UubWluKSAvIChzaXplUmFuZ2UubWF4IC0gc2l6ZVJhbmdlLm1pbikgOiAwLjVcblxuICAgICAgLy8gQW5nbGUgZXQgcmF5b24gYmFzw6lzIHN1ciBsZXMgZG9ubsOpZXNcbiAgICAgIGNvbnN0IGFuZ2xlID0gbm9ybWFsaXplZENvbG9yICogNiAqIE1hdGguUEkgKyB0ICogMiAqIE1hdGguUElcbiAgICAgIGNvbnN0IHJhZGl1cyA9IG5vcm1hbGl6ZWRTaXplICogMyArIHQgKiAwLjVcbiAgICAgIGNvbnN0IGhlaWdodCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMiAqICgxIC0gdCkgLy8gUGx1cyBwbGF0IHZlcnMgbCdleHTDqXJpZXVyXG5cbiAgICAgIC8vIEJyYXMgcHJpbmNpcGFsXG4gICAgICBnYWxheHlYLnB1c2goTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzKVxuICAgICAgZ2FsYXh5WS5wdXNoKE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cylcbiAgICAgIGdhbGF4eVoucHVzaChoZWlnaHQpXG4gICAgICBnYWxheHlDb2xvcnMucHVzaChjb2xvclZhbClcbiAgICAgIGdhbGF4eVNpemVzLnB1c2goTWF0aC5tYXgoMiwgTWF0aC5taW4oMTIsICgxIC0gbm9ybWFsaXplZFNpemUpICogOCArIDMpKSlcblxuICAgICAgLy8gQnJhcyBzZWNvbmRhaXJlIHNpIGFzc2V6IGRlIGRvbm7DqWVzXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiAyMCkge1xuICAgICAgICBjb25zdCBhbmdsZTIgPSBhbmdsZSArIE1hdGguUEkgKiAwLjhcbiAgICAgICAgY29uc3QgcmFkaXVzMiA9IHJhZGl1cyAqIDAuN1xuICAgICAgICBnYWxheHlYLnB1c2goTWF0aC5jb3MoYW5nbGUyKSAqIHJhZGl1czIpXG4gICAgICAgIGdhbGF4eVkucHVzaChNYXRoLnNpbihhbmdsZTIpICogcmFkaXVzMilcbiAgICAgICAgZ2FsYXh5Wi5wdXNoKGhlaWdodCAqIDAuNSlcbiAgICAgICAgZ2FsYXh5Q29sb3JzLnB1c2goY29sb3JWYWwgKiAwLjgpXG4gICAgICAgIGdhbGF4eVNpemVzLnB1c2goTWF0aC5tYXgoMSwgZ2FsYXh5U2l6ZXNbZ2FsYXh5U2l6ZXMubGVuZ3RoIC0gMV0gKiAwLjcpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBwbG90RGF0YSA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzY2F0dGVyM2RcIixcbiAgICAgICAgbW9kZTogXCJtYXJrZXJzXCIsXG4gICAgICAgIHg6IGdhbGF4eVgsXG4gICAgICAgIHk6IGdhbGF4eVksXG4gICAgICAgIHo6IGdhbGF4eVosXG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgIHNpemU6IGdhbGF4eVNpemVzLFxuICAgICAgICAgIGNvbG9yOiBnYWxheHlDb2xvcnMsXG4gICAgICAgICAgY29sb3JzY2FsZTogXCJWaXJpZGlzXCIsXG4gICAgICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgICAgIGNvbG9yYmFyOiB7XG4gICAgICAgICAgICB0aXRsZTogYEx1bWlub3NpdMOpICgke2FuYWx5c2lzLm1hcHBpbmcuY29sb3JCeX0pYCxcbiAgICAgICAgICAgIHRpdGxlZm9udDogeyBzaXplOiAxMCB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6IGBHYWxheGllIDNEIC0gJHtkYXRhLmxlbmd0aH0gw6l0b2lsZXNgLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVEeW5hbWljTGF5b3V0KFwiR2FsYXhpZSAzRCAtIFNwaXJhbGUgQ29zbWlxdWVcIiwgYW5hbHlzaXMpXG4gICAgbGF5b3V0LnNjZW5lLmJnY29sb3IgPSBcInJnYmEoMCwgMCwgMjAsIDAuOSlcIlxuICAgIGxheW91dC5zY2VuZS5jYW1lcmEgPSB7IGV5ZTogeyB4OiAxLjUsIHk6IDEuNSwgejogMSB9IH1cbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICAvLyA2LiBUSU1FTElORSAzRCAtIFBvdXIgZG9ubsOpZXMgdGVtcG9yZWxsZXNcbiAgY29uc3QgcmVuZGVyVGltZWxpbmUzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgLy8gQ2hlcmNoZXIgdW5lIGNvbG9ubmUgdGVtcG9yZWxsZVxuICAgIGNvbnN0IHRpbWVDb2x1bW4gPSBhbmFseXNpcy50ZW1wb3JhbENvbHVtbnNbMF0gfHwgYW5hbHlzaXMubWFwcGluZy54QXhpc1xuICAgIGNvbnN0IHZhbHVlQ29sdW1uID0gYW5hbHlzaXMubWFwcGluZy55QXhpc1xuICAgIGNvbnN0IGNvbG9yQ29sdW1uID0gYW5hbHlzaXMubWFwcGluZy5jb2xvckJ5XG5cbiAgICBjb25zdCB0aW1lVmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInhBeGlzXCIpXG4gICAgY29uc3QgdmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInlBeGlzXCIpXG4gICAgY29uc3QgY29sb3JWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiY29sb3JCeVwiKVxuXG4gICAgLy8gVHJpZXIgcGFyIHRlbXBzIHNpIGMnZXN0IHRlbXBvcmVsXG4gICAgY29uc3Qgc29ydGVkSW5kaWNlcyA9IHRpbWVWYWx1ZXMubWFwKChfLCBpKSA9PiBpKS5zb3J0KChhLCBiKSA9PiB0aW1lVmFsdWVzW2FdIC0gdGltZVZhbHVlc1tiXSlcblxuICAgIGNvbnN0IHRpbWVsaW5lWCA9IHNvcnRlZEluZGljZXMubWFwKChpKSA9PiB0aW1lVmFsdWVzW2ldKVxuICAgIGNvbnN0IHRpbWVsaW5lWSA9IHNvcnRlZEluZGljZXMubWFwKChpKSA9PiB2YWx1ZXNbaV0pXG4gICAgY29uc3QgdGltZWxpbmVaID0gc29ydGVkSW5kaWNlcy5tYXAoKF8sIGkpID0+IGkgKiAwLjEpIC8vIMOJbMOpdmF0aW9uIHByb2dyZXNzaXZlXG4gICAgY29uc3QgdGltZWxpbmVDb2xvcnMgPSBzb3J0ZWRJbmRpY2VzLm1hcCgoaSkgPT4gY29sb3JWYWx1ZXNbaV0pXG5cbiAgICBjb25zdCBwbG90RGF0YSA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzY2F0dGVyM2RcIixcbiAgICAgICAgbW9kZTogXCJtYXJrZXJzK2xpbmVzXCIsXG4gICAgICAgIHg6IHRpbWVsaW5lWCxcbiAgICAgICAgeTogdGltZWxpbmVZLFxuICAgICAgICB6OiB0aW1lbGluZVosXG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgIHNpemU6IDYsXG4gICAgICAgICAgY29sb3I6IHRpbWVsaW5lQ29sb3JzLFxuICAgICAgICAgIGNvbG9yc2NhbGU6IFwiVmlyaWRpc1wiLFxuICAgICAgICAgIG9wYWNpdHk6IDAuOCxcbiAgICAgICAgICBjb2xvcmJhcjoge1xuICAgICAgICAgICAgdGl0bGU6IGFuYWx5c2lzLm1hcHBpbmcuY29sb3JCeSxcbiAgICAgICAgICAgIHRpdGxlZm9udDogeyBzaXplOiAxMCB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBjb2xvcjogXCJyZ2JhKDEwMCwgMTAwLCAxMDAsIDAuNilcIixcbiAgICAgICAgICB3aWR0aDogMyxcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogc29ydGVkSW5kaWNlcy5tYXAoKGkpID0+IHtcbiAgICAgICAgICBjb25zdCByb3cgPSBkYXRhW2ldXG4gICAgICAgICAgbGV0IHRvb2x0aXAgPSBgPGI+UG9pbnQgdGVtcG9yZWwgJHtpICsgMX08L2I+PGJyPmBcbiAgICAgICAgICB0b29sdGlwICs9IGA8Yj5UZW1wczo8L2I+ICR7cm93W3RpbWVDb2x1bW5dIHx8IFwiTi9BXCJ9PGJyPmBcbiAgICAgICAgICB0b29sdGlwICs9IGA8Yj5WYWxldXI6PC9iPiAke3Jvd1t2YWx1ZUNvbHVtbl0gfHwgXCJOL0FcIn08YnI+YFxuICAgICAgICAgIHJldHVybiB0b29sdGlwXG4gICAgICAgIH0pLFxuICAgICAgICBob3ZlcnRlbXBsYXRlOiBcIiV7dGV4dH08ZXh0cmE+PC9leHRyYT5cIixcbiAgICAgICAgbmFtZTogYFRpbWVsaW5lIDNEIC0gJHtkYXRhLmxlbmd0aH0gcG9pbnRzYCxcbiAgICAgIH0sXG4gICAgXVxuXG4gICAgY29uc3QgbGF5b3V0ID0gY3JlYXRlRHluYW1pY0xheW91dChcIlRpbWVsaW5lIDNEIC0gw4l2b2x1dGlvbiBUZW1wb3JlbGxlXCIsIGFuYWx5c2lzKVxuICAgIHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90UmVmLmN1cnJlbnQsIHBsb3REYXRhLCBsYXlvdXQsIGdldFBsb3RDb25maWcoKSlcbiAgfVxuXG4gIC8vIEZvbmN0aW9ucyBkZSByZW5kdSBzaW1wbGlmacOpZXMgcG91ciBsZXMgYXV0cmVzIG1vZMOobGVzXG4gIGNvbnN0IHJlbmRlckFuaW1hdGVkU2NhdHRlciA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyQ2x1c3RlcmVkU2NhdHRlciA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJCdWJibGVTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJDbGFzc2ljU3VyZmFjZSA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDb250b3VyU3VyZmFjZShhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyTWVzaFN1cmZhY2UgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ29udG91clN1cmZhY2UoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckdyYWRpZW50U3VyZmFjZSA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDb250b3VyU3VyZmFjZShhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyQ2xhc3NpY0JhcnMgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQnViYmxlU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyR3JvdXBlZEJhcnMgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQnViYmxlU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyQ3lsaW5kcmljYWxCYXJzID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckJ1YmJsZVNjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlclB5cmFtaWRCYXJzID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckJ1YmJsZVNjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlclNwaGVyZVBhY2sgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQnViYmxlU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyQ3ViZU1hdHJpeCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyQ29uZUZpZWxkID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJIZWxpeFNwaXJhbCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJETkFIZWxpeChhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyRnJhY3RhbDNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlck1hbmRhbGEzRChhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyQ3J5c3RhbDNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJOZXR3b3JrM0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlclRyZWUzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyV2F2ZVRlbXBvcmFsID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlclRpbWVsaW5lM0QoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlclNwaXJhbFRpbWUgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyVGltZWxpbmUzRChhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyR2xvYmUzRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyVGVycmFpbjNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNvbnRvdXJTdXJmYWNlKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJNb2xlY3VsZTNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJWZWN0b3JGaWVsZCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVySGlzdG9ncmFtM0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQnViYmxlU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyQm94UGxvdDNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckJ1YmJsZVNjYXR0ZXIoYW5hbHlzaXMpXG5cbiAgLy8gNy4gU1VSRkFDRSBBVkVDIENPTlRPVVJTIC0gQmFzw6llIHN1ciBsZXMgdnJhaWVzIGRvbm7DqWVzXG4gIGNvbnN0IHJlbmRlckNvbnRvdXJTdXJmYWNlID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICBjb25zdCB4VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInhBeGlzXCIpXG4gICAgY29uc3QgeVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ5QXhpc1wiKVxuICAgIGNvbnN0IHpWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiekF4aXNcIilcblxuICAgIGNvbnN0IHhSYW5nZSA9IGFuYWx5c2lzLmRhdGFSYW5nZXNbYW5hbHlzaXMubWFwcGluZy54QXhpc11cbiAgICBjb25zdCB5UmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcueUF4aXNdXG5cbiAgICBpZiAoIXhSYW5nZSB8fCAheVJhbmdlKSB7XG4gICAgICByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEFkYXB0ZXIgbGEgcsOpc29sdXRpb24gc2Vsb24gbGEgZGVuc2l0w6kgZGVzIGRvbm7DqWVzXG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKDMwLCBNYXRoLm1heCgxNSwgTWF0aC5zcXJ0KGRhdGEubGVuZ3RoKSkpXG4gICAgY29uc3QgeE1pbiA9IHhSYW5nZS5taW5cbiAgICBjb25zdCB4TWF4ID0geFJhbmdlLm1heFxuICAgIGNvbnN0IHlNaW4gPSB5UmFuZ2UubWluXG4gICAgY29uc3QgeU1heCA9IHlSYW5nZS5tYXhcblxuICAgIGNvbnN0IHhHcmlkID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogc2l6ZSB9LCAoXywgaSkgPT4geE1pbiArIChpIC8gKHNpemUgLSAxKSkgKiAoeE1heCAtIHhNaW4pKVxuICAgIGNvbnN0IHlHcmlkID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogc2l6ZSB9LCAoXywgaSkgPT4geU1pbiArIChpIC8gKHNpemUgLSAxKSkgKiAoeU1heCAtIHlNaW4pKVxuXG4gICAgY29uc3Qgc3VyZmFjZSA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IFtdXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNpemU7IGorKykge1xuICAgICAgICBjb25zdCB0YXJnZXRYID0geEdyaWRbal1cbiAgICAgICAgY29uc3QgdGFyZ2V0WSA9IHlHcmlkW2ldXG5cbiAgICAgICAgLy8gSW50ZXJwb2xhdGlvbiBwb25kw6lyw6llIHBhciBsYSBkaXN0YW5jZVxuICAgICAgICBsZXQgd2VpZ2h0ZWRTdW0gPSAwXG4gICAgICAgIGxldCB0b3RhbFdlaWdodCA9IDBcbiAgICAgICAgY29uc3QgbWF4RGlzdGFuY2UgPSBNYXRoLnNxcnQoKHhNYXggLSB4TWluKSAqKiAyICsgKHlNYXggLSB5TWluKSAqKiAyKSAvIDVcblxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRhdGEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBkeCA9IHhWYWx1ZXNba10gLSB0YXJnZXRYXG4gICAgICAgICAgY29uc3QgZHkgPSB5VmFsdWVzW2tdIC0gdGFyZ2V0WVxuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IE1hdGguZXhwKC0oZGlzdGFuY2UgKiBkaXN0YW5jZSkgLyAobWF4RGlzdGFuY2UgKiBtYXhEaXN0YW5jZSkpXG4gICAgICAgICAgICB3ZWlnaHRlZFN1bSArPSB6VmFsdWVzW2tdICogd2VpZ2h0XG4gICAgICAgICAgICB0b3RhbFdlaWdodCArPSB3ZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByb3cucHVzaCh0b3RhbFdlaWdodCA+IDAgPyB3ZWlnaHRlZFN1bSAvIHRvdGFsV2VpZ2h0IDogMClcbiAgICAgIH1cbiAgICAgIHN1cmZhY2UucHVzaChyb3cpXG4gICAgfVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic3VyZmFjZVwiLFxuICAgICAgICB6OiBzdXJmYWNlLFxuICAgICAgICB4OiB4R3JpZCxcbiAgICAgICAgeTogeUdyaWQsXG4gICAgICAgIGNvbG9yc2NhbGU6IFwiRWFydGhcIixcbiAgICAgICAgY29udG91cnM6IHtcbiAgICAgICAgICB6OiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgdXNlY29sb3JtYXA6IHRydWUsXG4gICAgICAgICAgICBoaWdobGlnaHRjb2xvcjogXCIjNDJmNDYyXCIsXG4gICAgICAgICAgICBwcm9qZWN0OiB7IHo6IHRydWUgfSxcbiAgICAgICAgICAgIHdpZHRoOiAyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yYmFyOiB7XG4gICAgICAgICAgdGl0bGU6IGFuYWx5c2lzLm1hcHBpbmcuekF4aXMsXG4gICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6IGBTdXJmYWNlIC0gJHtkYXRhLmxlbmd0aH0gcG9pbnRzIHNvdXJjZWAsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZUR5bmFtaWNMYXlvdXQoXCJTdXJmYWNlIDNEIC0gTGlnbmVzIGRlIE5pdmVhdVwiLCBhbmFseXNpcylcbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICAvLyA4LiBIw4lMSUNFIEFETiAtIEJhc8OpZSBzdXIgbGVzIHPDqXF1ZW5jZXMgZGUgZG9ubsOpZXNcbiAgY29uc3QgcmVuZGVyRE5BSGVsaXggPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4ge1xuICAgIGNvbnN0IGNvbG9yVmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcImNvbG9yQnlcIilcbiAgICBjb25zdCBzaXplVmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInNpemVCeVwiKVxuXG4gICAgY29uc3QgZG5hWDEgPSBbXVxuICAgIGNvbnN0IGRuYVkxID0gW11cbiAgICBjb25zdCBkbmFaMSA9IFtdXG4gICAgY29uc3QgZG5hWDIgPSBbXVxuICAgIGNvbnN0IGRuYVkyID0gW11cbiAgICBjb25zdCBkbmFaMiA9IFtdXG4gICAgY29uc3QgZG5hQ29sb3JzID0gW11cbiAgICBjb25zdCBkbmFTaXplcyA9IFtdXG5cbiAgICAvLyBVdGlsaXNlciBsZXMgdnJhaWVzIGRvbm7DqWVzIHBvdXIgbW9kdWxlciBsJ2jDqWxpY2VcbiAgICBjb25zdCBjb2xvclJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLmNvbG9yQnldXG4gICAgY29uc3Qgc2l6ZVJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLnNpemVCeV1cblxuICAgIGRhdGEuZm9yRWFjaCgocm93LCBpKSA9PiB7XG4gICAgICBjb25zdCB0ID0gKGkgLyBkYXRhLmxlbmd0aCkgKiA4ICogTWF0aC5QSVxuICAgICAgY29uc3QgeiA9IChpIC8gZGF0YS5sZW5ndGgpICogNFxuXG4gICAgICAvLyBNb2R1bGF0aW9uIGJhc8OpZSBzdXIgbGVzIGRvbm7DqWVzXG4gICAgICBjb25zdCBjb2xvclZhbCA9IGNvbG9yVmFsdWVzW2ldXG4gICAgICBjb25zdCBzaXplVmFsID0gc2l6ZVZhbHVlc1tpXVxuXG4gICAgICBjb25zdCByYWRpdXNNb2R1bGF0aW9uID0gY29sb3JSYW5nZVxuICAgICAgICA/IDEgKyAoMC4zICogKGNvbG9yVmFsIC0gY29sb3JSYW5nZS5taW4pKSAvIChjb2xvclJhbmdlLm1heCAtIGNvbG9yUmFuZ2UubWluKVxuICAgICAgICA6IDFcbiAgICAgIGNvbnN0IGhlaWdodE1vZHVsYXRpb24gPSBzaXplUmFuZ2UgPyAoMC4xICogKHNpemVWYWwgLSBzaXplUmFuZ2UubWluKSkgLyAoc2l6ZVJhbmdlLm1heCAtIHNpemVSYW5nZS5taW4pIDogMFxuXG4gICAgICAvLyBQcmVtaWVyIGJyaW5cbiAgICAgIGRuYVgxLnB1c2goTWF0aC5jb3ModCkgKiByYWRpdXNNb2R1bGF0aW9uKVxuICAgICAgZG5hWTEucHVzaChNYXRoLnNpbih0KSAqIHJhZGl1c01vZHVsYXRpb24pXG4gICAgICBkbmFaMS5wdXNoKHogKyBoZWlnaHRNb2R1bGF0aW9uKVxuXG4gICAgICAvLyBEZXV4acOobWUgYnJpbiAoZMOpY2Fsw6kgZGUgz4ApXG4gICAgICBkbmFYMi5wdXNoKE1hdGguY29zKHQgKyBNYXRoLlBJKSAqIHJhZGl1c01vZHVsYXRpb24pXG4gICAgICBkbmFZMi5wdXNoKE1hdGguc2luKHQgKyBNYXRoLlBJKSAqIHJhZGl1c01vZHVsYXRpb24pXG4gICAgICBkbmFaMi5wdXNoKHogKyBoZWlnaHRNb2R1bGF0aW9uKVxuXG4gICAgICBkbmFDb2xvcnMucHVzaChjb2xvclZhbClcbiAgICAgIGRuYVNpemVzLnB1c2goTWF0aC5tYXgoNCwgTWF0aC5taW4oMTAsIChzaXplVmFsIC8gKHNpemVSYW5nZT8ubWF4IHx8IDEpKSAqIDYgKyA0KSkpXG4gICAgfSlcblxuICAgIGNvbnN0IHBsb3REYXRhID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnMrbGluZXNcIixcbiAgICAgICAgeDogZG5hWDEsXG4gICAgICAgIHk6IGRuYVkxLFxuICAgICAgICB6OiBkbmFaMSxcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgc2l6ZTogZG5hU2l6ZXMsXG4gICAgICAgICAgY29sb3I6IGRuYUNvbG9ycyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlJkWWxCdVwiLFxuICAgICAgICAgIGNvbG9yYmFyOiB7XG4gICAgICAgICAgICB0aXRsZTogYW5hbHlzaXMubWFwcGluZy5jb2xvckJ5LFxuICAgICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbGluZTogeyBjb2xvcjogXCJyZ2JhKDI1NSwgMTAwLCAxMDAsIDAuOClcIiwgd2lkdGg6IDQgfSxcbiAgICAgICAgbmFtZTogYEJyaW4gQUROIDEgLSAke2RhdGEubGVuZ3RofSBiYXNlc2AsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnMrbGluZXNcIixcbiAgICAgICAgeDogZG5hWDIsXG4gICAgICAgIHk6IGRuYVkyLFxuICAgICAgICB6OiBkbmFaMixcbiAgICAgICAgbWFya2VyOiB7IHNpemU6IGRuYVNpemVzLCBjb2xvcjogZG5hQ29sb3JzLCBjb2xvcnNjYWxlOiBcIlJkWWxCdVwiIH0sXG4gICAgICAgIGxpbmU6IHsgY29sb3I6IFwicmdiYSgxMDAsIDEwMCwgMjU1LCAwLjgpXCIsIHdpZHRoOiA0IH0sXG4gICAgICAgIG5hbWU6IGBCcmluIEFETiAyIC0gJHtkYXRhLmxlbmd0aH0gYmFzZXNgLFxuICAgICAgICBzaG93bGVnZW5kOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgXVxuXG4gICAgY29uc3QgbGF5b3V0ID0gY3JlYXRlRHluYW1pY0xheW91dChcIkRvdWJsZSBIw6lsaWNlIEFETlwiLCBhbmFseXNpcylcbiAgICBsYXlvdXQuc2NlbmUuY2FtZXJhID0geyBleWU6IHsgeDogMiwgeTogMCwgejogMSB9IH1cbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICAvLyBGb25jdGlvbiBwb3VyIGNyw6llciB1biBsYXlvdXQgZHluYW1pcXVlIGJhc8OpIHN1ciBsJ2FuYWx5c2VcbiAgY29uc3QgY3JlYXRlRHluYW1pY0xheW91dCA9ICh0aXRsZTogc3RyaW5nLCBhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgZGF0YUluZm8gPSBgJHtkYXRhLmxlbmd0aH0gZW50csOpZXMg4oCiICR7YW5hbHlzaXMubnVtZXJpY0NvbHVtbnMubGVuZ3RofSBudW0uIOKAoiAke2FuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1ucy5sZW5ndGh9IGNhdC5gXG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NlbmU6IHtcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgdGV4dDogYCR7YW5hbHlzaXMubWFwcGluZy54QXhpc30gJHthbmFseXNpcy5kYXRhVHlwZXNbYW5hbHlzaXMubWFwcGluZy54QXhpc10gPyBgKCR7YW5hbHlzaXMuZGF0YVR5cGVzW2FuYWx5c2lzLm1hcHBpbmcueEF4aXNdfSlgIDogXCJcIn1gLFxuICAgICAgICAgICAgZm9udDogeyBzaXplOiAxMiwgY29sb3I6IFwiI2VhNTgwY1wiIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaG93YmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICBiYWNrZ3JvdW5kY29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjQwLCAwLjgpXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIHRleHQ6IGAke2FuYWx5c2lzLm1hcHBpbmcueUF4aXN9ICR7YW5hbHlzaXMuZGF0YVR5cGVzW2FuYWx5c2lzLm1hcHBpbmcueUF4aXNdID8gYCgke2FuYWx5c2lzLmRhdGFUeXBlc1thbmFseXNpcy5tYXBwaW5nLnlBeGlzXX0pYCA6IFwiXCJ9YCxcbiAgICAgICAgICAgIGZvbnQ6IHsgc2l6ZTogMTIsIGNvbG9yOiBcIiNlYTU4MGNcIiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2hvd2JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgYmFja2dyb3VuZGNvbG9yOiBcInJnYmEoMjQwLCAyNDAsIDI0MCwgMC44KVwiLFxuICAgICAgICB9LFxuICAgICAgICB6YXhpczoge1xuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0ZXh0OiBgJHthbmFseXNpcy5tYXBwaW5nLnpBeGlzfSAke2FuYWx5c2lzLmRhdGFUeXBlc1thbmFseXNpcy5tYXBwaW5nLnpBeGlzXSA/IGAoJHthbmFseXNpcy5kYXRhVHlwZXNbYW5hbHlzaXMubWFwcGluZy56QXhpc119KWAgOiBcIlwifWAsXG4gICAgICAgICAgICBmb250OiB7IHNpemU6IDEyLCBjb2xvcjogXCIjZWE1ODBjXCIgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNob3diYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgIGJhY2tncm91bmRjb2xvcjogXCJyZ2JhKDI0MCwgMjQwLCAyNDAsIDAuOClcIixcbiAgICAgICAgfSxcbiAgICAgICAgY2FtZXJhOiB7IGV5ZTogeyB4OiAxLjI1LCB5OiAxLjI1LCB6OiAxLjI1IH0gfSxcbiAgICAgIH0sXG4gICAgICB0aXRsZTogeyB0ZXh0OiB0aXRsZSwgZm9udDogeyBzaXplOiAxOCwgY29sb3I6IFwiI2VhNTgwY1wiIH0gfSxcbiAgICAgIHBhcGVyX2JnY29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgbWFyZ2luOiB7IGw6IDAsIHI6IDAsIHQ6IDYwLCBiOiAwIH0sXG4gICAgICBhbm5vdGF0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgdGV4dDogYDxiPk1vZMOobGU6PC9iPiAke3RpdGxlfTxicj48Yj5Eb25uw6llczo8L2I+ICR7ZGF0YUluZm99PGJyPjxiPk1hcHBpbmc6PC9iPjxicj7igKIgWDogJHthbmFseXNpcy5tYXBwaW5nLnhBeGlzfTxicj7igKIgWTogJHthbmFseXNpcy5tYXBwaW5nLnlBeGlzfTxicj7igKIgWjogJHthbmFseXNpcy5tYXBwaW5nLnpBeGlzfTxicj7igKIgQ291bGV1cjogJHthbmFseXNpcy5tYXBwaW5nLmNvbG9yQnl9PGJyPuKAoiBUYWlsbGU6ICR7YW5hbHlzaXMubWFwcGluZy5zaXplQnl9JHthbmFseXNpcy5tYXBwaW5nLmNhdGVnb3J5QnkgPyBgPGJyPuKAoiBDYXTDqWdvcmllOiAke2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeX1gIDogXCJcIn1gLFxuICAgICAgICAgIHNob3dhcnJvdzogZmFsc2UsXG4gICAgICAgICAgeHJlZjogXCJwYXBlclwiLFxuICAgICAgICAgIHlyZWY6IFwicGFwZXJcIixcbiAgICAgICAgICB4OiAtMC4xNSxcbiAgICAgICAgICB5OiAwLjk1LFxuICAgICAgICAgIHhhbmNob3I6IFwibGVmdFwiLFxuICAgICAgICAgIHlhbmNob3I6IFwidG9wXCIsXG4gICAgICAgICAgYmdjb2xvcjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOClcIixcbiAgICAgICAgICBib3JkZXJjb2xvcjogXCJyZ2JhKDIzNCwgODgsIDEyLCAwLjMpXCIsXG4gICAgICAgICAgYm9yZGVyd2lkdGg6IDEsXG4gICAgICAgICAgZm9udDogeyBzaXplOiA4LCBjb2xvcjogXCIjNjY2XCIgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZ2V0UGxvdENvbmZpZyA9ICgpID0+ICh7XG4gICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICBkaXNwbGF5TW9kZUJhcjogZmFsc2UsXG4gICAgc3RhdGljUGxvdDogZmFsc2UsXG4gICAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgICBkb3VibGVDbGljazogXCJyZXNldFwiLFxuICB9KVxuXG4gIGNvbnN0IHJlbmRlclYwVmlzdWFsaXphdGlvbiA9IChjb25maWc6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBjb25maWcuY29uZmlnLmRhdGEsIGNvbmZpZy5jb25maWcubGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJldXIgcmVuZHUgdjA6XCIsIGVycm9yKVxuICAgICAgcmVuZGVyTW9kZWxTcGVjaWZpY1Zpc3VhbGl6YXRpb24oKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlbmRlckRlbW9WaXN1YWxpemF0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IGRlbW9EYXRhID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNTAgfSwgKF8sIGkpID0+ICh7XG4gICAgICB4OiBNYXRoLnJhbmRvbSgpICogMTAsXG4gICAgICB5OiBNYXRoLnJhbmRvbSgpICogMTAsXG4gICAgICB6OiBNYXRoLnJhbmRvbSgpICogMTAsXG4gICAgICB2YWx1ZTogTWF0aC5yYW5kb20oKSAqIDEwMCxcbiAgICAgIGNhdGVnb3J5OiBgQ2F0JHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1KSArIDF9YCxcbiAgICB9KSlcblxuICAgIHNldERhdGFNYXBwaW5nKHtcbiAgICAgIHhBeGlzOiBcIkRpbWVuc2lvbiBYXCIsXG4gICAgICB5QXhpczogXCJEaW1lbnNpb24gWVwiLFxuICAgICAgekF4aXM6IFwiRGltZW5zaW9uIFpcIixcbiAgICAgIGNvbG9yQnk6IFwiVmFsZXVyXCIsXG4gICAgICBzaXplQnk6IFwiVmFsZXVyXCIsXG4gICAgfSlcblxuICAgIGNvbnN0IHBsb3REYXRhID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnNcIixcbiAgICAgICAgeDogZGVtb0RhdGEubWFwKChkKSA9PiBkLngpLFxuICAgICAgICB5OiBkZW1vRGF0YS5tYXAoKGQpID0+IGQueSksXG4gICAgICAgIHo6IGRlbW9EYXRhLm1hcCgoZCkgPT4gZC56KSxcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgc2l6ZTogOCxcbiAgICAgICAgICBjb2xvcjogZGVtb0RhdGEubWFwKChkKSA9PiBkLnZhbHVlKSxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlJhaW5ib3dcIixcbiAgICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6IFwiRMOpbW9uc3RyYXRpb25cIixcbiAgICAgIH0sXG4gICAgXVxuXG4gICAgY29uc3QgbGF5b3V0ID0ge1xuICAgICAgc2NlbmU6IHtcbiAgICAgICAgeGF4aXM6IHsgdGl0bGU6IFwiRGltZW5zaW9uIFhcIiwgc2hvd2JhY2tncm91bmQ6IHRydWUsIGJhY2tncm91bmRjb2xvcjogXCJyZ2JhKDI0MCwgMjQwLCAyNDAsIDAuOClcIiB9LFxuICAgICAgICB5YXhpczogeyB0aXRsZTogXCJEaW1lbnNpb24gWVwiLCBzaG93YmFja2dyb3VuZDogdHJ1ZSwgYmFja2dyb3VuZGNvbG9yOiBcInJnYmEoMjQwLCAyNDAsIDI0MCwgMC44KVwiIH0sXG4gICAgICAgIHpheGlzOiB7IHRpdGxlOiBcIkRpbWVuc2lvbiBaXCIsIHNob3diYWNrZ3JvdW5kOiB0cnVlLCBiYWNrZ3JvdW5kY29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjQwLCAwLjgpXCIgfSxcbiAgICAgICAgY2FtZXJhOiB7IGV5ZTogeyB4OiAxLjI1LCB5OiAxLjI1LCB6OiAxLjI1IH0gfSxcbiAgICAgIH0sXG4gICAgICB0aXRsZTogeyB0ZXh0OiBgRMOpbW9uc3RyYXRpb24gLSAke2dldE1vZGVsTmFtZSh2aXN1YWxpemF0aW9uVHlwZSl9YCwgZm9udDogeyBzaXplOiAxOCwgY29sb3I6IFwiI2VhNTgwY1wiIH0gfSxcbiAgICAgIHBhcGVyX2JnY29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgbWFyZ2luOiB7IGw6IDAsIHI6IDAsIHQ6IDYwLCBiOiAwIH0sXG4gICAgfVxuXG4gICAgd2luZG93LlBsb3RseS5uZXdQbG90KHBsb3RSZWYuY3VycmVudCwgcGxvdERhdGEsIGxheW91dCwgZ2V0UGxvdENvbmZpZygpKVxuICB9XG5cbiAgY29uc3QgZ2V0TW9kZWxOYW1lID0gKG1vZGVsSWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IG5hbWVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgICAgc2NhdHRlcjNkOiBcIk51YWdlIDNEIENsYXNzaXF1ZVwiLFxuICAgICAgc2NhdHRlcl9kZW5zaXR5OiBcIkRlbnNpdMOpIDNEXCIsXG4gICAgICBzY2F0dGVyX2J1YmJsZTogXCJCdWxsZXMgM0RcIixcbiAgICAgIG1hbmRhbGFfM2Q6IFwiTWFuZGFsYSAzRFwiLFxuICAgICAgZ2FsYXh5XzNkOiBcIkdhbGF4aWUgM0RcIixcbiAgICAgIHN1cmZhY2VfY29udG91cjogXCJTdXJmYWNlIENvbnRvdXJzXCIsXG4gICAgICBkbmFfaGVsaXg6IFwiSMOpbGljZSBBRE5cIixcbiAgICAgIHRpbWVsaW5lXzNkOiBcIlRpbWVsaW5lIDNEXCIsXG4gICAgfVxuICAgIHJldHVybiBuYW1lc1ttb2RlbElkXSB8fCBcIlZpc3VhbGlzYXRpb24gM0RcIlxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImgtZnVsbCBiZy1ncmFkaWVudC10by1iciBmcm9tLW9yYW5nZS01MCB0by13aGl0ZSByb3VuZGVkLXhsIGJvcmRlci0yIGJvcmRlci1vcmFuZ2UtMjAwIG92ZXJmbG93LWhpZGRlblwiPlxuICAgICAgey8qIEhlYWRlciAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC02IGJvcmRlci1iIGJvcmRlci1vcmFuZ2UtMjAwIGJnLXdoaXRlXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTNcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy0xMiBoLTEyIGJnLWdyYWRpZW50LXRvLWJyIGZyb20tb3JhbmdlLTYwMCB0by1vcmFuZ2UtNTAwIHJvdW5kZWQteGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgPFRyZW5kaW5nVXAgY2xhc3NOYW1lPVwidy02IGgtNiB0ZXh0LXdoaXRlXCIgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ib2xkIHRleHQtZ3JheS04MDBcIj5DYW52YXMgSUEg4oCiIFZpc3VhbGlzYXRpb24gRHluYW1pcXVlPC9oMj5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNjAwXCI+XG4gICAgICAgICAgICAgICAge2RhdGEubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgPyBgJHtkYXRhLmxlbmd0aH0gw6ljaGFudGlsbG9ucyDigKIgJHtjb2x1bW5zLmxlbmd0aH0gdmFyaWFibGVzIOKAoiAke2dldE1vZGVsTmFtZShjdXJyZW50TW9kZWwpfWBcbiAgICAgICAgICAgICAgICAgIDogYE1vZGUgZMOpbW9uc3RyYXRpb24g4oCiICR7Z2V0TW9kZWxOYW1lKGN1cnJlbnRNb2RlbCl9YH1cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICB7ZGF0YUFuYWx5c2lzICYmIChcbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS01MDBcIj5cbiAgICAgICAgICAgICAgICAgIHtkYXRhQW5hbHlzaXMubnVtZXJpY0NvbHVtbnMubGVuZ3RofSBudW3DqXJpcXVlcyDigKIge2RhdGFBbmFseXNpcy5jYXRlZ29yaWNhbENvbHVtbnMubGVuZ3RofXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgIGNhdMOpZ29yaWVsbGVzIOKAoiB7ZGF0YUFuYWx5c2lzLnRlbXBvcmFsQ29sdW1ucy5sZW5ndGh9IHRlbXBvcmVsbGVzXG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxuICAgICAgICAgICAge2lzVjBHZW5lcmF0ZWQgJiYgKFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgcHgtMyBweS0xIHJvdW5kZWQtZnVsbCB0ZXh0LXhzIGZvbnQtbWVkaXVtIGJnLWJsdWUtMTAwIHRleHQtYmx1ZS04MDBcIj5cbiAgICAgICAgICAgICAgICA8Q29kZSBjbGFzc05hbWU9XCJ3LTMgaC0zIG1yLTFcIiAvPlxuICAgICAgICAgICAgICAgIEfDqW7DqXLDqSBwYXIgdjBcbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBweC0zIHB5LTEgcm91bmRlZC1mdWxsIHRleHQteHMgZm9udC1tZWRpdW0gYmctb3JhbmdlLTEwMCB0ZXh0LW9yYW5nZS04MDBcIj5cbiAgICAgICAgICAgICAgPFphcCBjbGFzc05hbWU9XCJ3LTMgaC0zIG1yLTFcIiAvPlxuICAgICAgICAgICAgICBQbG90bHkgdjIuMzVcbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBweC0zIHB5LTEgcm91bmRlZC1mdWxsIHRleHQteHMgZm9udC1tZWRpdW0gYmctZ3JlZW4tMTAwIHRleHQtZ3JlZW4tODAwXCI+XG4gICAgICAgICAgICAgIEFkYXB0YXRpZiBEeW5hbWlxdWVcbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIENhbnZhcyAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgaC1bY2FsYygxMDAlLTEyMHB4KV1cIj5cbiAgICAgICAgeyFwbG90bHlMb2FkZWQgPyAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBoLWZ1bGxcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTggaC04IGJvcmRlci0yIGJvcmRlci1vcmFuZ2UtNTAwIGJvcmRlci10LXRyYW5zcGFyZW50IHJvdW5kZWQtZnVsbCBhbmltYXRlLXNwaW4gbXgtYXV0byBtYi00XCI+PC9kaXY+XG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS02MDBcIj5DaGFyZ2VtZW50IGRlIFBsb3RseS5qcyB2Mi4zNS4uLjwvcD5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNTAwIG10LTJcIj5BbmFseXNlIGR5bmFtaXF1ZSBkZXMgZG9ubsOpZXMgZW4gY291cnMuLi48L3A+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8ZGl2IHJlZj17cGxvdFJlZn0gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiIC8+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiVHJlbmRpbmdVcCIsIlphcCIsIkNvZGUiLCJDYW52YXMzRFZpc3VhbGl6YXRpb24iLCJkYXRhIiwiY29sdW1ucyIsInZpc3VhbGl6YXRpb25UeXBlIiwiZ2VuZXJhdGVkQ29uZmlnIiwicGxvdFJlZiIsImlzVjBHZW5lcmF0ZWQiLCJzZXRJc1YwR2VuZXJhdGVkIiwicGxvdGx5TG9hZGVkIiwic2V0UGxvdGx5TG9hZGVkIiwiZGF0YU1hcHBpbmciLCJzZXREYXRhTWFwcGluZyIsImN1cnJlbnRNb2RlbCIsInNldEN1cnJlbnRNb2RlbCIsImRhdGFBbmFseXNpcyIsInNldERhdGFBbmFseXNpcyIsIndpbmRvdyIsIlBsb3RseSIsInNjcmlwdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJjb25zb2xlIiwiZXJyb3IiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJjdXJyZW50IiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJwdXJnZSIsInR5cGUiLCJsb2ciLCJyZW5kZXJWMFZpc3VhbGl6YXRpb24iLCJyZW5kZXJNb2RlbFNwZWNpZmljVmlzdWFsaXphdGlvbiIsImFuYWx5emVEYXRhSW50ZWxsaWdlbnRseSIsImFuYWx5c2lzIiwibWFwcGluZyIsIm51bWVyaWNDb2x1bW5zIiwiY2F0ZWdvcmljYWxDb2x1bW5zIiwidGVtcG9yYWxDb2x1bW5zIiwiZGF0YVJhbmdlcyIsImNhdGVnb3JpZXMiLCJkYXRhVHlwZXMiLCJmb3JFYWNoIiwiY29sIiwidmFsdWVzIiwibWFwIiwicm93IiwiZmlsdGVyIiwidmFsIiwibnVtZXJpY1ZhbHVlcyIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJpc05hTiIsImlzRmluaXRlIiwibnVtZXJpY1JhdGlvIiwiZGF0ZVZhbHVlcyIsImRhdGUiLCJEYXRlIiwiZ2V0VGltZSIsImdldEZ1bGxZZWFyIiwidGVtcG9yYWxSYXRpbyIsInVuaXF1ZVZhbHVlcyIsIlNldCIsInVuaXF1ZVJhdGlvIiwicHVzaCIsInRpbWVzdGFtcHMiLCJtaW4iLCJNYXRoIiwibWF4Iiwic2xpY2UiLCJhbGxOdW1lcmljQ29scyIsInhBeGlzIiwieUF4aXMiLCJ6QXhpcyIsImNvbG9yQnkiLCJzaXplQnkiLCJjYXRlZ29yeUJ5IiwicmVuZGVyRGVtb1Zpc3VhbGl6YXRpb24iLCJyZW5kZXJDbGFzc2ljU2NhdHRlciIsInJlbmRlckJ1YmJsZVNjYXR0ZXIiLCJyZW5kZXJBbmltYXRlZFNjYXR0ZXIiLCJyZW5kZXJDbHVzdGVyZWRTY2F0dGVyIiwicmVuZGVyRGVuc2l0eVNjYXR0ZXIiLCJyZW5kZXJDbGFzc2ljU3VyZmFjZSIsInJlbmRlckNvbnRvdXJTdXJmYWNlIiwicmVuZGVyTWVzaFN1cmZhY2UiLCJyZW5kZXJHcmFkaWVudFN1cmZhY2UiLCJyZW5kZXJDbGFzc2ljQmFycyIsInJlbmRlckdyb3VwZWRCYXJzIiwicmVuZGVyQ3lsaW5kcmljYWxCYXJzIiwicmVuZGVyUHlyYW1pZEJhcnMiLCJyZW5kZXJTcGhlcmVQYWNrIiwicmVuZGVyQ3ViZU1hdHJpeCIsInJlbmRlckNvbmVGaWVsZCIsInJlbmRlckhlbGl4U3BpcmFsIiwicmVuZGVyTWFuZGFsYTNEIiwicmVuZGVyRnJhY3RhbDNEIiwicmVuZGVyQ3J5c3RhbDNEIiwicmVuZGVyR2FsYXh5M0QiLCJyZW5kZXJETkFIZWxpeCIsInJlbmRlck5ldHdvcmszRCIsInJlbmRlclRyZWUzRCIsInJlbmRlclRpbWVsaW5lM0QiLCJyZW5kZXJXYXZlVGVtcG9yYWwiLCJyZW5kZXJTcGlyYWxUaW1lIiwicmVuZGVyR2xvYmUzRCIsInJlbmRlclRlcnJhaW4zRCIsInJlbmRlck1vbGVjdWxlM0QiLCJyZW5kZXJWZWN0b3JGaWVsZCIsInJlbmRlckhpc3RvZ3JhbTNEIiwicmVuZGVyQm94UGxvdDNEIiwiZ2V0VmFsdWVzRnJvbUFuYWx5c2lzIiwia2V5IiwiY29sdW1uIiwiXyIsImkiLCJpbmNsdWRlcyIsInJhbmdlIiwidGltZXN0YW1wIiwibnVtVmFsIiwiaW5kZXgiLCJpbmRleE9mIiwieFZhbHVlcyIsInlWYWx1ZXMiLCJ6VmFsdWVzIiwiY29sb3JWYWx1ZXMiLCJtYXJrZXJTaXplIiwic3FydCIsInBsb3REYXRhIiwibW9kZSIsIngiLCJ5IiwieiIsIm1hcmtlciIsInNpemUiLCJjb2xvciIsImNvbG9yc2NhbGUiLCJvcGFjaXR5IiwiY29sb3JiYXIiLCJ0aXRsZSIsInRpdGxlZm9udCIsInRleHQiLCJ0b29sdGlwIiwiaG92ZXJ0ZW1wbGF0ZSIsIm5hbWUiLCJsYXlvdXQiLCJjcmVhdGVEeW5hbWljTGF5b3V0IiwibmV3UGxvdCIsImdldFBsb3RDb25maWciLCJncmlkU2l6ZSIsInhSYW5nZSIsInlSYW5nZSIsInpSYW5nZSIsImRlbnNpdHlYIiwiZGVuc2l0eVkiLCJkZW5zaXR5WiIsImRlbnNpdHlDb2xvcnMiLCJkZW5zaXR5U2l6ZXMiLCJ4U3BhbiIsInlTcGFuIiwielNwYW4iLCJyYWRpdXMiLCJqIiwiayIsImRlbnNpdHkiLCJwIiwiZHgiLCJkeSIsImR6IiwiZGlzdGFuY2UiLCJleHAiLCJ0aHJlc2hvbGQiLCJ0b0ZpeGVkIiwic2l6ZVZhbHVlcyIsInNpemVSYW5nZSIsIm5vcm1hbGl6ZWRTaXplcyIsIm5vcm1hbGl6ZWQiLCJsaW5lIiwid2lkdGgiLCJtYW5kYWxhWCIsIm1hbmRhbGFZIiwibWFuZGFsYVoiLCJtYW5kYWxhQ29sb3JzIiwibWFuZGFsYVNpemVzIiwibm9ybWFsaXplZEluZGV4IiwiY29sb3JWYWwiLCJzaXplVmFsIiwiY29sb3JSYW5nZSIsInRvdXJzIiwiYW5nbGUiLCJQSSIsInNpbiIsImhlaWdodCIsImNvcyIsIm51bVBldGFscyIsInBldGFsQW5nbGUiLCJwZXRhbFJhZGl1cyIsInNjZW5lIiwiY2FtZXJhIiwiZXllIiwiZ2FsYXh5WCIsImdhbGF4eVkiLCJnYWxheHlaIiwiZ2FsYXh5Q29sb3JzIiwiZ2FsYXh5U2l6ZXMiLCJ0Iiwibm9ybWFsaXplZENvbG9yIiwibm9ybWFsaXplZFNpemUiLCJyYW5kb20iLCJhbmdsZTIiLCJyYWRpdXMyIiwiYmdjb2xvciIsInRpbWVDb2x1bW4iLCJ2YWx1ZUNvbHVtbiIsImNvbG9yQ29sdW1uIiwidGltZVZhbHVlcyIsInNvcnRlZEluZGljZXMiLCJzb3J0IiwiYSIsImIiLCJ0aW1lbGluZVgiLCJ0aW1lbGluZVkiLCJ0aW1lbGluZVoiLCJ0aW1lbGluZUNvbG9ycyIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJ4R3JpZCIsIkFycmF5IiwiZnJvbSIsInlHcmlkIiwic3VyZmFjZSIsInRhcmdldFgiLCJ0YXJnZXRZIiwid2VpZ2h0ZWRTdW0iLCJ0b3RhbFdlaWdodCIsIm1heERpc3RhbmNlIiwid2VpZ2h0IiwiY29udG91cnMiLCJzaG93IiwidXNlY29sb3JtYXAiLCJoaWdobGlnaHRjb2xvciIsInByb2plY3QiLCJkbmFYMSIsImRuYVkxIiwiZG5hWjEiLCJkbmFYMiIsImRuYVkyIiwiZG5hWjIiLCJkbmFDb2xvcnMiLCJkbmFTaXplcyIsInJhZGl1c01vZHVsYXRpb24iLCJoZWlnaHRNb2R1bGF0aW9uIiwic2hvd2xlZ2VuZCIsImRhdGFJbmZvIiwieGF4aXMiLCJmb250Iiwic2hvd2JhY2tncm91bmQiLCJiYWNrZ3JvdW5kY29sb3IiLCJ5YXhpcyIsInpheGlzIiwicGFwZXJfYmdjb2xvciIsIm1hcmdpbiIsImwiLCJyIiwiYW5ub3RhdGlvbnMiLCJzaG93YXJyb3ciLCJ4cmVmIiwieXJlZiIsInhhbmNob3IiLCJ5YW5jaG9yIiwiYm9yZGVyY29sb3IiLCJib3JkZXJ3aWR0aCIsInJlc3BvbnNpdmUiLCJkaXNwbGF5TW9kZUJhciIsInN0YXRpY1Bsb3QiLCJzY3JvbGxab29tIiwiZG91YmxlQ2xpY2siLCJjb25maWciLCJkZW1vRGF0YSIsInZhbHVlIiwiY2F0ZWdvcnkiLCJmbG9vciIsImQiLCJnZXRNb2RlbE5hbWUiLCJtb2RlbElkIiwibmFtZXMiLCJzY2F0dGVyM2QiLCJzY2F0dGVyX2RlbnNpdHkiLCJzY2F0dGVyX2J1YmJsZSIsIm1hbmRhbGFfM2QiLCJnYWxheHlfM2QiLCJzdXJmYWNlX2NvbnRvdXIiLCJkbmFfaGVsaXgiLCJ0aW1lbGluZV8zZCIsImRpdiIsImNsYXNzTmFtZSIsImgyIiwic3BhbiIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Canvas3DVisualization.tsx\n"));

/***/ })

});