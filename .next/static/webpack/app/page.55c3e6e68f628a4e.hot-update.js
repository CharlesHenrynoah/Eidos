"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Canvas3DVisualization.tsx":
/*!**********************************************!*\
  !*** ./components/Canvas3DVisualization.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Canvas3DVisualization; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.16_@opentelemetry+api@1.9.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.16_@opentelemetry+api@1.9.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=Code,TrendingUp,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/.pnpm/lucide-react@0.454.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/trending-up.js\");\n/* harmony import */ var _barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=Code,TrendingUp,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/.pnpm/lucide-react@0.454.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/code.js\");\n/* harmony import */ var _barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Code,TrendingUp,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/.pnpm/lucide-react@0.454.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/zap.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Canvas3DVisualization(param) {\n    let { data, columns, visualizationType, generatedConfig } = param;\n    _s();\n    const plotRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isV0Generated, setIsV0Generated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [plotlyLoaded, setPlotlyLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [dataMapping, setDataMapping] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentModel, setCurrentModel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"scatter3d\");\n    const [dataAnalysis, setDataAnalysis] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Charger Plotly.js\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if ( true && !window.Plotly) {\n            const script = document.createElement(\"script\");\n            script.src = \"https://cdn.plot.ly/plotly-2.35.2.min.js\";\n            script.onload = ()=>setPlotlyLoaded(true);\n            script.onerror = ()=>{\n                console.error(\"Erreur lors du chargement de Plotly.js\");\n                setPlotlyLoaded(false);\n            };\n            document.head.appendChild(script);\n        } else if (window.Plotly) {\n            setPlotlyLoaded(true);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!plotlyLoaded || !plotRef.current) return;\n        const updateVisualization = async ()=>{\n            const plotElement = plotRef.current;\n            if (!plotElement) return;\n            // Nettoyer le graphique précédent\n            if (plotElement.children.length > 0) {\n                window.Plotly.purge(plotElement);\n            }\n            setCurrentModel(visualizationType);\n            try {\n                if (generatedConfig) {\n                    await renderV0Visualization(generatedConfig);\n                    setIsV0Generated(true);\n                } else {\n                    await renderModelSpecificVisualization();\n                    setIsV0Generated(false);\n                }\n            } catch (error) {\n                console.error(\"Erreur lors de la mise \\xe0 jour de la visualisation:\", error);\n                // En cas d'erreur, on revient au nuage de points basique\n                renderClassicScatter(analyzeDataIntelligently() || {\n                    mapping: {\n                        xAxis: columns[0] || \"index\",\n                        yAxis: columns[1] || \"index\",\n                        zAxis: columns[2] || \"index\",\n                        colorBy: columns[0] || \"index\",\n                        sizeBy: columns[1] || \"index\"\n                    },\n                    numericColumns: columns,\n                    categoricalColumns: [],\n                    temporalColumns: [],\n                    dataRanges: {},\n                    categories: {},\n                    dataTypes: {}\n                });\n            }\n        };\n        updateVisualization();\n    }, [\n        plotlyLoaded,\n        data,\n        columns,\n        visualizationType,\n        generatedConfig\n    ]);\n    // Analyse complète et intelligente des données\n    const analyzeDataIntelligently = ()=>{\n        if (!data || data.length === 0 || !columns || columns.length === 0) {\n            return null;\n        }\n        const analysis = {\n            mapping: {},\n            numericColumns: [],\n            categoricalColumns: [],\n            temporalColumns: [],\n            dataRanges: {},\n            categories: {},\n            dataTypes: {}\n        };\n        // Analyser chaque colonne en détail\n        columns.forEach((col)=>{\n            const values = data.map((row)=>row[col]).filter((val)=>val != null && val !== \"\");\n            if (values.length === 0) {\n                analysis.dataTypes[col] = \"mixed\";\n                return;\n            }\n            // Test numérique\n            const numericValues = values.map((val)=>Number.parseFloat(val)).filter((val)=>!isNaN(val) && isFinite(val));\n            const numericRatio = numericValues.length / values.length;\n            // Test temporel\n            const dateValues = values.filter((val)=>{\n                const date = new Date(val);\n                return !isNaN(date.getTime()) && date.getFullYear() > 1900 && date.getFullYear() < 2100;\n            });\n            const temporalRatio = dateValues.length / values.length;\n            // Test catégoriel\n            const uniqueValues = [\n                ...new Set(values)\n            ];\n            const uniqueRatio = uniqueValues.length / values.length;\n            // Classification intelligente\n            if (temporalRatio > 0.7) {\n                analysis.dataTypes[col] = \"temporal\";\n                analysis.temporalColumns.push(col);\n                // Convertir en timestamps pour les calculs\n                const timestamps = dateValues.map((val)=>new Date(val).getTime());\n                analysis.dataRanges[col] = {\n                    min: Math.min(...timestamps),\n                    max: Math.max(...timestamps),\n                    values: timestamps\n                };\n            } else if (numericRatio > 0.7) {\n                analysis.dataTypes[col] = \"numeric\";\n                analysis.numericColumns.push(col);\n                analysis.dataRanges[col] = {\n                    min: Math.min(...numericValues),\n                    max: Math.max(...numericValues),\n                    values: numericValues\n                };\n            } else if (uniqueRatio < 0.3 || uniqueValues.length <= 20) {\n                analysis.dataTypes[col] = \"categorical\";\n                analysis.categoricalColumns.push(col);\n                analysis.categories[col] = uniqueValues.slice(0, 20) // Limiter à 20 catégories\n                ;\n            } else {\n                analysis.dataTypes[col] = \"mixed\";\n                if (numericValues.length > 0) {\n                    analysis.dataRanges[col] = {\n                        min: Math.min(...numericValues),\n                        max: Math.max(...numericValues),\n                        values: numericValues\n                    };\n                }\n            }\n        });\n        // Créer un mapping intelligent basé sur les types de données\n        const allNumericCols = [\n            ...analysis.numericColumns,\n            ...analysis.temporalColumns\n        ];\n        if (allNumericCols.length >= 3) {\n            analysis.mapping = {\n                xAxis: allNumericCols[0],\n                yAxis: allNumericCols[1],\n                zAxis: allNumericCols[2],\n                colorBy: allNumericCols[0],\n                sizeBy: allNumericCols.length > 3 ? allNumericCols[3] : allNumericCols[0],\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        } else if (allNumericCols.length === 2) {\n            analysis.mapping = {\n                xAxis: allNumericCols[0],\n                yAxis: allNumericCols[1],\n                zAxis: allNumericCols[0],\n                colorBy: allNumericCols[1],\n                sizeBy: allNumericCols[0],\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        } else if (allNumericCols.length === 1) {\n            analysis.mapping = {\n                xAxis: allNumericCols[0],\n                yAxis: \"index\",\n                zAxis: allNumericCols[0],\n                colorBy: allNumericCols[0],\n                sizeBy: allNumericCols[0],\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        } else {\n            // Utiliser les indices et catégories\n            analysis.mapping = {\n                xAxis: \"index\",\n                yAxis: analysis.categoricalColumns[0] || \"index\",\n                zAxis: \"count\",\n                colorBy: analysis.categoricalColumns[0] || \"index\",\n                sizeBy: \"count\",\n                categoryBy: analysis.categoricalColumns[0]\n            };\n        }\n        return analysis;\n    };\n    // Fonction principale qui route vers la bonne visualisation selon le modèle\n    const renderModelSpecificVisualization = ()=>{\n        if (!data || data.length === 0) {\n            renderDemoVisualization();\n            return;\n        }\n        const analysis = analyzeDataIntelligently();\n        if (!analysis) {\n            renderDemoVisualization();\n            return;\n        }\n        setDataAnalysis(analysis);\n        setDataMapping(analysis.mapping);\n        // Router vers la fonction spécialisée selon le modèle exact\n        switch(visualizationType){\n            // NUAGES\n            case \"scatter3d\":\n                renderClassicScatter(analysis);\n                break;\n            case \"scatter_bubble\":\n                renderBubbleScatter(analysis);\n                break;\n            case \"scatter_animated\":\n                renderAnimatedScatter(analysis);\n                break;\n            case \"scatter_clustered\":\n                renderClusteredScatter(analysis);\n                break;\n            case \"scatter_density\":\n                renderDensityScatter(analysis);\n                break;\n            // SURFACES\n            case \"surface3d\":\n                renderClassicSurface(analysis);\n                break;\n            case \"surface_contour\":\n                renderContourSurface(analysis);\n                break;\n            case \"surface_mesh\":\n                renderMeshSurface(analysis);\n                break;\n            case \"surface_gradient\":\n                renderGradientSurface(analysis);\n                break;\n            // ARCHITECTURE\n            case \"bars3d\":\n                renderClassicBars(analysis);\n                break;\n            case \"bars_grouped\":\n                renderGroupedBars(analysis);\n                break;\n            case \"bars_cylindrical\":\n                renderCylindricalBars(analysis);\n                break;\n            case \"bars_pyramid\":\n                renderPyramidBars(analysis);\n                break;\n            // GÉOMÉTRIQUES\n            case \"sphere_pack\":\n                renderSpherePack(analysis);\n                break;\n            case \"cube_matrix\":\n                renderCubeMatrix(analysis);\n                break;\n            case \"cone_field\":\n                renderConeField(analysis);\n                break;\n            case \"helix_spiral\":\n                renderHelixSpiral(analysis);\n                break;\n            // ARTISTIQUES\n            case \"mandala_3d\":\n                renderMandala3D(analysis);\n                break;\n            case \"fractal_3d\":\n                renderFractal3D(analysis);\n                break;\n            case \"crystal_3d\":\n                renderCrystal3D(analysis);\n                break;\n            case \"galaxy_3d\":\n                renderGalaxy3D(analysis);\n                break;\n            case \"dna_helix\":\n                renderDNAHelix(analysis);\n                break;\n            // RÉSEAUX\n            case \"network_3d\":\n                renderNetwork3D(analysis);\n                break;\n            case \"tree_3d\":\n                renderTree3D(analysis);\n                break;\n            // TEMPORELS\n            case \"timeline_3d\":\n                renderTimeline3D(analysis);\n                break;\n            case \"wave_temporal\":\n                renderWaveTemporal(analysis);\n                break;\n            case \"spiral_time\":\n                renderSpiralTime(analysis);\n                break;\n            // GÉOGRAPHIQUES\n            case \"globe_3d\":\n                renderGlobe3D(analysis);\n                break;\n            case \"terrain_3d\":\n                renderTerrain3D(analysis);\n                break;\n            // SCIENTIFIQUES\n            case \"molecule_3d\":\n                renderMolecule3D(analysis);\n                break;\n            case \"vector_field\":\n                renderVectorField(analysis);\n                break;\n            // STATISTIQUES\n            case \"histogram_3d\":\n                renderHistogram3D(analysis);\n                break;\n            case \"box_plot_3d\":\n                renderBoxPlot3D(analysis);\n                break;\n            default:\n                renderClassicScatter(analysis);\n        }\n    };\n    // Fonction utilitaire pour extraire les valeurs avec l'analyse\n    const getValuesFromAnalysis = (analysis, key)=>{\n        const column = analysis.mapping[key];\n        if (column === \"index\") {\n            return data.map((_, i)=>i);\n        } else if (column === \"count\") {\n            return data.map(()=>1);\n        } else if (column && columns.includes(column)) {\n            if (analysis.dataRanges[column]) {\n                // Utiliser les valeurs pré-calculées pour les colonnes numériques/temporelles\n                const range = analysis.dataRanges[column];\n                return data.map((row, i)=>{\n                    const val = row[column];\n                    if (analysis.dataTypes[column] === \"temporal\") {\n                        const timestamp = new Date(val).getTime();\n                        return isNaN(timestamp) ? range.min : timestamp;\n                    } else {\n                        const numVal = Number.parseFloat(val);\n                        return !isNaN(numVal) && isFinite(numVal) ? numVal : range.min;\n                    }\n                });\n            } else if (analysis.categories[column]) {\n                // Convertir les catégories en indices numériques\n                const categories = analysis.categories[column];\n                return data.map((row)=>{\n                    const val = row[column];\n                    const index = categories.indexOf(val);\n                    return index >= 0 ? index : 0;\n                });\n            }\n        }\n        return data.map((_, i)=>i);\n    };\n    // VISUALISATIONS SPÉCIALISÉES AVEC DONNÉES DYNAMIQUES\n    // 1. NUAGE CLASSIQUE - Adapté aux données\n    const renderClassicScatter = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        // Adapter la taille des marqueurs selon la densité des données\n        const markerSize = Math.max(3, Math.min(12, 100 / Math.sqrt(data.length)));\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: xValues,\n                y: yValues,\n                z: zValues,\n                marker: {\n                    size: markerSize,\n                    color: colorValues,\n                    colorscale: \"Viridis\",\n                    opacity: Math.max(0.6, 1 - data.length / 1000),\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                text: data.map((row, i)=>{\n                    let tooltip = \"<b>Point \".concat(i + 1, \"</b><br>\");\n                    tooltip += \"<b>\".concat(analysis.mapping.xAxis, \":</b> \").concat(row[analysis.mapping.xAxis] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>\".concat(analysis.mapping.yAxis, \":</b> \").concat(row[analysis.mapping.yAxis] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>\".concat(analysis.mapping.zAxis, \":</b> \").concat(row[analysis.mapping.zAxis] || \"N/A\", \"<br>\");\n                    if (analysis.mapping.categoryBy && row[analysis.mapping.categoryBy]) {\n                        tooltip += \"<b>\".concat(analysis.mapping.categoryBy, \":</b> \").concat(row[analysis.mapping.categoryBy], \"<br>\");\n                    }\n                    return tooltip;\n                }),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Nuage 3D - \".concat(data.length, \" points\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Nuage 3D Classique\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 2. DENSITÉ 3D - Vraie densité basée sur les données réelles\n    const renderDensityScatter = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        // Adapter la résolution de la grille selon le nombre de données\n        const gridSize = Math.min(25, Math.max(10, Math.sqrt(data.length)));\n        const xRange = analysis.dataRanges[analysis.mapping.xAxis];\n        const yRange = analysis.dataRanges[analysis.mapping.yAxis];\n        const zRange = analysis.dataRanges[analysis.mapping.zAxis];\n        if (!xRange || !yRange || !zRange) {\n            renderClassicScatter(analysis);\n            return;\n        }\n        const densityX = [];\n        const densityY = [];\n        const densityZ = [];\n        const densityColors = [];\n        const densitySizes = [];\n        // Calculer le rayon adaptatif basé sur les vraies données\n        const xSpan = xRange.max - xRange.min;\n        const ySpan = yRange.max - yRange.min;\n        const zSpan = zRange.max - zRange.min;\n        const radius = Math.max(xSpan, ySpan, zSpan) / (gridSize * 0.8);\n        for(let i = 0; i < gridSize; i++){\n            for(let j = 0; j < gridSize; j++){\n                for(let k = 0; k < gridSize; k++){\n                    const x = xRange.min + i / (gridSize - 1) * xSpan;\n                    const y = yRange.min + j / (gridSize - 1) * ySpan;\n                    const z = zRange.min + k / (gridSize - 1) * zSpan;\n                    // Calculer la densité locale avec les vraies données\n                    let density = 0;\n                    for(let p = 0; p < data.length; p++){\n                        const dx = xValues[p] - x;\n                        const dy = yValues[p] - y;\n                        const dz = zValues[p] - z;\n                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                        if (distance < radius) {\n                            density += Math.exp(-(distance * distance) / (radius * radius));\n                        }\n                    }\n                    // Seuil adaptatif basé sur la densité moyenne\n                    const threshold = data.length / (gridSize * gridSize * gridSize) * 0.5;\n                    if (density > threshold) {\n                        densityX.push(x);\n                        densityY.push(y);\n                        densityZ.push(z);\n                        densityColors.push(density);\n                        densitySizes.push(Math.max(4, Math.min(20, density * 15)));\n                    }\n                }\n            }\n        }\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: densityX,\n                y: densityY,\n                z: densityZ,\n                marker: {\n                    size: densitySizes,\n                    color: densityColors,\n                    colorscale: \"Hot\",\n                    opacity: 0.7,\n                    colorbar: {\n                        title: \"Densit\\xe9 Locale\",\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                text: densityX.map((_, i)=>\"<b>Zone Dense \".concat(i + 1, \"</b><br>Densit\\xe9: \").concat(densityColors[i].toFixed(2), \"<br>Position: (\").concat(densityX[i].toFixed(1), \", \").concat(densityY[i].toFixed(1), \", \").concat(densityZ[i].toFixed(1), \")\")),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Densit\\xe9 3D - \".concat(densityX.length, \" zones\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Densit\\xe9 3D - Zones de Concentration\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 3. BULLES 3D - Tailles vraiment proportionnelles aux données\n    const renderBubbleScatter = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        // Adapter la taille des bulles selon les données\n        const minSize = 10;\n        const maxSize = 50;\n        const normalizedSizes = sizeValues.map((v)=>{\n            const min = Math.min(...sizeValues);\n            const max = Math.max(...sizeValues);\n            return minSize + (v - min) / (max - min) * (maxSize - minSize);\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: xValues,\n                y: yValues,\n                z: zValues,\n                marker: {\n                    size: normalizedSizes,\n                    color: colorValues,\n                    colorscale: \"Plasma\",\n                    opacity: 0.75,\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    },\n                    line: {\n                        color: \"rgba(255, 255, 255, 0.3)\",\n                        width: 1\n                    }\n                },\n                text: data.map((row, i)=>{\n                    let tooltip = \"<b>Bulle \".concat(i + 1, \"</b><br>\");\n                    tooltip += \"<b>Taille (\".concat(analysis.mapping.sizeBy, \"):</b> \").concat(row[analysis.mapping.sizeBy] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>Couleur (\".concat(analysis.mapping.colorBy, \"):</b> \").concat(row[analysis.mapping.colorBy] || \"N/A\", \"<br>\");\n                    if (analysis.mapping.categoryBy && row[analysis.mapping.categoryBy]) {\n                        tooltip += \"<b>Cat\\xe9gorie:</b> \".concat(row[analysis.mapping.categoryBy], \"<br>\");\n                    }\n                    return tooltip;\n                }),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Bulles 3D - \".concat(data.length, \" \\xe9l\\xe9ments\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Bulles 3D - Tailles Proportionnelles\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 4. MANDALA 3D - Basé sur les patterns des données\n    const renderMandala3D = (analysis)=>{\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        const mandalaX = [];\n        const mandalaY = [];\n        const mandalaZ = [];\n        const mandalaColors = [];\n        const mandalaSizes = [];\n        // Utiliser les vraies données pour créer les patterns\n        data.forEach((row, i)=>{\n            const normalizedIndex = i / data.length;\n            const colorVal = colorValues[i];\n            const sizeVal = sizeValues[i];\n            // Nombre de tours basé sur la variance des données\n            const colorRange = analysis.dataRanges[analysis.mapping.colorBy];\n            const tours = colorRange ? 4 + (colorVal - colorRange.min) / (colorRange.max - colorRange.min) * 4 : 6;\n            const angle = normalizedIndex * tours * Math.PI;\n            const radius = 1 + Math.sin(angle * 3) * 0.5;\n            const height = Math.sin(angle * 2) * 0.3;\n            // Point principal\n            mandalaX.push(Math.cos(angle) * radius);\n            mandalaY.push(Math.sin(angle) * radius);\n            mandalaZ.push(height);\n            mandalaColors.push(colorVal);\n            mandalaSizes.push(Math.max(3, Math.min(8, sizeVal / ((colorRange === null || colorRange === void 0 ? void 0 : colorRange.max) || 1) * 6 + 3)));\n            // Pétales basés sur les catégories\n            const numPetals = analysis.mapping.categoryBy && analysis.categories[analysis.mapping.categoryBy] ? Math.min(6, analysis.categories[analysis.mapping.categoryBy].length) : 5;\n            for(let j = 0; j < numPetals; j++){\n                const petalAngle = angle + j * 2 * Math.PI / numPetals;\n                const petalRadius = radius * 0.3;\n                mandalaX.push(Math.cos(angle) * radius + Math.cos(petalAngle) * petalRadius);\n                mandalaY.push(Math.sin(angle) * radius + Math.sin(petalAngle) * petalRadius);\n                mandalaZ.push(height + Math.sin(petalAngle * 2) * 0.1);\n                mandalaColors.push(colorVal * 0.8);\n                mandalaSizes.push(Math.max(2, mandalaSizes[mandalaSizes.length - 1] * 0.6));\n            }\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: mandalaX,\n                y: mandalaY,\n                z: mandalaZ,\n                marker: {\n                    size: mandalaSizes,\n                    color: mandalaColors,\n                    colorscale: \"Rainbow\",\n                    opacity: 0.8,\n                    colorbar: {\n                        title: \"Harmonie (\".concat(analysis.mapping.colorBy, \")\"),\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                name: \"Mandala 3D - \".concat(data.length, \" \\xe9l\\xe9ments source\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Mandala 3D - Motifs Sacr\\xe9s\", analysis);\n        layout.scene.camera = {\n            eye: {\n                x: 0,\n                y: 0,\n                z: 2.5\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 5. GALAXIE 3D - Structure basée sur les données\n    const renderGalaxy3D = (analysis)=>{\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        const galaxyX = [];\n        const galaxyY = [];\n        const galaxyZ = [];\n        const galaxyColors = [];\n        const galaxySizes = [];\n        // Analyser la distribution pour créer les bras galactiques\n        const colorRange = analysis.dataRanges[analysis.mapping.colorBy];\n        const sizeRange = analysis.dataRanges[analysis.mapping.sizeBy];\n        data.forEach((row, i)=>{\n            const t = i / data.length;\n            const colorVal = colorValues[i];\n            const sizeVal = sizeValues[i];\n            // Position dans la galaxie basée sur les valeurs des données\n            const normalizedColor = colorRange ? (colorVal - colorRange.min) / (colorRange.max - colorRange.min) : t;\n            const normalizedSize = sizeRange ? (sizeVal - sizeRange.min) / (sizeRange.max - sizeRange.min) : 0.5;\n            // Angle et rayon basés sur les données\n            const angle = normalizedColor * 6 * Math.PI + t * 2 * Math.PI;\n            const radius = normalizedSize * 3 + t * 0.5;\n            const height = (Math.random() - 0.5) * 0.2 * (1 - t // Plus plat vers l'extérieur\n            );\n            // Bras principal\n            galaxyX.push(Math.cos(angle) * radius);\n            galaxyY.push(Math.sin(angle) * radius);\n            galaxyZ.push(height);\n            galaxyColors.push(colorVal);\n            galaxySizes.push(Math.max(2, Math.min(12, (1 - normalizedSize) * 8 + 3)));\n            // Bras secondaire si assez de données\n            if (data.length > 20) {\n                const angle2 = angle + Math.PI * 0.8;\n                const radius2 = radius * 0.7;\n                galaxyX.push(Math.cos(angle2) * radius2);\n                galaxyY.push(Math.sin(angle2) * radius2);\n                galaxyZ.push(height * 0.5);\n                galaxyColors.push(colorVal * 0.8);\n                galaxySizes.push(Math.max(1, galaxySizes[galaxySizes.length - 1] * 0.7));\n            }\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: galaxyX,\n                y: galaxyY,\n                z: galaxyZ,\n                marker: {\n                    size: galaxySizes,\n                    color: galaxyColors,\n                    colorscale: \"Viridis\",\n                    opacity: 0.8,\n                    colorbar: {\n                        title: \"Luminosit\\xe9 (\".concat(analysis.mapping.colorBy, \")\"),\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                name: \"Galaxie 3D - \".concat(data.length, \" \\xe9toiles\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Galaxie 3D - Spirale Cosmique\", analysis);\n        layout.scene.bgcolor = \"rgba(0, 0, 20, 0.9)\";\n        layout.scene.camera = {\n            eye: {\n                x: 1.5,\n                y: 1.5,\n                z: 1\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 6. TIMELINE 3D - Pour données temporelles\n    const renderTimeline3D = (analysis)=>{\n        // Chercher une colonne temporelle\n        const timeColumn = analysis.temporalColumns[0] || analysis.mapping.xAxis;\n        const valueColumn = analysis.mapping.yAxis;\n        const colorColumn = analysis.mapping.colorBy;\n        const timeValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const values = getValuesFromAnalysis(analysis, \"yAxis\");\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        // Trier par temps si c'est temporel\n        const sortedIndices = timeValues.map((_, i)=>i).sort((a, b)=>timeValues[a] - timeValues[b]);\n        const timelineX = sortedIndices.map((i)=>timeValues[i]);\n        const timelineY = sortedIndices.map((i)=>values[i]);\n        const timelineZ = sortedIndices.map((_, i)=>i * 0.1) // Élévation progressive\n        ;\n        const timelineColors = sortedIndices.map((i)=>colorValues[i]);\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers+lines\",\n                x: timelineX,\n                y: timelineY,\n                z: timelineZ,\n                marker: {\n                    size: 6,\n                    color: timelineColors,\n                    colorscale: \"Viridis\",\n                    opacity: 0.8,\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                line: {\n                    color: \"rgba(100, 100, 100, 0.6)\",\n                    width: 3\n                },\n                text: sortedIndices.map((i)=>{\n                    const row = data[i];\n                    let tooltip = \"<b>Point temporel \".concat(i + 1, \"</b><br>\");\n                    tooltip += \"<b>Temps:</b> \".concat(row[timeColumn] || \"N/A\", \"<br>\");\n                    tooltip += \"<b>Valeur:</b> \".concat(row[valueColumn] || \"N/A\", \"<br>\");\n                    return tooltip;\n                }),\n                hovertemplate: \"%{text}<extra></extra>\",\n                name: \"Timeline 3D - \".concat(data.length, \" points\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Timeline 3D - \\xc9volution Temporelle\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // Fonctions de rendu simplifiées pour les autres modèles\n    const renderAnimatedScatter = (analysis)=>renderClassicScatter(analysis);\n    const renderClusteredScatter = (analysis)=>renderBubbleScatter(analysis);\n    const renderClassicSurface = (analysis)=>renderContourSurface(analysis);\n    const renderMeshSurface = (analysis)=>renderContourSurface(analysis);\n    const renderGradientSurface = (analysis)=>renderContourSurface(analysis);\n    const renderClassicBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderGroupedBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderCylindricalBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderPyramidBars = (analysis)=>renderBubbleScatter(analysis);\n    const renderSpherePack = (analysis)=>renderBubbleScatter(analysis);\n    const renderCubeMatrix = (analysis)=>renderClassicScatter(analysis);\n    const renderConeField = (analysis)=>renderClassicScatter(analysis);\n    const renderHelixSpiral = (analysis)=>renderDNAHelix(analysis);\n    const renderFractal3D = (analysis)=>renderMandala3D(analysis);\n    const renderCrystal3D = (analysis)=>renderClassicScatter(analysis);\n    const renderNetwork3D = (analysis)=>renderClassicScatter(analysis);\n    const renderTree3D = (analysis)=>renderClassicScatter(analysis);\n    const renderWaveTemporal = (analysis)=>renderTimeline3D(analysis);\n    const renderSpiralTime = (analysis)=>renderTimeline3D(analysis);\n    const renderGlobe3D = (analysis)=>renderClassicScatter(analysis);\n    const renderTerrain3D = (analysis)=>renderContourSurface(analysis);\n    const renderMolecule3D = (analysis)=>renderClassicScatter(analysis);\n    const renderVectorField = (analysis)=>renderClassicScatter(analysis);\n    const renderHistogram3D = (analysis)=>renderBubbleScatter(analysis);\n    const renderBoxPlot3D = (analysis)=>renderBubbleScatter(analysis);\n    // 7. SURFACE AVEC CONTOURS - Basée sur les vraies données\n    const renderContourSurface = (analysis)=>{\n        const xValues = getValuesFromAnalysis(analysis, \"xAxis\");\n        const yValues = getValuesFromAnalysis(analysis, \"yAxis\");\n        const zValues = getValuesFromAnalysis(analysis, \"zAxis\");\n        const xRange = analysis.dataRanges[analysis.mapping.xAxis];\n        const yRange = analysis.dataRanges[analysis.mapping.yAxis];\n        if (!xRange || !yRange) {\n            renderClassicScatter(analysis);\n            return;\n        }\n        // Adapter la résolution selon la densité des données\n        const size = Math.min(30, Math.max(15, Math.sqrt(data.length)));\n        const xMin = xRange.min;\n        const xMax = xRange.max;\n        const yMin = yRange.min;\n        const yMax = yRange.max;\n        const xGrid = Array.from({\n            length: size\n        }, (_, i)=>xMin + i / (size - 1) * (xMax - xMin));\n        const yGrid = Array.from({\n            length: size\n        }, (_, i)=>yMin + i / (size - 1) * (yMax - yMin));\n        const surface = [];\n        for(let i = 0; i < size; i++){\n            const row = [];\n            for(let j = 0; j < size; j++){\n                const targetX = xGrid[j];\n                const targetY = yGrid[i];\n                // Interpolation pondérée par la distance\n                let weightedSum = 0;\n                let totalWeight = 0;\n                const maxDistance = Math.sqrt((xMax - xMin) ** 2 + (yMax - yMin) ** 2) / 5;\n                for(let k = 0; k < data.length; k++){\n                    const dx = xValues[k] - targetX;\n                    const dy = yValues[k] - targetY;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    if (distance < maxDistance) {\n                        const weight = Math.exp(-(distance * distance) / (maxDistance * maxDistance));\n                        weightedSum += zValues[k] * weight;\n                        totalWeight += weight;\n                    }\n                }\n                row.push(totalWeight > 0 ? weightedSum / totalWeight : 0);\n            }\n            surface.push(row);\n        }\n        const plotData = [\n            {\n                type: \"surface\",\n                z: surface,\n                x: xGrid,\n                y: yGrid,\n                colorscale: \"Earth\",\n                contours: {\n                    z: {\n                        show: true,\n                        usecolormap: true,\n                        highlightcolor: \"#42f462\",\n                        project: {\n                            z: true\n                        },\n                        width: 2\n                    }\n                },\n                colorbar: {\n                    title: analysis.mapping.zAxis,\n                    titlefont: {\n                        size: 10\n                    }\n                },\n                name: \"Surface - \".concat(data.length, \" points source\")\n            }\n        ];\n        const layout = createDynamicLayout(\"Surface 3D - Lignes de Niveau\", analysis);\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // 8. HÉLICE ADN - Basée sur les séquences de données\n    const renderDNAHelix = (analysis)=>{\n        const colorValues = getValuesFromAnalysis(analysis, \"colorBy\");\n        const sizeValues = getValuesFromAnalysis(analysis, \"sizeBy\");\n        const dnaX1 = [];\n        const dnaY1 = [];\n        const dnaZ1 = [];\n        const dnaX2 = [];\n        const dnaY2 = [];\n        const dnaZ2 = [];\n        const dnaColors = [];\n        const dnaSizes = [];\n        // Utiliser les vraies données pour moduler l'hélice\n        const colorRange = analysis.dataRanges[analysis.mapping.colorBy];\n        const sizeRange = analysis.dataRanges[analysis.mapping.sizeBy];\n        data.forEach((row, i)=>{\n            const t = i / data.length * 8 * Math.PI;\n            const z = i / data.length * 4;\n            // Modulation basée sur les données\n            const colorVal = colorValues[i];\n            const sizeVal = sizeValues[i];\n            const radiusModulation = colorRange ? 1 + 0.3 * (colorVal - colorRange.min) / (colorRange.max - colorRange.min) : 1;\n            const heightModulation = sizeRange ? 0.1 * (sizeVal - sizeRange.min) / (sizeRange.max - sizeRange.min) : 0;\n            // Premier brin\n            dnaX1.push(Math.cos(t) * radiusModulation);\n            dnaY1.push(Math.sin(t) * radiusModulation);\n            dnaZ1.push(z + heightModulation);\n            // Deuxième brin (décalé de π)\n            dnaX2.push(Math.cos(t + Math.PI) * radiusModulation);\n            dnaY2.push(Math.sin(t + Math.PI) * radiusModulation);\n            dnaZ2.push(z + heightModulation);\n            dnaColors.push(colorVal);\n            dnaSizes.push(Math.max(4, Math.min(10, sizeVal / ((sizeRange === null || sizeRange === void 0 ? void 0 : sizeRange.max) || 1) * 6 + 4)));\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers+lines\",\n                x: dnaX1,\n                y: dnaY1,\n                z: dnaZ1,\n                marker: {\n                    size: dnaSizes,\n                    color: dnaColors,\n                    colorscale: \"RdYlBu\",\n                    colorbar: {\n                        title: analysis.mapping.colorBy,\n                        titlefont: {\n                            size: 10\n                        }\n                    }\n                },\n                line: {\n                    color: \"rgba(255, 100, 100, 0.8)\",\n                    width: 4\n                },\n                name: \"Brin ADN 1 - \".concat(data.length, \" bases\")\n            },\n            {\n                type: \"scatter3d\",\n                mode: \"markers+lines\",\n                x: dnaX2,\n                y: dnaY2,\n                z: dnaZ2,\n                marker: {\n                    size: dnaSizes,\n                    color: dnaColors,\n                    colorscale: \"RdYlBu\"\n                },\n                line: {\n                    color: \"rgba(100, 100, 255, 0.8)\",\n                    width: 4\n                },\n                name: \"Brin ADN 2 - \".concat(data.length, \" bases\"),\n                showlegend: false\n            }\n        ];\n        const layout = createDynamicLayout(\"Double H\\xe9lice ADN\", analysis);\n        layout.scene.camera = {\n            eye: {\n                x: 2,\n                y: 0,\n                z: 1\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    // Fonction pour créer un layout dynamique basé sur l'analyse\n    const createDynamicLayout = (title, analysis)=>{\n        const dataInfo = \"\".concat(data.length, \" entr\\xe9es • \").concat(analysis.numericColumns.length, \" num. • \").concat(analysis.categoricalColumns.length, \" cat.\");\n        return {\n            scene: {\n                xaxis: {\n                    title: {\n                        text: \"\".concat(analysis.mapping.xAxis, \" \").concat(analysis.dataTypes[analysis.mapping.xAxis] ? \"(\".concat(analysis.dataTypes[analysis.mapping.xAxis], \")\") : \"\"),\n                        font: {\n                            size: 12,\n                            color: \"#ea580c\"\n                        }\n                    },\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                yaxis: {\n                    title: {\n                        text: \"\".concat(analysis.mapping.yAxis, \" \").concat(analysis.dataTypes[analysis.mapping.yAxis] ? \"(\".concat(analysis.dataTypes[analysis.mapping.yAxis], \")\") : \"\"),\n                        font: {\n                            size: 12,\n                            color: \"#ea580c\"\n                        }\n                    },\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                zaxis: {\n                    title: {\n                        text: \"\".concat(analysis.mapping.zAxis, \" \").concat(analysis.dataTypes[analysis.mapping.zAxis] ? \"(\".concat(analysis.dataTypes[analysis.mapping.zAxis], \")\") : \"\"),\n                        font: {\n                            size: 12,\n                            color: \"#ea580c\"\n                        }\n                    },\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                camera: {\n                    eye: {\n                        x: 1.25,\n                        y: 1.25,\n                        z: 1.25\n                    }\n                }\n            },\n            title: {\n                text: title,\n                font: {\n                    size: 18,\n                    color: \"#ea580c\"\n                }\n            },\n            paper_bgcolor: \"rgba(0,0,0,0)\",\n            margin: {\n                l: 0,\n                r: 0,\n                t: 60,\n                b: 0\n            },\n            annotations: [\n                {\n                    text: \"<b>Mod\\xe8le:</b> \".concat(title, \"<br><b>Donn\\xe9es:</b> \").concat(dataInfo, \"<br><b>Mapping:</b><br>• X: \").concat(analysis.mapping.xAxis, \"<br>• Y: \").concat(analysis.mapping.yAxis, \"<br>• Z: \").concat(analysis.mapping.zAxis, \"<br>• Couleur: \").concat(analysis.mapping.colorBy, \"<br>• Taille: \").concat(analysis.mapping.sizeBy).concat(analysis.mapping.categoryBy ? \"<br>• Cat\\xe9gorie: \".concat(analysis.mapping.categoryBy) : \"\"),\n                    showarrow: false,\n                    xref: \"paper\",\n                    yref: \"paper\",\n                    x: -0.15,\n                    y: 0.95,\n                    xanchor: \"left\",\n                    yanchor: \"top\",\n                    bgcolor: \"rgba(255, 255, 255, 0.8)\",\n                    bordercolor: \"rgba(234, 88, 12, 0.3)\",\n                    borderwidth: 1,\n                    font: {\n                        size: 8,\n                        color: \"#666\"\n                    }\n                }\n            ]\n        };\n    };\n    const getPlotConfig = ()=>({\n            responsive: true,\n            displayModeBar: false,\n            staticPlot: false,\n            scrollZoom: true,\n            doubleClick: \"reset\"\n        });\n    const renderV0Visualization = (config)=>{\n        try {\n            window.Plotly.newPlot(plotRef.current, config.config.data, config.config.layout, getPlotConfig());\n        } catch (error) {\n            console.error(\"Erreur rendu v0:\", error);\n            renderModelSpecificVisualization();\n        }\n    };\n    const renderDemoVisualization = ()=>{\n        const demoData = Array.from({\n            length: 50\n        }, (_, i)=>({\n                x: Math.random() * 10,\n                y: Math.random() * 10,\n                z: Math.random() * 10,\n                value: Math.random() * 100,\n                category: \"Cat\".concat(Math.floor(Math.random() * 5) + 1)\n            }));\n        setDataMapping({\n            xAxis: \"Dimension X\",\n            yAxis: \"Dimension Y\",\n            zAxis: \"Dimension Z\",\n            colorBy: \"Valeur\",\n            sizeBy: \"Valeur\"\n        });\n        const plotData = [\n            {\n                type: \"scatter3d\",\n                mode: \"markers\",\n                x: demoData.map((d)=>d.x),\n                y: demoData.map((d)=>d.y),\n                z: demoData.map((d)=>d.z),\n                marker: {\n                    size: 8,\n                    color: demoData.map((d)=>d.value),\n                    colorscale: \"Rainbow\",\n                    opacity: 0.8\n                },\n                name: \"D\\xe9monstration\"\n            }\n        ];\n        const layout = {\n            scene: {\n                xaxis: {\n                    title: \"Dimension X\",\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                yaxis: {\n                    title: \"Dimension Y\",\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                zaxis: {\n                    title: \"Dimension Z\",\n                    showbackground: true,\n                    backgroundcolor: \"rgba(240, 240, 240, 0.8)\"\n                },\n                camera: {\n                    eye: {\n                        x: 1.25,\n                        y: 1.25,\n                        z: 1.25\n                    }\n                }\n            },\n            title: {\n                text: \"D\\xe9monstration - \".concat(getModelName(visualizationType)),\n                font: {\n                    size: 18,\n                    color: \"#ea580c\"\n                }\n            },\n            paper_bgcolor: \"rgba(0,0,0,0)\",\n            margin: {\n                l: 0,\n                r: 0,\n                t: 60,\n                b: 0\n            }\n        };\n        window.Plotly.newPlot(plotRef.current, plotData, layout, getPlotConfig());\n    };\n    const getModelName = (modelId)=>{\n        const names = {\n            scatter3d: \"Nuage 3D Classique\",\n            scatter_density: \"Densit\\xe9 3D\",\n            scatter_bubble: \"Bulles 3D\",\n            mandala_3d: \"Mandala 3D\",\n            galaxy_3d: \"Galaxie 3D\",\n            surface_contour: \"Surface Contours\",\n            dna_helix: \"H\\xe9lice ADN\",\n            timeline_3d: \"Timeline 3D\"\n        };\n        return names[modelId] || \"Visualisation 3D\";\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-full bg-gradient-to-br from-orange-50 to-white rounded-xl border-2 border-orange-200 overflow-hidden\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-6 border-b border-orange-200 bg-white\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-3\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-12 h-12 bg-gradient-to-br from-orange-600 to-orange-500 rounded-xl flex items-center justify-center\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                        className: \"w-6 h-6 text-white\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                        lineNumber: 1142,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1141,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                            className: \"text-xl font-bold text-gray-800\",\n                                            children: \"Canvas IA • Visualisation Dynamique\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1145,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-sm text-gray-600\",\n                                            children: data.length > 0 ? \"\".concat(data.length, \" \\xe9chantillons • \").concat(columns.length, \" variables • \").concat(getModelName(currentModel)) : \"Mode d\\xe9monstration • \".concat(getModelName(currentModel))\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1146,\n                                            columnNumber: 15\n                                        }, this),\n                                        dataAnalysis && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-xs text-gray-500\",\n                                            children: [\n                                                dataAnalysis.numericColumns.length,\n                                                \" num\\xe9riques • \",\n                                                dataAnalysis.categoricalColumns.length,\n                                                \" \",\n                                                \"cat\\xe9gorielles • \",\n                                                dataAnalysis.temporalColumns.length,\n                                                \" temporelles\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1152,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1144,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                            lineNumber: 1140,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: [\n                                isV0Generated && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                            className: \"w-3 h-3 mr-1\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1163,\n                                            columnNumber: 17\n                                        }, this),\n                                        \"G\\xe9n\\xe9r\\xe9 par v0\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1162,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-orange-100 text-orange-800\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Code_TrendingUp_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                            className: \"w-3 h-3 mr-1\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                            lineNumber: 1168,\n                                            columnNumber: 15\n                                        }, this),\n                                        \"Plotly v2.35\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1167,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800\",\n                                    children: \"Adaptatif Dynamique\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                    lineNumber: 1171,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                            lineNumber: 1160,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                    lineNumber: 1139,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                lineNumber: 1138,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative h-[calc(100%-120px)]\",\n                children: !plotlyLoaded ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-center h-full\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-8 h-8 border-2 border-orange-500 border-t-transparent rounded-full animate-spin mx-auto mb-4\"\n                            }, void 0, false, {\n                                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                lineNumber: 1183,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-gray-600\",\n                                children: \"Chargement de Plotly.js v2.35...\"\n                            }, void 0, false, {\n                                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                lineNumber: 1184,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-gray-500 mt-2\",\n                                children: \"Analyse dynamique des donn\\xe9es en cours...\"\n                            }, void 0, false, {\n                                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                                lineNumber: 1185,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                        lineNumber: 1182,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                    lineNumber: 1181,\n                    columnNumber: 11\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    ref: plotRef,\n                    className: \"w-full h-full\"\n                }, void 0, false, {\n                    fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                    lineNumber: 1189,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n                lineNumber: 1179,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/charles-henrynoah/Desktop/eidos/Eidos/components/Canvas3DVisualization.tsx\",\n        lineNumber: 1136,\n        columnNumber: 5\n    }, this);\n}\n_s(Canvas3DVisualization, \"eO0E6itovXilb3IAoe61XKZZfX8=\");\n_c = Canvas3DVisualization;\nvar _c;\n$RefreshReg$(_c, \"Canvas3DVisualization\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQ2FudmFzM0RWaXN1YWxpemF0aW9uLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDQztBQW1DckMsU0FBU00sc0JBQXNCLEtBS2pCO1FBTGlCLEVBQzVDQyxJQUFJLEVBQ0pDLE9BQU8sRUFDUEMsaUJBQWlCLEVBQ2pCQyxlQUFlLEVBQ1ksR0FMaUI7O0lBTTVDLE1BQU1DLFVBQVVWLDZDQUFNQSxDQUFpQjtJQUN2QyxNQUFNLENBQUNXLGVBQWVDLGlCQUFpQixHQUFHWCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNZLGNBQWNDLGdCQUFnQixHQUFHYiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNjLGFBQWFDLGVBQWUsR0FBR2YsK0NBQVFBLENBQXFCO0lBQ25FLE1BQU0sQ0FBQ2dCLGNBQWNDLGdCQUFnQixHQUFHakIsK0NBQVFBLENBQVM7SUFDekQsTUFBTSxDQUFDa0IsY0FBY0MsZ0JBQWdCLEdBQUduQiwrQ0FBUUEsQ0FBc0I7SUFFdEUsb0JBQW9CO0lBQ3BCRixnREFBU0EsQ0FBQztRQUNSLElBQUksS0FBNkIsSUFBSSxDQUFDc0IsT0FBT0MsTUFBTSxFQUFFO1lBQ25ELE1BQU1DLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztZQUN0Q0YsT0FBT0csR0FBRyxHQUFHO1lBQ2JILE9BQU9JLE1BQU0sR0FBRyxJQUFNYixnQkFBZ0I7WUFDdENTLE9BQU9LLE9BQU8sR0FBRztnQkFDZkMsUUFBUUMsS0FBSyxDQUFDO2dCQUNkaEIsZ0JBQWdCO1lBQ2xCO1lBQ0FVLFNBQVNPLElBQUksQ0FBQ0MsV0FBVyxDQUFDVDtRQUM1QixPQUFPLElBQUlGLE9BQU9DLE1BQU0sRUFBRTtZQUN4QlIsZ0JBQWdCO1FBQ2xCO0lBQ0YsR0FBRyxFQUFFO0lBRUxmLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDYyxnQkFBZ0IsQ0FBQ0gsUUFBUXVCLE9BQU8sRUFBRTtRQUV2QyxNQUFNQyxzQkFBc0I7WUFDMUIsTUFBTUMsY0FBY3pCLFFBQVF1QixPQUFPO1lBQ25DLElBQUksQ0FBQ0UsYUFBYTtZQUVsQixrQ0FBa0M7WUFDbEMsSUFBSUEsWUFBWUMsUUFBUSxDQUFDQyxNQUFNLEdBQUcsR0FBRztnQkFDbkNoQixPQUFPQyxNQUFNLENBQUNnQixLQUFLLENBQUNIO1lBQ3RCO1lBRUFqQixnQkFBZ0JWO1lBRWhCLElBQUk7Z0JBQ0YsSUFBSUMsaUJBQWlCO29CQUNuQixNQUFNOEIsc0JBQXNCOUI7b0JBQzVCRyxpQkFBaUI7Z0JBQ25CLE9BQU87b0JBQ0wsTUFBTTRCO29CQUNONUIsaUJBQWlCO2dCQUNuQjtZQUNGLEVBQUUsT0FBT2tCLE9BQU87Z0JBQ2RELFFBQVFDLEtBQUssQ0FBQyx5REFBc0RBO2dCQUNwRSx5REFBeUQ7Z0JBQ3pEVyxxQkFBcUJDLDhCQUE4QjtvQkFDakRDLFNBQVM7d0JBQ1BDLE9BQU9yQyxPQUFPLENBQUMsRUFBRSxJQUFJO3dCQUNyQnNDLE9BQU90QyxPQUFPLENBQUMsRUFBRSxJQUFJO3dCQUNyQnVDLE9BQU92QyxPQUFPLENBQUMsRUFBRSxJQUFJO3dCQUNyQndDLFNBQVN4QyxPQUFPLENBQUMsRUFBRSxJQUFJO3dCQUN2QnlDLFFBQVF6QyxPQUFPLENBQUMsRUFBRSxJQUFJO29CQUN4QjtvQkFDQTBDLGdCQUFnQjFDO29CQUNoQjJDLG9CQUFvQixFQUFFO29CQUN0QkMsaUJBQWlCLEVBQUU7b0JBQ25CQyxZQUFZLENBQUM7b0JBQ2JDLFlBQVksQ0FBQztvQkFDYkMsV0FBVyxDQUFDO2dCQUNkO1lBQ0Y7UUFDRjtRQUVBcEI7SUFDRixHQUFHO1FBQUNyQjtRQUFjUDtRQUFNQztRQUFTQztRQUFtQkM7S0FBZ0I7SUFFcEUsK0NBQStDO0lBQy9DLE1BQU1pQywyQkFBMkI7UUFDL0IsSUFBSSxDQUFDcEMsUUFBUUEsS0FBSytCLE1BQU0sS0FBSyxLQUFLLENBQUM5QixXQUFXQSxRQUFROEIsTUFBTSxLQUFLLEdBQUc7WUFDbEUsT0FBTztRQUNUO1FBRUEsTUFBTWtCLFdBQXlCO1lBQzdCWixTQUFTLENBQUM7WUFDVk0sZ0JBQWdCLEVBQUU7WUFDbEJDLG9CQUFvQixFQUFFO1lBQ3RCQyxpQkFBaUIsRUFBRTtZQUNuQkMsWUFBWSxDQUFDO1lBQ2JDLFlBQVksQ0FBQztZQUNiQyxXQUFXLENBQUM7UUFDZDtRQUVBLG9DQUFvQztRQUNwQy9DLFFBQVFpRCxPQUFPLENBQUMsQ0FBQ0M7WUFDZixNQUFNQyxTQUFTcEQsS0FBS3FELEdBQUcsQ0FBQyxDQUFDQyxNQUFRQSxHQUFHLENBQUNILElBQUksRUFBRUksTUFBTSxDQUFDLENBQUNDLE1BQVFBLE9BQU8sUUFBUUEsUUFBUTtZQUVsRixJQUFJSixPQUFPckIsTUFBTSxLQUFLLEdBQUc7Z0JBQ3ZCa0IsU0FBU0QsU0FBUyxDQUFDRyxJQUFJLEdBQUc7Z0JBQzFCO1lBQ0Y7WUFFQSxpQkFBaUI7WUFDakIsTUFBTU0sZ0JBQWdCTCxPQUFPQyxHQUFHLENBQUMsQ0FBQ0csTUFBUUUsT0FBT0MsVUFBVSxDQUFDSCxNQUFNRCxNQUFNLENBQUMsQ0FBQ0MsTUFBUSxDQUFDSSxNQUFNSixRQUFRSyxTQUFTTDtZQUMxRyxNQUFNTSxlQUFlTCxjQUFjMUIsTUFBTSxHQUFHcUIsT0FBT3JCLE1BQU07WUFFekQsZ0JBQWdCO1lBQ2hCLE1BQU1nQyxhQUFhWCxPQUFPRyxNQUFNLENBQUMsQ0FBQ0M7Z0JBQ2hDLE1BQU1RLE9BQU8sSUFBSUMsS0FBS1Q7Z0JBQ3RCLE9BQU8sQ0FBQ0ksTUFBTUksS0FBS0UsT0FBTyxPQUFPRixLQUFLRyxXQUFXLEtBQUssUUFBUUgsS0FBS0csV0FBVyxLQUFLO1lBQ3JGO1lBQ0EsTUFBTUMsZ0JBQWdCTCxXQUFXaEMsTUFBTSxHQUFHcUIsT0FBT3JCLE1BQU07WUFFdkQsa0JBQWtCO1lBQ2xCLE1BQU1zQyxlQUFlO21CQUFJLElBQUlDLElBQUlsQjthQUFRO1lBQ3pDLE1BQU1tQixjQUFjRixhQUFhdEMsTUFBTSxHQUFHcUIsT0FBT3JCLE1BQU07WUFFdkQsOEJBQThCO1lBQzlCLElBQUlxQyxnQkFBZ0IsS0FBSztnQkFDdkJuQixTQUFTRCxTQUFTLENBQUNHLElBQUksR0FBRztnQkFDMUJGLFNBQVNKLGVBQWUsQ0FBQzJCLElBQUksQ0FBQ3JCO2dCQUM5QiwyQ0FBMkM7Z0JBQzNDLE1BQU1zQixhQUFhVixXQUFXVixHQUFHLENBQUMsQ0FBQ0csTUFBUSxJQUFJUyxLQUFLVCxLQUFLVSxPQUFPO2dCQUNoRWpCLFNBQVNILFVBQVUsQ0FBQ0ssSUFBSSxHQUFHO29CQUN6QnVCLEtBQUtDLEtBQUtELEdBQUcsSUFBSUQ7b0JBQ2pCRyxLQUFLRCxLQUFLQyxHQUFHLElBQUlIO29CQUNqQnJCLFFBQVFxQjtnQkFDVjtZQUNGLE9BQU8sSUFBSVgsZUFBZSxLQUFLO2dCQUM3QmIsU0FBU0QsU0FBUyxDQUFDRyxJQUFJLEdBQUc7Z0JBQzFCRixTQUFTTixjQUFjLENBQUM2QixJQUFJLENBQUNyQjtnQkFDN0JGLFNBQVNILFVBQVUsQ0FBQ0ssSUFBSSxHQUFHO29CQUN6QnVCLEtBQUtDLEtBQUtELEdBQUcsSUFBSWpCO29CQUNqQm1CLEtBQUtELEtBQUtDLEdBQUcsSUFBSW5CO29CQUNqQkwsUUFBUUs7Z0JBQ1Y7WUFDRixPQUFPLElBQUljLGNBQWMsT0FBT0YsYUFBYXRDLE1BQU0sSUFBSSxJQUFJO2dCQUN6RGtCLFNBQVNELFNBQVMsQ0FBQ0csSUFBSSxHQUFHO2dCQUMxQkYsU0FBU0wsa0JBQWtCLENBQUM0QixJQUFJLENBQUNyQjtnQkFDakNGLFNBQVNGLFVBQVUsQ0FBQ0ksSUFBSSxHQUFHa0IsYUFBYVEsS0FBSyxDQUFDLEdBQUcsSUFBSSwwQkFBMEI7O1lBQ2pGLE9BQU87Z0JBQ0w1QixTQUFTRCxTQUFTLENBQUNHLElBQUksR0FBRztnQkFDMUIsSUFBSU0sY0FBYzFCLE1BQU0sR0FBRyxHQUFHO29CQUM1QmtCLFNBQVNILFVBQVUsQ0FBQ0ssSUFBSSxHQUFHO3dCQUN6QnVCLEtBQUtDLEtBQUtELEdBQUcsSUFBSWpCO3dCQUNqQm1CLEtBQUtELEtBQUtDLEdBQUcsSUFBSW5CO3dCQUNqQkwsUUFBUUs7b0JBQ1Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsNkRBQTZEO1FBQzdELE1BQU1xQixpQkFBaUI7ZUFBSTdCLFNBQVNOLGNBQWM7ZUFBS00sU0FBU0osZUFBZTtTQUFDO1FBRWhGLElBQUlpQyxlQUFlL0MsTUFBTSxJQUFJLEdBQUc7WUFDOUJrQixTQUFTWixPQUFPLEdBQUc7Z0JBQ2pCQyxPQUFPd0MsY0FBYyxDQUFDLEVBQUU7Z0JBQ3hCdkMsT0FBT3VDLGNBQWMsQ0FBQyxFQUFFO2dCQUN4QnRDLE9BQU9zQyxjQUFjLENBQUMsRUFBRTtnQkFDeEJyQyxTQUFTcUMsY0FBYyxDQUFDLEVBQUU7Z0JBQzFCcEMsUUFBUW9DLGVBQWUvQyxNQUFNLEdBQUcsSUFBSStDLGNBQWMsQ0FBQyxFQUFFLEdBQUdBLGNBQWMsQ0FBQyxFQUFFO2dCQUN6RUMsWUFBWTlCLFNBQVNMLGtCQUFrQixDQUFDLEVBQUU7WUFDNUM7UUFDRixPQUFPLElBQUlrQyxlQUFlL0MsTUFBTSxLQUFLLEdBQUc7WUFDdENrQixTQUFTWixPQUFPLEdBQUc7Z0JBQ2pCQyxPQUFPd0MsY0FBYyxDQUFDLEVBQUU7Z0JBQ3hCdkMsT0FBT3VDLGNBQWMsQ0FBQyxFQUFFO2dCQUN4QnRDLE9BQU9zQyxjQUFjLENBQUMsRUFBRTtnQkFDeEJyQyxTQUFTcUMsY0FBYyxDQUFDLEVBQUU7Z0JBQzFCcEMsUUFBUW9DLGNBQWMsQ0FBQyxFQUFFO2dCQUN6QkMsWUFBWTlCLFNBQVNMLGtCQUFrQixDQUFDLEVBQUU7WUFDNUM7UUFDRixPQUFPLElBQUlrQyxlQUFlL0MsTUFBTSxLQUFLLEdBQUc7WUFDdENrQixTQUFTWixPQUFPLEdBQUc7Z0JBQ2pCQyxPQUFPd0MsY0FBYyxDQUFDLEVBQUU7Z0JBQ3hCdkMsT0FBTztnQkFDUEMsT0FBT3NDLGNBQWMsQ0FBQyxFQUFFO2dCQUN4QnJDLFNBQVNxQyxjQUFjLENBQUMsRUFBRTtnQkFDMUJwQyxRQUFRb0MsY0FBYyxDQUFDLEVBQUU7Z0JBQ3pCQyxZQUFZOUIsU0FBU0wsa0JBQWtCLENBQUMsRUFBRTtZQUM1QztRQUNGLE9BQU87WUFDTCxxQ0FBcUM7WUFDckNLLFNBQVNaLE9BQU8sR0FBRztnQkFDakJDLE9BQU87Z0JBQ1BDLE9BQU9VLFNBQVNMLGtCQUFrQixDQUFDLEVBQUUsSUFBSTtnQkFDekNKLE9BQU87Z0JBQ1BDLFNBQVNRLFNBQVNMLGtCQUFrQixDQUFDLEVBQUUsSUFBSTtnQkFDM0NGLFFBQVE7Z0JBQ1JxQyxZQUFZOUIsU0FBU0wsa0JBQWtCLENBQUMsRUFBRTtZQUM1QztRQUNGO1FBRUEsT0FBT0s7SUFDVDtJQUVBLDRFQUE0RTtJQUM1RSxNQUFNZixtQ0FBbUM7UUFDdkMsSUFBSSxDQUFDbEMsUUFBUUEsS0FBSytCLE1BQU0sS0FBSyxHQUFHO1lBQzlCaUQ7WUFDQTtRQUNGO1FBRUEsTUFBTS9CLFdBQVdiO1FBQ2pCLElBQUksQ0FBQ2EsVUFBVTtZQUNiK0I7WUFDQTtRQUNGO1FBRUFsRSxnQkFBZ0JtQztRQUNoQnZDLGVBQWV1QyxTQUFTWixPQUFPO1FBRS9CLDREQUE0RDtRQUM1RCxPQUFRbkM7WUFDTixTQUFTO1lBQ1QsS0FBSztnQkFDSGlDLHFCQUFxQmM7Z0JBQ3JCO1lBQ0YsS0FBSztnQkFDSGdDLG9CQUFvQmhDO2dCQUNwQjtZQUNGLEtBQUs7Z0JBQ0hpQyxzQkFBc0JqQztnQkFDdEI7WUFDRixLQUFLO2dCQUNIa0MsdUJBQXVCbEM7Z0JBQ3ZCO1lBQ0YsS0FBSztnQkFDSG1DLHFCQUFxQm5DO2dCQUNyQjtZQUVGLFdBQVc7WUFDWCxLQUFLO2dCQUNIb0MscUJBQXFCcEM7Z0JBQ3JCO1lBQ0YsS0FBSztnQkFDSHFDLHFCQUFxQnJDO2dCQUNyQjtZQUNGLEtBQUs7Z0JBQ0hzQyxrQkFBa0J0QztnQkFDbEI7WUFDRixLQUFLO2dCQUNIdUMsc0JBQXNCdkM7Z0JBQ3RCO1lBRUYsZUFBZTtZQUNmLEtBQUs7Z0JBQ0h3QyxrQkFBa0J4QztnQkFDbEI7WUFDRixLQUFLO2dCQUNIeUMsa0JBQWtCekM7Z0JBQ2xCO1lBQ0YsS0FBSztnQkFDSDBDLHNCQUFzQjFDO2dCQUN0QjtZQUNGLEtBQUs7Z0JBQ0gyQyxrQkFBa0IzQztnQkFDbEI7WUFFRixlQUFlO1lBQ2YsS0FBSztnQkFDSDRDLGlCQUFpQjVDO2dCQUNqQjtZQUNGLEtBQUs7Z0JBQ0g2QyxpQkFBaUI3QztnQkFDakI7WUFDRixLQUFLO2dCQUNIOEMsZ0JBQWdCOUM7Z0JBQ2hCO1lBQ0YsS0FBSztnQkFDSCtDLGtCQUFrQi9DO2dCQUNsQjtZQUVGLGNBQWM7WUFDZCxLQUFLO2dCQUNIZ0QsZ0JBQWdCaEQ7Z0JBQ2hCO1lBQ0YsS0FBSztnQkFDSGlELGdCQUFnQmpEO2dCQUNoQjtZQUNGLEtBQUs7Z0JBQ0hrRCxnQkFBZ0JsRDtnQkFDaEI7WUFDRixLQUFLO2dCQUNIbUQsZUFBZW5EO2dCQUNmO1lBQ0YsS0FBSztnQkFDSG9ELGVBQWVwRDtnQkFDZjtZQUVGLFVBQVU7WUFDVixLQUFLO2dCQUNIcUQsZ0JBQWdCckQ7Z0JBQ2hCO1lBQ0YsS0FBSztnQkFDSHNELGFBQWF0RDtnQkFDYjtZQUVGLFlBQVk7WUFDWixLQUFLO2dCQUNIdUQsaUJBQWlCdkQ7Z0JBQ2pCO1lBQ0YsS0FBSztnQkFDSHdELG1CQUFtQnhEO2dCQUNuQjtZQUNGLEtBQUs7Z0JBQ0h5RCxpQkFBaUJ6RDtnQkFDakI7WUFFRixnQkFBZ0I7WUFDaEIsS0FBSztnQkFDSDBELGNBQWMxRDtnQkFDZDtZQUNGLEtBQUs7Z0JBQ0gyRCxnQkFBZ0IzRDtnQkFDaEI7WUFFRixnQkFBZ0I7WUFDaEIsS0FBSztnQkFDSDRELGlCQUFpQjVEO2dCQUNqQjtZQUNGLEtBQUs7Z0JBQ0g2RCxrQkFBa0I3RDtnQkFDbEI7WUFFRixlQUFlO1lBQ2YsS0FBSztnQkFDSDhELGtCQUFrQjlEO2dCQUNsQjtZQUNGLEtBQUs7Z0JBQ0grRCxnQkFBZ0IvRDtnQkFDaEI7WUFFRjtnQkFDRWQscUJBQXFCYztRQUN6QjtJQUNGO0lBRUEsK0RBQStEO0lBQy9ELE1BQU1nRSx3QkFBd0IsQ0FBQ2hFLFVBQXdCaUU7UUFDckQsTUFBTUMsU0FBU2xFLFNBQVNaLE9BQU8sQ0FBQzZFLElBQUk7UUFFcEMsSUFBSUMsV0FBVyxTQUFTO1lBQ3RCLE9BQU9uSCxLQUFLcUQsR0FBRyxDQUFDLENBQUMrRCxHQUFHQyxJQUFNQTtRQUM1QixPQUFPLElBQUlGLFdBQVcsU0FBUztZQUM3QixPQUFPbkgsS0FBS3FELEdBQUcsQ0FBQyxJQUFNO1FBQ3hCLE9BQU8sSUFBSThELFVBQVVsSCxRQUFRcUgsUUFBUSxDQUFDSCxTQUFTO1lBQzdDLElBQUlsRSxTQUFTSCxVQUFVLENBQUNxRSxPQUFPLEVBQUU7Z0JBQy9CLDhFQUE4RTtnQkFDOUUsTUFBTUksUUFBUXRFLFNBQVNILFVBQVUsQ0FBQ3FFLE9BQU87Z0JBQ3pDLE9BQU9uSCxLQUFLcUQsR0FBRyxDQUFDLENBQUNDLEtBQUsrRDtvQkFDcEIsTUFBTTdELE1BQU1GLEdBQUcsQ0FBQzZELE9BQU87b0JBQ3ZCLElBQUlsRSxTQUFTRCxTQUFTLENBQUNtRSxPQUFPLEtBQUssWUFBWTt3QkFDN0MsTUFBTUssWUFBWSxJQUFJdkQsS0FBS1QsS0FBS1UsT0FBTzt3QkFDdkMsT0FBT04sTUFBTTRELGFBQWFELE1BQU03QyxHQUFHLEdBQUc4QztvQkFDeEMsT0FBTzt3QkFDTCxNQUFNQyxTQUFTL0QsT0FBT0MsVUFBVSxDQUFDSDt3QkFDakMsT0FBTyxDQUFDSSxNQUFNNkQsV0FBVzVELFNBQVM0RCxVQUFVQSxTQUFTRixNQUFNN0MsR0FBRztvQkFDaEU7Z0JBQ0Y7WUFDRixPQUFPLElBQUl6QixTQUFTRixVQUFVLENBQUNvRSxPQUFPLEVBQUU7Z0JBQ3RDLGlEQUFpRDtnQkFDakQsTUFBTXBFLGFBQWFFLFNBQVNGLFVBQVUsQ0FBQ29FLE9BQU87Z0JBQzlDLE9BQU9uSCxLQUFLcUQsR0FBRyxDQUFDLENBQUNDO29CQUNmLE1BQU1FLE1BQU1GLEdBQUcsQ0FBQzZELE9BQU87b0JBQ3ZCLE1BQU1PLFFBQVEzRSxXQUFXNEUsT0FBTyxDQUFDbkU7b0JBQ2pDLE9BQU9rRSxTQUFTLElBQUlBLFFBQVE7Z0JBQzlCO1lBQ0Y7UUFDRjtRQUVBLE9BQU8xSCxLQUFLcUQsR0FBRyxDQUFDLENBQUMrRCxHQUFHQyxJQUFNQTtJQUM1QjtJQUVBLHNEQUFzRDtJQUV0RCwwQ0FBMEM7SUFDMUMsTUFBTWxGLHVCQUF1QixDQUFDYztRQUM1QixNQUFNMkUsVUFBVVgsc0JBQXNCaEUsVUFBVTtRQUNoRCxNQUFNNEUsVUFBVVosc0JBQXNCaEUsVUFBVTtRQUNoRCxNQUFNNkUsVUFBVWIsc0JBQXNCaEUsVUFBVTtRQUNoRCxNQUFNOEUsY0FBY2Qsc0JBQXNCaEUsVUFBVTtRQUVwRCwrREFBK0Q7UUFDL0QsTUFBTStFLGFBQWFyRCxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0QsR0FBRyxDQUFDLElBQUksTUFBTUMsS0FBS3NELElBQUksQ0FBQ2pJLEtBQUsrQixNQUFNO1FBRXZFLE1BQU1tRyxXQUFXO1lBQ2Y7Z0JBQ0VDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLEdBQUdUO2dCQUNIVSxHQUFHVDtnQkFDSFUsR0FBR1Q7Z0JBQ0hVLFFBQVE7b0JBQ05DLE1BQU1UO29CQUNOVSxPQUFPWDtvQkFDUFksWUFBWTtvQkFDWkMsU0FBU2pFLEtBQUtDLEdBQUcsQ0FBQyxLQUFLLElBQUk1RSxLQUFLK0IsTUFBTSxHQUFHO29CQUN6QzhHLFVBQVU7d0JBQ1JDLE9BQU83RixTQUFTWixPQUFPLENBQUNJLE9BQU87d0JBQy9Cc0csV0FBVzs0QkFBRU4sTUFBTTt3QkFBRztvQkFDeEI7Z0JBQ0Y7Z0JBQ0FPLE1BQU1oSixLQUFLcUQsR0FBRyxDQUFDLENBQUNDLEtBQUsrRDtvQkFDbkIsSUFBSTRCLFVBQVUsWUFBa0IsT0FBTjVCLElBQUksR0FBRTtvQkFDaEM0QixXQUFXLE1BQXFDM0YsT0FBL0JMLFNBQVNaLE9BQU8sQ0FBQ0MsS0FBSyxFQUFDLFVBQTZDLE9BQXJDZ0IsR0FBRyxDQUFDTCxTQUFTWixPQUFPLENBQUNDLEtBQUssQ0FBQyxJQUFJLE9BQU07b0JBQ3JGMkcsV0FBVyxNQUFxQzNGLE9BQS9CTCxTQUFTWixPQUFPLENBQUNFLEtBQUssRUFBQyxVQUE2QyxPQUFyQ2UsR0FBRyxDQUFDTCxTQUFTWixPQUFPLENBQUNFLEtBQUssQ0FBQyxJQUFJLE9BQU07b0JBQ3JGMEcsV0FBVyxNQUFxQzNGLE9BQS9CTCxTQUFTWixPQUFPLENBQUNHLEtBQUssRUFBQyxVQUE2QyxPQUFyQ2MsR0FBRyxDQUFDTCxTQUFTWixPQUFPLENBQUNHLEtBQUssQ0FBQyxJQUFJLE9BQU07b0JBQ3JGLElBQUlTLFNBQVNaLE9BQU8sQ0FBQzBDLFVBQVUsSUFBSXpCLEdBQUcsQ0FBQ0wsU0FBU1osT0FBTyxDQUFDMEMsVUFBVSxDQUFDLEVBQUU7d0JBQ25Fa0UsV0FBVyxNQUEwQzNGLE9BQXBDTCxTQUFTWixPQUFPLENBQUMwQyxVQUFVLEVBQUMsVUFBeUMsT0FBakN6QixHQUFHLENBQUNMLFNBQVNaLE9BQU8sQ0FBQzBDLFVBQVUsQ0FBQyxFQUFDO29CQUN4RjtvQkFDQSxPQUFPa0U7Z0JBQ1Q7Z0JBQ0FDLGVBQWU7Z0JBQ2ZDLE1BQU0sY0FBMEIsT0FBWm5KLEtBQUsrQixNQUFNLEVBQUM7WUFDbEM7U0FDRDtRQUVELE1BQU1xSCxTQUFTQyxvQkFBb0Isc0JBQXNCcEc7UUFDekRsQyxPQUFPQyxNQUFNLENBQUNzSSxPQUFPLENBQUNsSixRQUFRdUIsT0FBTyxFQUFFdUcsVUFBVWtCLFFBQVFHO0lBQzNEO0lBRUEsOERBQThEO0lBQzlELE1BQU1uRSx1QkFBdUIsQ0FBQ25DO1FBQzVCLE1BQU0yRSxVQUFVWCxzQkFBc0JoRSxVQUFVO1FBQ2hELE1BQU00RSxVQUFVWixzQkFBc0JoRSxVQUFVO1FBQ2hELE1BQU02RSxVQUFVYixzQkFBc0JoRSxVQUFVO1FBRWhELGdFQUFnRTtRQUNoRSxNQUFNdUcsV0FBVzdFLEtBQUtELEdBQUcsQ0FBQyxJQUFJQyxLQUFLQyxHQUFHLENBQUMsSUFBSUQsS0FBS3NELElBQUksQ0FBQ2pJLEtBQUsrQixNQUFNO1FBRWhFLE1BQU0wSCxTQUFTeEcsU0FBU0gsVUFBVSxDQUFDRyxTQUFTWixPQUFPLENBQUNDLEtBQUssQ0FBQztRQUMxRCxNQUFNb0gsU0FBU3pHLFNBQVNILFVBQVUsQ0FBQ0csU0FBU1osT0FBTyxDQUFDRSxLQUFLLENBQUM7UUFDMUQsTUFBTW9ILFNBQVMxRyxTQUFTSCxVQUFVLENBQUNHLFNBQVNaLE9BQU8sQ0FBQ0csS0FBSyxDQUFDO1FBRTFELElBQUksQ0FBQ2lILFVBQVUsQ0FBQ0MsVUFBVSxDQUFDQyxRQUFRO1lBQ2pDeEgscUJBQXFCYztZQUNyQjtRQUNGO1FBRUEsTUFBTTJHLFdBQVcsRUFBRTtRQUNuQixNQUFNQyxXQUFXLEVBQUU7UUFDbkIsTUFBTUMsV0FBVyxFQUFFO1FBQ25CLE1BQU1DLGdCQUFnQixFQUFFO1FBQ3hCLE1BQU1DLGVBQWUsRUFBRTtRQUV2QiwwREFBMEQ7UUFDMUQsTUFBTUMsUUFBUVIsT0FBTzdFLEdBQUcsR0FBRzZFLE9BQU8vRSxHQUFHO1FBQ3JDLE1BQU13RixRQUFRUixPQUFPOUUsR0FBRyxHQUFHOEUsT0FBT2hGLEdBQUc7UUFDckMsTUFBTXlGLFFBQVFSLE9BQU8vRSxHQUFHLEdBQUcrRSxPQUFPakYsR0FBRztRQUNyQyxNQUFNMEYsU0FBU3pGLEtBQUtDLEdBQUcsQ0FBQ3FGLE9BQU9DLE9BQU9DLFNBQVVYLENBQUFBLFdBQVcsR0FBRTtRQUU3RCxJQUFLLElBQUluQyxJQUFJLEdBQUdBLElBQUltQyxVQUFVbkMsSUFBSztZQUNqQyxJQUFLLElBQUlnRCxJQUFJLEdBQUdBLElBQUliLFVBQVVhLElBQUs7Z0JBQ2pDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJZCxVQUFVYyxJQUFLO29CQUNqQyxNQUFNakMsSUFBSW9CLE9BQU8vRSxHQUFHLEdBQUcsSUFBTThFLENBQUFBLFdBQVcsS0FBTVM7b0JBQzlDLE1BQU0zQixJQUFJb0IsT0FBT2hGLEdBQUcsR0FBRyxJQUFNOEUsQ0FBQUEsV0FBVyxLQUFNVTtvQkFDOUMsTUFBTTNCLElBQUlvQixPQUFPakYsR0FBRyxHQUFHLElBQU04RSxDQUFBQSxXQUFXLEtBQU1XO29CQUU5QyxxREFBcUQ7b0JBQ3JELElBQUlJLFVBQVU7b0JBQ2QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUl4SyxLQUFLK0IsTUFBTSxFQUFFeUksSUFBSzt3QkFDcEMsTUFBTUMsS0FBSzdDLE9BQU8sQ0FBQzRDLEVBQUUsR0FBR25DO3dCQUN4QixNQUFNcUMsS0FBSzdDLE9BQU8sQ0FBQzJDLEVBQUUsR0FBR2xDO3dCQUN4QixNQUFNcUMsS0FBSzdDLE9BQU8sQ0FBQzBDLEVBQUUsR0FBR2pDO3dCQUN4QixNQUFNcUMsV0FBV2pHLEtBQUtzRCxJQUFJLENBQUN3QyxLQUFLQSxLQUFLQyxLQUFLQSxLQUFLQyxLQUFLQTt3QkFDcEQsSUFBSUMsV0FBV1IsUUFBUTs0QkFDckJHLFdBQVc1RixLQUFLa0csR0FBRyxDQUFDLENBQUVELENBQUFBLFdBQVdBLFFBQU8sSUFBTVIsQ0FBQUEsU0FBU0EsTUFBSzt3QkFDOUQ7b0JBQ0Y7b0JBRUEsOENBQThDO29CQUM5QyxNQUFNVSxZQUFZLEtBQU0vSSxNQUFNLEdBQUl5SCxDQUFBQSxXQUFXQSxXQUFXQSxRQUFPLElBQU07b0JBQ3JFLElBQUllLFVBQVVPLFdBQVc7d0JBQ3ZCbEIsU0FBU3BGLElBQUksQ0FBQzZEO3dCQUNkd0IsU0FBU3JGLElBQUksQ0FBQzhEO3dCQUNkd0IsU0FBU3RGLElBQUksQ0FBQytEO3dCQUNkd0IsY0FBY3ZGLElBQUksQ0FBQytGO3dCQUNuQlAsYUFBYXhGLElBQUksQ0FBQ0csS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtELEdBQUcsQ0FBQyxJQUFJNkYsVUFBVTtvQkFDdkQ7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsTUFBTXJDLFdBQVc7WUFDZjtnQkFDRUMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsR0FBR3VCO2dCQUNIdEIsR0FBR3VCO2dCQUNIdEIsR0FBR3VCO2dCQUNIdEIsUUFBUTtvQkFDTkMsTUFBTXVCO29CQUNOdEIsT0FBT3FCO29CQUNQcEIsWUFBWTtvQkFDWkMsU0FBUztvQkFDVEMsVUFBVTt3QkFDUkMsT0FBTzt3QkFDUEMsV0FBVzs0QkFBRU4sTUFBTTt3QkFBRztvQkFDeEI7Z0JBQ0Y7Z0JBQ0FPLE1BQU1ZLFNBQVN2RyxHQUFHLENBQ2hCLENBQUMrRCxHQUFHQyxJQUNGLGlCQUEwQzBDLE9BQXpCMUMsSUFBSSxHQUFFLHdCQUFnRXVDLE9BQTdDRyxhQUFhLENBQUMxQyxFQUFFLENBQUMwRCxPQUFPLENBQUMsSUFBRyxtQkFBNENsQixPQUEzQkQsUUFBUSxDQUFDdkMsRUFBRSxDQUFDMEQsT0FBTyxDQUFDLElBQUcsTUFBK0JqQixPQUEzQkQsUUFBUSxDQUFDeEMsRUFBRSxDQUFDMEQsT0FBTyxDQUFDLElBQUcsTUFBMkIsT0FBdkJqQixRQUFRLENBQUN6QyxFQUFFLENBQUMwRCxPQUFPLENBQUMsSUFBRztnQkFFeEs3QixlQUFlO2dCQUNmQyxNQUFNLG1CQUFnQyxPQUFoQlMsU0FBUzdILE1BQU0sRUFBQztZQUN4QztTQUNEO1FBRUQsTUFBTXFILFNBQVNDLG9CQUFvQiwwQ0FBdUNwRztRQUMxRWxDLE9BQU9DLE1BQU0sQ0FBQ3NJLE9BQU8sQ0FBQ2xKLFFBQVF1QixPQUFPLEVBQUV1RyxVQUFVa0IsUUFBUUc7SUFDM0Q7SUFFQSwrREFBK0Q7SUFDL0QsTUFBTXRFLHNCQUFzQixDQUFDaEM7UUFDM0IsTUFBTTJFLFVBQVVYLHNCQUFzQmhFLFVBQVU7UUFDaEQsTUFBTTRFLFVBQVVaLHNCQUFzQmhFLFVBQVU7UUFDaEQsTUFBTTZFLFVBQVViLHNCQUFzQmhFLFVBQVU7UUFDaEQsTUFBTThFLGNBQWNkLHNCQUFzQmhFLFVBQVU7UUFDcEQsTUFBTStILGFBQWEvRCxzQkFBc0JoRSxVQUFVO1FBRW5ELGlEQUFpRDtRQUNqRCxNQUFNZ0ksVUFBVTtRQUNoQixNQUFNQyxVQUFVO1FBQ2hCLE1BQU1DLGtCQUFrQkgsV0FBVzNILEdBQUcsQ0FBQytILENBQUFBO1lBQ3JDLE1BQU0xRyxNQUFNQyxLQUFLRCxHQUFHLElBQUlzRztZQUN4QixNQUFNcEcsTUFBTUQsS0FBS0MsR0FBRyxJQUFJb0c7WUFDeEIsT0FBT0MsVUFBVSxDQUFFRyxJQUFJMUcsR0FBRSxJQUFNRSxDQUFBQSxNQUFNRixHQUFFLElBQU93RyxDQUFBQSxVQUFVRCxPQUFNO1FBQ2hFO1FBRUEsTUFBTS9DLFdBQVc7WUFDZjtnQkFDRUMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsR0FBR1Q7Z0JBQ0hVLEdBQUdUO2dCQUNIVSxHQUFHVDtnQkFDSFUsUUFBUTtvQkFDTkMsTUFBTTBDO29CQUNOekMsT0FBT1g7b0JBQ1BZLFlBQVk7b0JBQ1pDLFNBQVM7b0JBQ1RDLFVBQVU7d0JBQ1JDLE9BQU83RixTQUFTWixPQUFPLENBQUNJLE9BQU87d0JBQy9Cc0csV0FBVzs0QkFBRU4sTUFBTTt3QkFBRztvQkFDeEI7b0JBQ0E0QyxNQUFNO3dCQUFFM0MsT0FBTzt3QkFBNEI0QyxPQUFPO29CQUFFO2dCQUN0RDtnQkFDQXRDLE1BQU1oSixLQUFLcUQsR0FBRyxDQUFDLENBQUNDLEtBQUsrRDtvQkFDbkIsSUFBSTRCLFVBQVUsWUFBa0IsT0FBTjVCLElBQUksR0FBRTtvQkFDaEM0QixXQUFXLGNBQStDM0YsT0FBakNMLFNBQVNaLE9BQU8sQ0FBQ0ssTUFBTSxFQUFDLFdBQStDLE9BQXRDWSxHQUFHLENBQUNMLFNBQVNaLE9BQU8sQ0FBQ0ssTUFBTSxDQUFDLElBQUksT0FBTTtvQkFDaEd1RyxXQUFXLGVBQWlEM0YsT0FBbENMLFNBQVNaLE9BQU8sQ0FBQ0ksT0FBTyxFQUFDLFdBQWdELE9BQXZDYSxHQUFHLENBQUNMLFNBQVNaLE9BQU8sQ0FBQ0ksT0FBTyxDQUFDLElBQUksT0FBTTtvQkFDbkcsSUFBSVEsU0FBU1osT0FBTyxDQUFDMEMsVUFBVSxJQUFJekIsR0FBRyxDQUFDTCxTQUFTWixPQUFPLENBQUMwQyxVQUFVLENBQUMsRUFBRTt3QkFDbkVrRSxXQUFXLHdCQUFzRCxPQUFqQzNGLEdBQUcsQ0FBQ0wsU0FBU1osT0FBTyxDQUFDMEMsVUFBVSxDQUFDLEVBQUM7b0JBQ25FO29CQUNBLE9BQU9rRTtnQkFDVDtnQkFDQUMsZUFBZTtnQkFDZkMsTUFBTSxlQUEyQixPQUFabkosS0FBSytCLE1BQU0sRUFBQztZQUNuQztTQUNEO1FBRUQsTUFBTXFILFNBQVNDLG9CQUFvQix3Q0FBd0NwRztRQUMzRWxDLE9BQU9DLE1BQU0sQ0FBQ3NJLE9BQU8sQ0FBQ2xKLFFBQVF1QixPQUFPLEVBQUV1RyxVQUFVa0IsUUFBUUc7SUFDM0Q7SUFFQSxvREFBb0Q7SUFDcEQsTUFBTXRELGtCQUFrQixDQUFDaEQ7UUFDdkIsTUFBTThFLGNBQWNkLHNCQUFzQmhFLFVBQVU7UUFDcEQsTUFBTStILGFBQWEvRCxzQkFBc0JoRSxVQUFVO1FBRW5ELE1BQU1zSSxXQUFXLEVBQUU7UUFDbkIsTUFBTUMsV0FBVyxFQUFFO1FBQ25CLE1BQU1DLFdBQVcsRUFBRTtRQUNuQixNQUFNQyxnQkFBZ0IsRUFBRTtRQUN4QixNQUFNQyxlQUFlLEVBQUU7UUFFdkIsc0RBQXNEO1FBQ3REM0wsS0FBS2tELE9BQU8sQ0FBQyxDQUFDSSxLQUFLK0Q7WUFDakIsTUFBTXVFLGtCQUFrQnZFLElBQUlySCxLQUFLK0IsTUFBTTtZQUN2QyxNQUFNOEosV0FBVzlELFdBQVcsQ0FBQ1YsRUFBRTtZQUMvQixNQUFNeUUsVUFBVWQsVUFBVSxDQUFDM0QsRUFBRTtZQUU3QixtREFBbUQ7WUFDbkQsTUFBTTBFLGFBQWE5SSxTQUFTSCxVQUFVLENBQUNHLFNBQVNaLE9BQU8sQ0FBQ0ksT0FBTyxDQUFDO1lBQ2hFLE1BQU11SixRQUFRRCxhQUFhLElBQUksQ0FBRUYsV0FBV0UsV0FBV3JILEdBQUcsSUFBS3FILENBQUFBLFdBQVduSCxHQUFHLEdBQUdtSCxXQUFXckgsR0FBRyxJQUFLLElBQUk7WUFFdkcsTUFBTXVILFFBQVFMLGtCQUFrQkksUUFBUXJILEtBQUt1SCxFQUFFO1lBQy9DLE1BQU05QixTQUFTLElBQUl6RixLQUFLd0gsR0FBRyxDQUFDRixRQUFRLEtBQUs7WUFDekMsTUFBTUcsU0FBU3pILEtBQUt3SCxHQUFHLENBQUNGLFFBQVEsS0FBSztZQUVyQyxrQkFBa0I7WUFDbEJWLFNBQVMvRyxJQUFJLENBQUNHLEtBQUswSCxHQUFHLENBQUNKLFNBQVM3QjtZQUNoQ29CLFNBQVNoSCxJQUFJLENBQUNHLEtBQUt3SCxHQUFHLENBQUNGLFNBQVM3QjtZQUNoQ3FCLFNBQVNqSCxJQUFJLENBQUM0SDtZQUNkVixjQUFjbEgsSUFBSSxDQUFDcUg7WUFDbkJGLGFBQWFuSCxJQUFJLENBQUNHLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRCxHQUFHLENBQUMsR0FBRyxVQUFZcUgsQ0FBQUEsQ0FBQUEsdUJBQUFBLGlDQUFBQSxXQUFZbkgsR0FBRyxLQUFJLEtBQU0sSUFBSTtZQUVuRixtQ0FBbUM7WUFDbkMsTUFBTTBILFlBQ0pySixTQUFTWixPQUFPLENBQUMwQyxVQUFVLElBQUk5QixTQUFTRixVQUFVLENBQUNFLFNBQVNaLE9BQU8sQ0FBQzBDLFVBQVUsQ0FBQyxHQUMzRUosS0FBS0QsR0FBRyxDQUFDLEdBQUd6QixTQUFTRixVQUFVLENBQUNFLFNBQVNaLE9BQU8sQ0FBQzBDLFVBQVUsQ0FBQyxDQUFDaEQsTUFBTSxJQUNuRTtZQUVOLElBQUssSUFBSXNJLElBQUksR0FBR0EsSUFBSWlDLFdBQVdqQyxJQUFLO2dCQUNsQyxNQUFNa0MsYUFBYU4sUUFBUSxJQUFLLElBQUl0SCxLQUFLdUgsRUFBRSxHQUFJSTtnQkFDL0MsTUFBTUUsY0FBY3BDLFNBQVM7Z0JBQzdCbUIsU0FBUy9HLElBQUksQ0FBQ0csS0FBSzBILEdBQUcsQ0FBQ0osU0FBUzdCLFNBQVN6RixLQUFLMEgsR0FBRyxDQUFDRSxjQUFjQztnQkFDaEVoQixTQUFTaEgsSUFBSSxDQUFDRyxLQUFLd0gsR0FBRyxDQUFDRixTQUFTN0IsU0FBU3pGLEtBQUt3SCxHQUFHLENBQUNJLGNBQWNDO2dCQUNoRWYsU0FBU2pILElBQUksQ0FBQzRILFNBQVN6SCxLQUFLd0gsR0FBRyxDQUFDSSxhQUFhLEtBQUs7Z0JBQ2xEYixjQUFjbEgsSUFBSSxDQUFDcUgsV0FBVztnQkFDOUJGLGFBQWFuSCxJQUFJLENBQUNHLEtBQUtDLEdBQUcsQ0FBQyxHQUFHK0csWUFBWSxDQUFDQSxhQUFhNUosTUFBTSxHQUFHLEVBQUUsR0FBRztZQUN4RTtRQUNGO1FBRUEsTUFBTW1HLFdBQVc7WUFDZjtnQkFDRUMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsR0FBR2tEO2dCQUNIakQsR0FBR2tEO2dCQUNIakQsR0FBR2tEO2dCQUNIakQsUUFBUTtvQkFDTkMsTUFBTWtEO29CQUNOakQsT0FBT2dEO29CQUNQL0MsWUFBWTtvQkFDWkMsU0FBUztvQkFDVEMsVUFBVTt3QkFDUkMsT0FBTyxhQUFzQyxPQUF6QjdGLFNBQVNaLE9BQU8sQ0FBQ0ksT0FBTyxFQUFDO3dCQUM3Q3NHLFdBQVc7NEJBQUVOLE1BQU07d0JBQUc7b0JBQ3hCO2dCQUNGO2dCQUNBVSxNQUFNLGdCQUE0QixPQUFabkosS0FBSytCLE1BQU0sRUFBQztZQUNwQztTQUNEO1FBRUQsTUFBTXFILFNBQVNDLG9CQUFvQixpQ0FBOEJwRztRQUNqRW1HLE9BQU9xRCxLQUFLLENBQUNDLE1BQU0sR0FBRztZQUFFQyxLQUFLO2dCQUFFdEUsR0FBRztnQkFBR0MsR0FBRztnQkFBR0MsR0FBRztZQUFJO1FBQUU7UUFDcER4SCxPQUFPQyxNQUFNLENBQUNzSSxPQUFPLENBQUNsSixRQUFRdUIsT0FBTyxFQUFFdUcsVUFBVWtCLFFBQVFHO0lBQzNEO0lBRUEsa0RBQWtEO0lBQ2xELE1BQU1uRCxpQkFBaUIsQ0FBQ25EO1FBQ3RCLE1BQU04RSxjQUFjZCxzQkFBc0JoRSxVQUFVO1FBQ3BELE1BQU0rSCxhQUFhL0Qsc0JBQXNCaEUsVUFBVTtRQUVuRCxNQUFNMkosVUFBVSxFQUFFO1FBQ2xCLE1BQU1DLFVBQVUsRUFBRTtRQUNsQixNQUFNQyxVQUFVLEVBQUU7UUFDbEIsTUFBTUMsZUFBZSxFQUFFO1FBQ3ZCLE1BQU1DLGNBQWMsRUFBRTtRQUV0QiwyREFBMkQ7UUFDM0QsTUFBTWpCLGFBQWE5SSxTQUFTSCxVQUFVLENBQUNHLFNBQVNaLE9BQU8sQ0FBQ0ksT0FBTyxDQUFDO1FBQ2hFLE1BQU13SyxZQUFZaEssU0FBU0gsVUFBVSxDQUFDRyxTQUFTWixPQUFPLENBQUNLLE1BQU0sQ0FBQztRQUU5RDFDLEtBQUtrRCxPQUFPLENBQUMsQ0FBQ0ksS0FBSytEO1lBQ2pCLE1BQU02RixJQUFJN0YsSUFBSXJILEtBQUsrQixNQUFNO1lBQ3pCLE1BQU04SixXQUFXOUQsV0FBVyxDQUFDVixFQUFFO1lBQy9CLE1BQU15RSxVQUFVZCxVQUFVLENBQUMzRCxFQUFFO1lBRTdCLDZEQUE2RDtZQUM3RCxNQUFNOEYsa0JBQWtCcEIsYUFBYSxDQUFDRixXQUFXRSxXQUFXckgsR0FBRyxJQUFLcUgsQ0FBQUEsV0FBV25ILEdBQUcsR0FBR21ILFdBQVdySCxHQUFHLElBQUl3STtZQUN2RyxNQUFNRSxpQkFBaUJILFlBQVksQ0FBQ25CLFVBQVVtQixVQUFVdkksR0FBRyxJQUFLdUksQ0FBQUEsVUFBVXJJLEdBQUcsR0FBR3FJLFVBQVV2SSxHQUFHLElBQUk7WUFFakcsdUNBQXVDO1lBQ3ZDLE1BQU11SCxRQUFRa0Isa0JBQWtCLElBQUl4SSxLQUFLdUgsRUFBRSxHQUFHZ0IsSUFBSSxJQUFJdkksS0FBS3VILEVBQUU7WUFDN0QsTUFBTTlCLFNBQVNnRCxpQkFBaUIsSUFBSUYsSUFBSTtZQUN4QyxNQUFNZCxTQUFTLENBQUN6SCxLQUFLMEksTUFBTSxLQUFLLEdBQUUsSUFBSyxNQUFPLEtBQUlILEVBQUcsNkJBQTZCO1lBQWhDQTtZQUVsRCxpQkFBaUI7WUFDakJOLFFBQVFwSSxJQUFJLENBQUNHLEtBQUswSCxHQUFHLENBQUNKLFNBQVM3QjtZQUMvQnlDLFFBQVFySSxJQUFJLENBQUNHLEtBQUt3SCxHQUFHLENBQUNGLFNBQVM3QjtZQUMvQjBDLFFBQVF0SSxJQUFJLENBQUM0SDtZQUNiVyxhQUFhdkksSUFBSSxDQUFDcUg7WUFDbEJtQixZQUFZeEksSUFBSSxDQUFDRyxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0QsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJMEksY0FBYSxJQUFLLElBQUk7WUFFckUsc0NBQXNDO1lBQ3RDLElBQUlwTixLQUFLK0IsTUFBTSxHQUFHLElBQUk7Z0JBQ3BCLE1BQU11TCxTQUFTckIsUUFBUXRILEtBQUt1SCxFQUFFLEdBQUc7Z0JBQ2pDLE1BQU1xQixVQUFVbkQsU0FBUztnQkFDekJ3QyxRQUFRcEksSUFBSSxDQUFDRyxLQUFLMEgsR0FBRyxDQUFDaUIsVUFBVUM7Z0JBQ2hDVixRQUFRckksSUFBSSxDQUFDRyxLQUFLd0gsR0FBRyxDQUFDbUIsVUFBVUM7Z0JBQ2hDVCxRQUFRdEksSUFBSSxDQUFDNEgsU0FBUztnQkFDdEJXLGFBQWF2SSxJQUFJLENBQUNxSCxXQUFXO2dCQUM3Qm1CLFlBQVl4SSxJQUFJLENBQUNHLEtBQUtDLEdBQUcsQ0FBQyxHQUFHb0ksV0FBVyxDQUFDQSxZQUFZakwsTUFBTSxHQUFHLEVBQUUsR0FBRztZQUNyRTtRQUNGO1FBRUEsTUFBTW1HLFdBQVc7WUFDZjtnQkFDRUMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsR0FBR3VFO2dCQUNIdEUsR0FBR3VFO2dCQUNIdEUsR0FBR3VFO2dCQUNIdEUsUUFBUTtvQkFDTkMsTUFBTXVFO29CQUNOdEUsT0FBT3FFO29CQUNQcEUsWUFBWTtvQkFDWkMsU0FBUztvQkFDVEMsVUFBVTt3QkFDUkMsT0FBTyxrQkFBd0MsT0FBekI3RixTQUFTWixPQUFPLENBQUNJLE9BQU8sRUFBQzt3QkFDL0NzRyxXQUFXOzRCQUFFTixNQUFNO3dCQUFHO29CQUN4QjtnQkFDRjtnQkFDQVUsTUFBTSxnQkFBNEIsT0FBWm5KLEtBQUsrQixNQUFNLEVBQUM7WUFDcEM7U0FDRDtRQUVELE1BQU1xSCxTQUFTQyxvQkFBb0IsaUNBQWlDcEc7UUFDcEVtRyxPQUFPcUQsS0FBSyxDQUFDZSxPQUFPLEdBQUc7UUFDdkJwRSxPQUFPcUQsS0FBSyxDQUFDQyxNQUFNLEdBQUc7WUFBRUMsS0FBSztnQkFBRXRFLEdBQUc7Z0JBQUtDLEdBQUc7Z0JBQUtDLEdBQUc7WUFBRTtRQUFFO1FBQ3REeEgsT0FBT0MsTUFBTSxDQUFDc0ksT0FBTyxDQUFDbEosUUFBUXVCLE9BQU8sRUFBRXVHLFVBQVVrQixRQUFRRztJQUMzRDtJQUVBLDRDQUE0QztJQUM1QyxNQUFNL0MsbUJBQW1CLENBQUN2RDtRQUN4QixrQ0FBa0M7UUFDbEMsTUFBTXdLLGFBQWF4SyxTQUFTSixlQUFlLENBQUMsRUFBRSxJQUFJSSxTQUFTWixPQUFPLENBQUNDLEtBQUs7UUFDeEUsTUFBTW9MLGNBQWN6SyxTQUFTWixPQUFPLENBQUNFLEtBQUs7UUFDMUMsTUFBTW9MLGNBQWMxSyxTQUFTWixPQUFPLENBQUNJLE9BQU87UUFFNUMsTUFBTW1MLGFBQWEzRyxzQkFBc0JoRSxVQUFVO1FBQ25ELE1BQU1HLFNBQVM2RCxzQkFBc0JoRSxVQUFVO1FBQy9DLE1BQU04RSxjQUFjZCxzQkFBc0JoRSxVQUFVO1FBRXBELG9DQUFvQztRQUNwQyxNQUFNNEssZ0JBQWdCRCxXQUFXdkssR0FBRyxDQUFDLENBQUMrRCxHQUFHQyxJQUFNQSxHQUFHeUcsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1KLFVBQVUsQ0FBQ0csRUFBRSxHQUFHSCxVQUFVLENBQUNJLEVBQUU7UUFFOUYsTUFBTUMsWUFBWUosY0FBY3hLLEdBQUcsQ0FBQyxDQUFDZ0UsSUFBTXVHLFVBQVUsQ0FBQ3ZHLEVBQUU7UUFDeEQsTUFBTTZHLFlBQVlMLGNBQWN4SyxHQUFHLENBQUMsQ0FBQ2dFLElBQU1qRSxNQUFNLENBQUNpRSxFQUFFO1FBQ3BELE1BQU04RyxZQUFZTixjQUFjeEssR0FBRyxDQUFDLENBQUMrRCxHQUFHQyxJQUFNQSxJQUFJLEtBQUssd0JBQXdCOztRQUMvRSxNQUFNK0csaUJBQWlCUCxjQUFjeEssR0FBRyxDQUFDLENBQUNnRSxJQUFNVSxXQUFXLENBQUNWLEVBQUU7UUFFOUQsTUFBTWEsV0FBVztZQUNmO2dCQUNFQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOQyxHQUFHNEY7Z0JBQ0gzRixHQUFHNEY7Z0JBQ0gzRixHQUFHNEY7Z0JBQ0gzRixRQUFRO29CQUNOQyxNQUFNO29CQUNOQyxPQUFPMEY7b0JBQ1B6RixZQUFZO29CQUNaQyxTQUFTO29CQUNUQyxVQUFVO3dCQUNSQyxPQUFPN0YsU0FBU1osT0FBTyxDQUFDSSxPQUFPO3dCQUMvQnNHLFdBQVc7NEJBQUVOLE1BQU07d0JBQUc7b0JBQ3hCO2dCQUNGO2dCQUNBNEMsTUFBTTtvQkFDSjNDLE9BQU87b0JBQ1A0QyxPQUFPO2dCQUNUO2dCQUNBdEMsTUFBTTZFLGNBQWN4SyxHQUFHLENBQUMsQ0FBQ2dFO29CQUN2QixNQUFNL0QsTUFBTXRELElBQUksQ0FBQ3FILEVBQUU7b0JBQ25CLElBQUk0QixVQUFVLHFCQUEyQixPQUFONUIsSUFBSSxHQUFFO29CQUN6QzRCLFdBQVcsaUJBQTBDLE9BQXpCM0YsR0FBRyxDQUFDbUssV0FBVyxJQUFJLE9BQU07b0JBQ3JEeEUsV0FBVyxrQkFBNEMsT0FBMUIzRixHQUFHLENBQUNvSyxZQUFZLElBQUksT0FBTTtvQkFDdkQsT0FBT3pFO2dCQUNUO2dCQUNBQyxlQUFlO2dCQUNmQyxNQUFNLGlCQUE2QixPQUFabkosS0FBSytCLE1BQU0sRUFBQztZQUNyQztTQUNEO1FBRUQsTUFBTXFILFNBQVNDLG9CQUFvQix5Q0FBc0NwRztRQUN6RWxDLE9BQU9DLE1BQU0sQ0FBQ3NJLE9BQU8sQ0FBQ2xKLFFBQVF1QixPQUFPLEVBQUV1RyxVQUFVa0IsUUFBUUc7SUFDM0Q7SUFFQSx5REFBeUQ7SUFDekQsTUFBTXJFLHdCQUF3QixDQUFDakMsV0FBMkJkLHFCQUFxQmM7SUFDL0UsTUFBTWtDLHlCQUF5QixDQUFDbEMsV0FBMkJnQyxvQkFBb0JoQztJQUMvRSxNQUFNb0MsdUJBQXVCLENBQUNwQyxXQUEyQnFDLHFCQUFxQnJDO0lBQzlFLE1BQU1zQyxvQkFBb0IsQ0FBQ3RDLFdBQTJCcUMscUJBQXFCckM7SUFDM0UsTUFBTXVDLHdCQUF3QixDQUFDdkMsV0FBMkJxQyxxQkFBcUJyQztJQUMvRSxNQUFNd0Msb0JBQW9CLENBQUN4QyxXQUEyQmdDLG9CQUFvQmhDO0lBQzFFLE1BQU15QyxvQkFBb0IsQ0FBQ3pDLFdBQTJCZ0Msb0JBQW9CaEM7SUFDMUUsTUFBTTBDLHdCQUF3QixDQUFDMUMsV0FBMkJnQyxvQkFBb0JoQztJQUM5RSxNQUFNMkMsb0JBQW9CLENBQUMzQyxXQUEyQmdDLG9CQUFvQmhDO0lBQzFFLE1BQU00QyxtQkFBbUIsQ0FBQzVDLFdBQTJCZ0Msb0JBQW9CaEM7SUFDekUsTUFBTTZDLG1CQUFtQixDQUFDN0MsV0FBMkJkLHFCQUFxQmM7SUFDMUUsTUFBTThDLGtCQUFrQixDQUFDOUMsV0FBMkJkLHFCQUFxQmM7SUFDekUsTUFBTStDLG9CQUFvQixDQUFDL0MsV0FBMkJvRCxlQUFlcEQ7SUFDckUsTUFBTWlELGtCQUFrQixDQUFDakQsV0FBMkJnRCxnQkFBZ0JoRDtJQUNwRSxNQUFNa0Qsa0JBQWtCLENBQUNsRCxXQUEyQmQscUJBQXFCYztJQUN6RSxNQUFNcUQsa0JBQWtCLENBQUNyRCxXQUEyQmQscUJBQXFCYztJQUN6RSxNQUFNc0QsZUFBZSxDQUFDdEQsV0FBMkJkLHFCQUFxQmM7SUFDdEUsTUFBTXdELHFCQUFxQixDQUFDeEQsV0FBMkJ1RCxpQkFBaUJ2RDtJQUN4RSxNQUFNeUQsbUJBQW1CLENBQUN6RCxXQUEyQnVELGlCQUFpQnZEO0lBQ3RFLE1BQU0wRCxnQkFBZ0IsQ0FBQzFELFdBQTJCZCxxQkFBcUJjO0lBQ3ZFLE1BQU0yRCxrQkFBa0IsQ0FBQzNELFdBQTJCcUMscUJBQXFCckM7SUFDekUsTUFBTTRELG1CQUFtQixDQUFDNUQsV0FBMkJkLHFCQUFxQmM7SUFDMUUsTUFBTTZELG9CQUFvQixDQUFDN0QsV0FBMkJkLHFCQUFxQmM7SUFDM0UsTUFBTThELG9CQUFvQixDQUFDOUQsV0FBMkJnQyxvQkFBb0JoQztJQUMxRSxNQUFNK0Qsa0JBQWtCLENBQUMvRCxXQUEyQmdDLG9CQUFvQmhDO0lBRXhFLDBEQUEwRDtJQUMxRCxNQUFNcUMsdUJBQXVCLENBQUNyQztRQUM1QixNQUFNMkUsVUFBVVgsc0JBQXNCaEUsVUFBVTtRQUNoRCxNQUFNNEUsVUFBVVosc0JBQXNCaEUsVUFBVTtRQUNoRCxNQUFNNkUsVUFBVWIsc0JBQXNCaEUsVUFBVTtRQUVoRCxNQUFNd0csU0FBU3hHLFNBQVNILFVBQVUsQ0FBQ0csU0FBU1osT0FBTyxDQUFDQyxLQUFLLENBQUM7UUFDMUQsTUFBTW9ILFNBQVN6RyxTQUFTSCxVQUFVLENBQUNHLFNBQVNaLE9BQU8sQ0FBQ0UsS0FBSyxDQUFDO1FBRTFELElBQUksQ0FBQ2tILFVBQVUsQ0FBQ0MsUUFBUTtZQUN0QnZILHFCQUFxQmM7WUFDckI7UUFDRjtRQUVBLHFEQUFxRDtRQUNyRCxNQUFNd0YsT0FBTzlELEtBQUtELEdBQUcsQ0FBQyxJQUFJQyxLQUFLQyxHQUFHLENBQUMsSUFBSUQsS0FBS3NELElBQUksQ0FBQ2pJLEtBQUsrQixNQUFNO1FBQzVELE1BQU1zTSxPQUFPNUUsT0FBTy9FLEdBQUc7UUFDdkIsTUFBTTRKLE9BQU83RSxPQUFPN0UsR0FBRztRQUN2QixNQUFNMkosT0FBTzdFLE9BQU9oRixHQUFHO1FBQ3ZCLE1BQU04SixPQUFPOUUsT0FBTzlFLEdBQUc7UUFFdkIsTUFBTTZKLFFBQVFDLE1BQU1DLElBQUksQ0FBQztZQUFFNU0sUUFBUTBHO1FBQUssR0FBRyxDQUFDckIsR0FBR0MsSUFBTWdILE9BQU8sSUFBTTVGLENBQUFBLE9BQU8sS0FBTzZGLENBQUFBLE9BQU9ELElBQUc7UUFDMUYsTUFBTU8sUUFBUUYsTUFBTUMsSUFBSSxDQUFDO1lBQUU1TSxRQUFRMEc7UUFBSyxHQUFHLENBQUNyQixHQUFHQyxJQUFNa0gsT0FBTyxJQUFNOUYsQ0FBQUEsT0FBTyxLQUFPK0YsQ0FBQUEsT0FBT0QsSUFBRztRQUUxRixNQUFNTSxVQUFVLEVBQUU7UUFDbEIsSUFBSyxJQUFJeEgsSUFBSSxHQUFHQSxJQUFJb0IsTUFBTXBCLElBQUs7WUFDN0IsTUFBTS9ELE1BQU0sRUFBRTtZQUNkLElBQUssSUFBSStHLElBQUksR0FBR0EsSUFBSTVCLE1BQU00QixJQUFLO2dCQUM3QixNQUFNeUUsVUFBVUwsS0FBSyxDQUFDcEUsRUFBRTtnQkFDeEIsTUFBTTBFLFVBQVVILEtBQUssQ0FBQ3ZILEVBQUU7Z0JBRXhCLHlDQUF5QztnQkFDekMsSUFBSTJILGNBQWM7Z0JBQ2xCLElBQUlDLGNBQWM7Z0JBQ2xCLE1BQU1DLGNBQWN2SyxLQUFLc0QsSUFBSSxDQUFDLENBQUNxRyxPQUFPRCxJQUFHLEtBQU0sSUFBSSxDQUFDRyxPQUFPRCxJQUFHLEtBQU0sS0FBSztnQkFFekUsSUFBSyxJQUFJakUsSUFBSSxHQUFHQSxJQUFJdEssS0FBSytCLE1BQU0sRUFBRXVJLElBQUs7b0JBQ3BDLE1BQU1HLEtBQUs3QyxPQUFPLENBQUMwQyxFQUFFLEdBQUd3RTtvQkFDeEIsTUFBTXBFLEtBQUs3QyxPQUFPLENBQUN5QyxFQUFFLEdBQUd5RTtvQkFDeEIsTUFBTW5FLFdBQVdqRyxLQUFLc0QsSUFBSSxDQUFDd0MsS0FBS0EsS0FBS0MsS0FBS0E7b0JBRTFDLElBQUlFLFdBQVdzRSxhQUFhO3dCQUMxQixNQUFNQyxTQUFTeEssS0FBS2tHLEdBQUcsQ0FBQyxDQUFFRCxDQUFBQSxXQUFXQSxRQUFPLElBQU1zRSxDQUFBQSxjQUFjQSxXQUFVO3dCQUMxRUYsZUFBZWxILE9BQU8sQ0FBQ3dDLEVBQUUsR0FBRzZFO3dCQUM1QkYsZUFBZUU7b0JBQ2pCO2dCQUNGO2dCQUVBN0wsSUFBSWtCLElBQUksQ0FBQ3lLLGNBQWMsSUFBSUQsY0FBY0MsY0FBYztZQUN6RDtZQUNBSixRQUFRckssSUFBSSxDQUFDbEI7UUFDZjtRQUVBLE1BQU00RSxXQUFXO1lBQ2Y7Z0JBQ0VDLE1BQU07Z0JBQ05JLEdBQUdzRztnQkFDSHhHLEdBQUdvRztnQkFDSG5HLEdBQUdzRztnQkFDSGpHLFlBQVk7Z0JBQ1p5RyxVQUFVO29CQUNSN0csR0FBRzt3QkFDRDhHLE1BQU07d0JBQ05DLGFBQWE7d0JBQ2JDLGdCQUFnQjt3QkFDaEJDLFNBQVM7NEJBQUVqSCxHQUFHO3dCQUFLO3dCQUNuQitDLE9BQU87b0JBQ1Q7Z0JBQ0Y7Z0JBQ0F6QyxVQUFVO29CQUNSQyxPQUFPN0YsU0FBU1osT0FBTyxDQUFDRyxLQUFLO29CQUM3QnVHLFdBQVc7d0JBQUVOLE1BQU07b0JBQUc7Z0JBQ3hCO2dCQUNBVSxNQUFNLGFBQXlCLE9BQVpuSixLQUFLK0IsTUFBTSxFQUFDO1lBQ2pDO1NBQ0Q7UUFFRCxNQUFNcUgsU0FBU0Msb0JBQW9CLGlDQUFpQ3BHO1FBQ3BFbEMsT0FBT0MsTUFBTSxDQUFDc0ksT0FBTyxDQUFDbEosUUFBUXVCLE9BQU8sRUFBRXVHLFVBQVVrQixRQUFRRztJQUMzRDtJQUVBLHFEQUFxRDtJQUNyRCxNQUFNbEQsaUJBQWlCLENBQUNwRDtRQUN0QixNQUFNOEUsY0FBY2Qsc0JBQXNCaEUsVUFBVTtRQUNwRCxNQUFNK0gsYUFBYS9ELHNCQUFzQmhFLFVBQVU7UUFFbkQsTUFBTXdNLFFBQVEsRUFBRTtRQUNoQixNQUFNQyxRQUFRLEVBQUU7UUFDaEIsTUFBTUMsUUFBUSxFQUFFO1FBQ2hCLE1BQU1DLFFBQVEsRUFBRTtRQUNoQixNQUFNQyxRQUFRLEVBQUU7UUFDaEIsTUFBTUMsUUFBUSxFQUFFO1FBQ2hCLE1BQU1DLFlBQVksRUFBRTtRQUNwQixNQUFNQyxXQUFXLEVBQUU7UUFFbkIsb0RBQW9EO1FBQ3BELE1BQU1qRSxhQUFhOUksU0FBU0gsVUFBVSxDQUFDRyxTQUFTWixPQUFPLENBQUNJLE9BQU8sQ0FBQztRQUNoRSxNQUFNd0ssWUFBWWhLLFNBQVNILFVBQVUsQ0FBQ0csU0FBU1osT0FBTyxDQUFDSyxNQUFNLENBQUM7UUFFOUQxQyxLQUFLa0QsT0FBTyxDQUFDLENBQUNJLEtBQUsrRDtZQUNqQixNQUFNNkYsSUFBSSxJQUFLbE4sS0FBSytCLE1BQU0sR0FBSSxJQUFJNEMsS0FBS3VILEVBQUU7WUFDekMsTUFBTTNELElBQUksSUFBS3ZJLEtBQUsrQixNQUFNLEdBQUk7WUFFOUIsbUNBQW1DO1lBQ25DLE1BQU04SixXQUFXOUQsV0FBVyxDQUFDVixFQUFFO1lBQy9CLE1BQU15RSxVQUFVZCxVQUFVLENBQUMzRCxFQUFFO1lBRTdCLE1BQU00SSxtQkFBbUJsRSxhQUNyQixJQUFJLE1BQVFGLENBQUFBLFdBQVdFLFdBQVdySCxHQUFHLElBQU1xSCxDQUFBQSxXQUFXbkgsR0FBRyxHQUFHbUgsV0FBV3JILEdBQUcsSUFDMUU7WUFDSixNQUFNd0wsbUJBQW1CakQsWUFBWSxNQUFRbkIsQ0FBQUEsVUFBVW1CLFVBQVV2SSxHQUFHLElBQU11SSxDQUFBQSxVQUFVckksR0FBRyxHQUFHcUksVUFBVXZJLEdBQUcsSUFBSTtZQUUzRyxlQUFlO1lBQ2YrSyxNQUFNakwsSUFBSSxDQUFDRyxLQUFLMEgsR0FBRyxDQUFDYSxLQUFLK0M7WUFDekJQLE1BQU1sTCxJQUFJLENBQUNHLEtBQUt3SCxHQUFHLENBQUNlLEtBQUsrQztZQUN6Qk4sTUFBTW5MLElBQUksQ0FBQytELElBQUkySDtZQUVmLDhCQUE4QjtZQUM5Qk4sTUFBTXBMLElBQUksQ0FBQ0csS0FBSzBILEdBQUcsQ0FBQ2EsSUFBSXZJLEtBQUt1SCxFQUFFLElBQUkrRDtZQUNuQ0osTUFBTXJMLElBQUksQ0FBQ0csS0FBS3dILEdBQUcsQ0FBQ2UsSUFBSXZJLEtBQUt1SCxFQUFFLElBQUkrRDtZQUNuQ0gsTUFBTXRMLElBQUksQ0FBQytELElBQUkySDtZQUVmSCxVQUFVdkwsSUFBSSxDQUFDcUg7WUFDZm1FLFNBQVN4TCxJQUFJLENBQUNHLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRCxHQUFHLENBQUMsSUFBSSxVQUFZdUksQ0FBQUEsQ0FBQUEsc0JBQUFBLGdDQUFBQSxVQUFXckksR0FBRyxLQUFJLEtBQU0sSUFBSTtRQUNqRjtRQUVBLE1BQU1zRCxXQUFXO1lBQ2Y7Z0JBQ0VDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLEdBQUdvSDtnQkFDSG5ILEdBQUdvSDtnQkFDSG5ILEdBQUdvSDtnQkFDSG5ILFFBQVE7b0JBQ05DLE1BQU11SDtvQkFDTnRILE9BQU9xSDtvQkFDUHBILFlBQVk7b0JBQ1pFLFVBQVU7d0JBQ1JDLE9BQU83RixTQUFTWixPQUFPLENBQUNJLE9BQU87d0JBQy9Cc0csV0FBVzs0QkFBRU4sTUFBTTt3QkFBRztvQkFDeEI7Z0JBQ0Y7Z0JBQ0E0QyxNQUFNO29CQUFFM0MsT0FBTztvQkFBNEI0QyxPQUFPO2dCQUFFO2dCQUNwRG5DLE1BQU0sZ0JBQTRCLE9BQVpuSixLQUFLK0IsTUFBTSxFQUFDO1lBQ3BDO1lBQ0E7Z0JBQ0VvRyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOQyxHQUFHdUg7Z0JBQ0h0SCxHQUFHdUg7Z0JBQ0h0SCxHQUFHdUg7Z0JBQ0h0SCxRQUFRO29CQUFFQyxNQUFNdUg7b0JBQVV0SCxPQUFPcUg7b0JBQVdwSCxZQUFZO2dCQUFTO2dCQUNqRTBDLE1BQU07b0JBQUUzQyxPQUFPO29CQUE0QjRDLE9BQU87Z0JBQUU7Z0JBQ3BEbkMsTUFBTSxnQkFBNEIsT0FBWm5KLEtBQUsrQixNQUFNLEVBQUM7Z0JBQ2xDb08sWUFBWTtZQUNkO1NBQ0Q7UUFFRCxNQUFNL0csU0FBU0Msb0JBQW9CLHdCQUFxQnBHO1FBQ3hEbUcsT0FBT3FELEtBQUssQ0FBQ0MsTUFBTSxHQUFHO1lBQUVDLEtBQUs7Z0JBQUV0RSxHQUFHO2dCQUFHQyxHQUFHO2dCQUFHQyxHQUFHO1lBQUU7UUFBRTtRQUNsRHhILE9BQU9DLE1BQU0sQ0FBQ3NJLE9BQU8sQ0FBQ2xKLFFBQVF1QixPQUFPLEVBQUV1RyxVQUFVa0IsUUFBUUc7SUFDM0Q7SUFFQSw2REFBNkQ7SUFDN0QsTUFBTUYsc0JBQXNCLENBQUNQLE9BQWU3RjtRQUMxQyxNQUFNbU4sV0FBVyxHQUE0Qm5OLE9BQXpCakQsS0FBSytCLE1BQU0sRUFBQyxrQkFBc0RrQixPQUF6Q0EsU0FBU04sY0FBYyxDQUFDWixNQUFNLEVBQUMsWUFBNkMsT0FBbkNrQixTQUFTTCxrQkFBa0IsQ0FBQ2IsTUFBTSxFQUFDO1FBRXpILE9BQU87WUFDTDBLLE9BQU87Z0JBQ0w0RCxPQUFPO29CQUNMdkgsT0FBTzt3QkFDTEUsTUFBTSxHQUE2Qi9GLE9BQTFCQSxTQUFTWixPQUFPLENBQUNDLEtBQUssRUFBQyxLQUF1RyxPQUFwR1csU0FBU0QsU0FBUyxDQUFDQyxTQUFTWixPQUFPLENBQUNDLEtBQUssQ0FBQyxHQUFHLElBQStDLE9BQTNDVyxTQUFTRCxTQUFTLENBQUNDLFNBQVNaLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLEVBQUMsT0FBSzt3QkFDcElnTyxNQUFNOzRCQUFFN0gsTUFBTTs0QkFBSUMsT0FBTzt3QkFBVTtvQkFDckM7b0JBQ0E2SCxnQkFBZ0I7b0JBQ2hCQyxpQkFBaUI7Z0JBQ25CO2dCQUNBQyxPQUFPO29CQUNMM0gsT0FBTzt3QkFDTEUsTUFBTSxHQUE2Qi9GLE9BQTFCQSxTQUFTWixPQUFPLENBQUNFLEtBQUssRUFBQyxLQUF1RyxPQUFwR1UsU0FBU0QsU0FBUyxDQUFDQyxTQUFTWixPQUFPLENBQUNFLEtBQUssQ0FBQyxHQUFHLElBQStDLE9BQTNDVSxTQUFTRCxTQUFTLENBQUNDLFNBQVNaLE9BQU8sQ0FBQ0UsS0FBSyxDQUFDLEVBQUMsT0FBSzt3QkFDcEkrTixNQUFNOzRCQUFFN0gsTUFBTTs0QkFBSUMsT0FBTzt3QkFBVTtvQkFDckM7b0JBQ0E2SCxnQkFBZ0I7b0JBQ2hCQyxpQkFBaUI7Z0JBQ25CO2dCQUNBRSxPQUFPO29CQUNMNUgsT0FBTzt3QkFDTEUsTUFBTSxHQUE2Qi9GLE9BQTFCQSxTQUFTWixPQUFPLENBQUNHLEtBQUssRUFBQyxLQUF1RyxPQUFwR1MsU0FBU0QsU0FBUyxDQUFDQyxTQUFTWixPQUFPLENBQUNHLEtBQUssQ0FBQyxHQUFHLElBQStDLE9BQTNDUyxTQUFTRCxTQUFTLENBQUNDLFNBQVNaLE9BQU8sQ0FBQ0csS0FBSyxDQUFDLEVBQUMsT0FBSzt3QkFDcEk4TixNQUFNOzRCQUFFN0gsTUFBTTs0QkFBSUMsT0FBTzt3QkFBVTtvQkFDckM7b0JBQ0E2SCxnQkFBZ0I7b0JBQ2hCQyxpQkFBaUI7Z0JBQ25CO2dCQUNBOUQsUUFBUTtvQkFBRUMsS0FBSzt3QkFBRXRFLEdBQUc7d0JBQU1DLEdBQUc7d0JBQU1DLEdBQUc7b0JBQUs7Z0JBQUU7WUFDL0M7WUFDQU8sT0FBTztnQkFBRUUsTUFBTUY7Z0JBQU93SCxNQUFNO29CQUFFN0gsTUFBTTtvQkFBSUMsT0FBTztnQkFBVTtZQUFFO1lBQzNEaUksZUFBZTtZQUNmQyxRQUFRO2dCQUFFQyxHQUFHO2dCQUFHQyxHQUFHO2dCQUFHNUQsR0FBRztnQkFBSWMsR0FBRztZQUFFO1lBQ2xDK0MsYUFBYTtnQkFDWDtvQkFDRS9ILE1BQU0scUJBQThDb0gsT0FBNUJ0SCxPQUFNLDJCQUE2RDdGLE9BQXZDbU4sVUFBUyxnQ0FBZ0VuTixPQUFsQ0EsU0FBU1osT0FBTyxDQUFDQyxLQUFLLEVBQUMsYUFBNkNXLE9BQWxDQSxTQUFTWixPQUFPLENBQUNFLEtBQUssRUFBQyxhQUFtRFUsT0FBeENBLFNBQVNaLE9BQU8sQ0FBQ0csS0FBSyxFQUFDLG1CQUEwRFMsT0FBekNBLFNBQVNaLE9BQU8sQ0FBQ0ksT0FBTyxFQUFDLGtCQUEwQ1EsT0FBMUJBLFNBQVNaLE9BQU8sQ0FBQ0ssTUFBTSxFQUF3RixPQUFyRk8sU0FBU1osT0FBTyxDQUFDMEMsVUFBVSxHQUFHLHVCQUFnRCxPQUE1QjlCLFNBQVNaLE9BQU8sQ0FBQzBDLFVBQVUsSUFBSztvQkFDNVZpTSxXQUFXO29CQUNYQyxNQUFNO29CQUNOQyxNQUFNO29CQUNON0ksR0FBRyxDQUFDO29CQUNKQyxHQUFHO29CQUNINkksU0FBUztvQkFDVEMsU0FBUztvQkFDVDVELFNBQVM7b0JBQ1Q2RCxhQUFhO29CQUNiQyxhQUFhO29CQUNiaEIsTUFBTTt3QkFBRTdILE1BQU07d0JBQUdDLE9BQU87b0JBQU87Z0JBQ2pDO2FBQ0Q7UUFDSDtJQUNGO0lBRUEsTUFBTWEsZ0JBQWdCLElBQU87WUFDM0JnSSxZQUFZO1lBQ1pDLGdCQUFnQjtZQUNoQkMsWUFBWTtZQUNaQyxZQUFZO1lBQ1pDLGFBQWE7UUFDZjtJQUVBLE1BQU0xUCx3QkFBd0IsQ0FBQzJQO1FBQzdCLElBQUk7WUFDRjdRLE9BQU9DLE1BQU0sQ0FBQ3NJLE9BQU8sQ0FBQ2xKLFFBQVF1QixPQUFPLEVBQUVpUSxPQUFPQSxNQUFNLENBQUM1UixJQUFJLEVBQUU0UixPQUFPQSxNQUFNLENBQUN4SSxNQUFNLEVBQUVHO1FBQ25GLEVBQUUsT0FBTy9ILE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLG9CQUFvQkE7WUFDbENVO1FBQ0Y7SUFDRjtJQUVBLE1BQU04QywwQkFBMEI7UUFDOUIsTUFBTTZNLFdBQVduRCxNQUFNQyxJQUFJLENBQUM7WUFBRTVNLFFBQVE7UUFBRyxHQUFHLENBQUNxRixHQUFHQyxJQUFPO2dCQUNyRGdCLEdBQUcxRCxLQUFLMEksTUFBTSxLQUFLO2dCQUNuQi9FLEdBQUczRCxLQUFLMEksTUFBTSxLQUFLO2dCQUNuQjlFLEdBQUc1RCxLQUFLMEksTUFBTSxLQUFLO2dCQUNuQnlFLE9BQU9uTixLQUFLMEksTUFBTSxLQUFLO2dCQUN2QjBFLFVBQVUsTUFBd0MsT0FBbENwTixLQUFLcU4sS0FBSyxDQUFDck4sS0FBSzBJLE1BQU0sS0FBSyxLQUFLO1lBQ2xEO1FBRUEzTSxlQUFlO1lBQ2I0QixPQUFPO1lBQ1BDLE9BQU87WUFDUEMsT0FBTztZQUNQQyxTQUFTO1lBQ1RDLFFBQVE7UUFDVjtRQUVBLE1BQU13RixXQUFXO1lBQ2Y7Z0JBQ0VDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLEdBQUd3SixTQUFTeE8sR0FBRyxDQUFDLENBQUM0TyxJQUFNQSxFQUFFNUosQ0FBQztnQkFDMUJDLEdBQUd1SixTQUFTeE8sR0FBRyxDQUFDLENBQUM0TyxJQUFNQSxFQUFFM0osQ0FBQztnQkFDMUJDLEdBQUdzSixTQUFTeE8sR0FBRyxDQUFDLENBQUM0TyxJQUFNQSxFQUFFMUosQ0FBQztnQkFDMUJDLFFBQVE7b0JBQ05DLE1BQU07b0JBQ05DLE9BQU9tSixTQUFTeE8sR0FBRyxDQUFDLENBQUM0TyxJQUFNQSxFQUFFSCxLQUFLO29CQUNsQ25KLFlBQVk7b0JBQ1pDLFNBQVM7Z0JBQ1g7Z0JBQ0FPLE1BQU07WUFDUjtTQUNEO1FBRUQsTUFBTUMsU0FBUztZQUNicUQsT0FBTztnQkFDTDRELE9BQU87b0JBQUV2SCxPQUFPO29CQUFleUgsZ0JBQWdCO29CQUFNQyxpQkFBaUI7Z0JBQTJCO2dCQUNqR0MsT0FBTztvQkFBRTNILE9BQU87b0JBQWV5SCxnQkFBZ0I7b0JBQU1DLGlCQUFpQjtnQkFBMkI7Z0JBQ2pHRSxPQUFPO29CQUFFNUgsT0FBTztvQkFBZXlILGdCQUFnQjtvQkFBTUMsaUJBQWlCO2dCQUEyQjtnQkFDakc5RCxRQUFRO29CQUFFQyxLQUFLO3dCQUFFdEUsR0FBRzt3QkFBTUMsR0FBRzt3QkFBTUMsR0FBRztvQkFBSztnQkFBRTtZQUMvQztZQUNBTyxPQUFPO2dCQUFFRSxNQUFNLHNCQUFtRCxPQUFoQ2tKLGFBQWFoUztnQkFBc0JvUSxNQUFNO29CQUFFN0gsTUFBTTtvQkFBSUMsT0FBTztnQkFBVTtZQUFFO1lBQzFHaUksZUFBZTtZQUNmQyxRQUFRO2dCQUFFQyxHQUFHO2dCQUFHQyxHQUFHO2dCQUFHNUQsR0FBRztnQkFBSWMsR0FBRztZQUFFO1FBQ3BDO1FBRUFqTixPQUFPQyxNQUFNLENBQUNzSSxPQUFPLENBQUNsSixRQUFRdUIsT0FBTyxFQUFFdUcsVUFBVWtCLFFBQVFHO0lBQzNEO0lBRUEsTUFBTTJJLGVBQWUsQ0FBQ0M7UUFDcEIsTUFBTUMsUUFBbUM7WUFDdkNDLFdBQVc7WUFDWEMsaUJBQWlCO1lBQ2pCQyxnQkFBZ0I7WUFDaEJDLFlBQVk7WUFDWkMsV0FBVztZQUNYQyxpQkFBaUI7WUFDakJDLFdBQVc7WUFDWEMsYUFBYTtRQUNmO1FBQ0EsT0FBT1IsS0FBSyxDQUFDRCxRQUFRLElBQUk7SUFDM0I7SUFFQSxxQkFDRSw4REFBQ1U7UUFBSUMsV0FBVTs7MEJBRWIsOERBQUNEO2dCQUFJQyxXQUFVOzBCQUNiLDRFQUFDRDtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNEOzRCQUFJQyxXQUFVOzs4Q0FDYiw4REFBQ0Q7b0NBQUlDLFdBQVU7OENBQ2IsNEVBQUNsVCwrRkFBVUE7d0NBQUNrVCxXQUFVOzs7Ozs7Ozs7Ozs4Q0FFeEIsOERBQUNEOztzREFDQyw4REFBQ0U7NENBQUdELFdBQVU7c0RBQWtDOzs7Ozs7c0RBQ2hELDhEQUFDdEk7NENBQUVzSSxXQUFVO3NEQUNWOVMsS0FBSytCLE1BQU0sR0FBRyxJQUNYLEdBQWlDOUIsT0FBOUJELEtBQUsrQixNQUFNLEVBQUMsdUJBQWdEbVEsT0FBOUJqUyxRQUFROEIsTUFBTSxFQUFDLGlCQUEwQyxPQUEzQm1RLGFBQWF2UixpQkFDNUUsMkJBQW1ELE9BQTNCdVIsYUFBYXZSOzs7Ozs7d0NBRTFDRSw4QkFDQyw4REFBQzJKOzRDQUFFc0ksV0FBVTs7Z0RBQ1ZqUyxhQUFhOEIsY0FBYyxDQUFDWixNQUFNO2dEQUFDO2dEQUFlbEIsYUFBYStCLGtCQUFrQixDQUFDYixNQUFNO2dEQUFFO2dEQUFJO2dEQUM5RWxCLGFBQWFnQyxlQUFlLENBQUNkLE1BQU07Z0RBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBTTdELDhEQUFDOFE7NEJBQUlDLFdBQVU7O2dDQUNaelMsK0JBQ0MsOERBQUMyUztvQ0FBS0YsV0FBVTs7c0RBQ2QsOERBQUNoVCwrRkFBSUE7NENBQUNnVCxXQUFVOzs7Ozs7d0NBQWlCOzs7Ozs7OzhDQUlyQyw4REFBQ0U7b0NBQUtGLFdBQVU7O3NEQUNkLDhEQUFDalQsK0ZBQUdBOzRDQUFDaVQsV0FBVTs7Ozs7O3dDQUFpQjs7Ozs7Ozs4Q0FHbEMsOERBQUNFO29DQUFLRixXQUFVOzhDQUFrRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBUXhILDhEQUFDRDtnQkFBSUMsV0FBVTswQkFDWixDQUFDdlMsNkJBQ0EsOERBQUNzUztvQkFBSUMsV0FBVTs4QkFDYiw0RUFBQ0Q7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDRDtnQ0FBSUMsV0FBVTs7Ozs7OzBDQUNmLDhEQUFDdEk7Z0NBQUVzSSxXQUFVOzBDQUFnQjs7Ozs7OzBDQUM3Qiw4REFBQ3RJO2dDQUFFc0ksV0FBVTswQ0FBNkI7Ozs7Ozs7Ozs7Ozs7Ozs7eUNBSTlDLDhEQUFDRDtvQkFBSUksS0FBSzdTO29CQUFTMFMsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLdkM7R0Fub0N3Qi9TO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FudmFzM0RWaXN1YWxpemF0aW9uLnRzeD9kYzUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBUcmVuZGluZ1VwLCBaYXAsIENvZGUgfSBmcm9tIFwibHVjaWRlLXJlYWN0XCJcblxuLy8gw4l0ZW5kcmUgbCdpbnRlcmZhY2UgV2luZG93IHBvdXIgaW5jbHVyZSBQbG90bHlcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgUGxvdGx5OiBhbnlcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ2FudmFzM0RWaXN1YWxpemF0aW9uUHJvcHMge1xuICBkYXRhOiBhbnlbXVxuICBjb2x1bW5zOiBzdHJpbmdbXVxuICB2aXN1YWxpemF0aW9uVHlwZTogc3RyaW5nXG4gIGdlbmVyYXRlZENvbmZpZz86IGFueVxufVxuXG5pbnRlcmZhY2UgRGF0YU1hcHBpbmcge1xuICB4QXhpczogc3RyaW5nXG4gIHlBeGlzOiBzdHJpbmdcbiAgekF4aXM6IHN0cmluZ1xuICBjb2xvckJ5OiBzdHJpbmdcbiAgc2l6ZUJ5OiBzdHJpbmdcbiAgY2F0ZWdvcnlCeT86IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgRGF0YUFuYWx5c2lzIHtcbiAgbWFwcGluZzogRGF0YU1hcHBpbmdcbiAgbnVtZXJpY0NvbHVtbnM6IHN0cmluZ1tdXG4gIGNhdGVnb3JpY2FsQ29sdW1uczogc3RyaW5nW11cbiAgdGVtcG9yYWxDb2x1bW5zOiBzdHJpbmdbXVxuICBkYXRhUmFuZ2VzOiB7IFtrZXk6IHN0cmluZ106IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyOyB2YWx1ZXM6IG51bWJlcltdIH0gfVxuICBjYXRlZ29yaWVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIH1cbiAgZGF0YVR5cGVzOiB7IFtrZXk6IHN0cmluZ106IFwibnVtZXJpY1wiIHwgXCJjYXRlZ29yaWNhbFwiIHwgXCJ0ZW1wb3JhbFwiIHwgXCJtaXhlZFwiIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FudmFzM0RWaXN1YWxpemF0aW9uKHtcbiAgZGF0YSxcbiAgY29sdW1ucyxcbiAgdmlzdWFsaXphdGlvblR5cGUsXG4gIGdlbmVyYXRlZENvbmZpZyxcbn06IENhbnZhczNEVmlzdWFsaXphdGlvblByb3BzKSB7XG4gIGNvbnN0IHBsb3RSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IFtpc1YwR2VuZXJhdGVkLCBzZXRJc1YwR2VuZXJhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbcGxvdGx5TG9hZGVkLCBzZXRQbG90bHlMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtkYXRhTWFwcGluZywgc2V0RGF0YU1hcHBpbmddID0gdXNlU3RhdGU8RGF0YU1hcHBpbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBbY3VycmVudE1vZGVsLCBzZXRDdXJyZW50TW9kZWxdID0gdXNlU3RhdGU8c3RyaW5nPihcInNjYXR0ZXIzZFwiKVxuICBjb25zdCBbZGF0YUFuYWx5c2lzLCBzZXREYXRhQW5hbHlzaXNdID0gdXNlU3RhdGU8RGF0YUFuYWx5c2lzIHwgbnVsbD4obnVsbClcblxuICAvLyBDaGFyZ2VyIFBsb3RseS5qc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICF3aW5kb3cuUGxvdGx5KSB7XG4gICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpXG4gICAgICBzY3JpcHQuc3JjID0gXCJodHRwczovL2Nkbi5wbG90Lmx5L3Bsb3RseS0yLjM1LjIubWluLmpzXCJcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiBzZXRQbG90bHlMb2FkZWQodHJ1ZSlcbiAgICAgIHNjcmlwdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyZXVyIGxvcnMgZHUgY2hhcmdlbWVudCBkZSBQbG90bHkuanNcIilcbiAgICAgICAgc2V0UGxvdGx5TG9hZGVkKGZhbHNlKVxuICAgICAgfVxuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXG4gICAgfSBlbHNlIGlmICh3aW5kb3cuUGxvdGx5KSB7XG4gICAgICBzZXRQbG90bHlMb2FkZWQodHJ1ZSlcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwbG90bHlMb2FkZWQgfHwgIXBsb3RSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICBjb25zdCB1cGRhdGVWaXN1YWxpemF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGxvdEVsZW1lbnQgPSBwbG90UmVmLmN1cnJlbnRcbiAgICAgIGlmICghcGxvdEVsZW1lbnQpIHJldHVyblxuXG4gICAgICAvLyBOZXR0b3llciBsZSBncmFwaGlxdWUgcHLDqWPDqWRlbnRcbiAgICAgIGlmIChwbG90RWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdpbmRvdy5QbG90bHkucHVyZ2UocGxvdEVsZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHNldEN1cnJlbnRNb2RlbCh2aXN1YWxpemF0aW9uVHlwZSlcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGdlbmVyYXRlZENvbmZpZykge1xuICAgICAgICAgIGF3YWl0IHJlbmRlclYwVmlzdWFsaXphdGlvbihnZW5lcmF0ZWRDb25maWcpXG4gICAgICAgICAgc2V0SXNWMEdlbmVyYXRlZCh0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YWl0IHJlbmRlck1vZGVsU3BlY2lmaWNWaXN1YWxpemF0aW9uKClcbiAgICAgICAgICBzZXRJc1YwR2VuZXJhdGVkKGZhbHNlKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyZXVyIGxvcnMgZGUgbGEgbWlzZSDDoCBqb3VyIGRlIGxhIHZpc3VhbGlzYXRpb246XCIsIGVycm9yKVxuICAgICAgICAvLyBFbiBjYXMgZCdlcnJldXIsIG9uIHJldmllbnQgYXUgbnVhZ2UgZGUgcG9pbnRzIGJhc2lxdWVcbiAgICAgICAgcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHl6ZURhdGFJbnRlbGxpZ2VudGx5KCkgfHwge1xuICAgICAgICAgIG1hcHBpbmc6IHtcbiAgICAgICAgICAgIHhBeGlzOiBjb2x1bW5zWzBdIHx8IFwiaW5kZXhcIixcbiAgICAgICAgICAgIHlBeGlzOiBjb2x1bW5zWzFdIHx8IFwiaW5kZXhcIixcbiAgICAgICAgICAgIHpBeGlzOiBjb2x1bW5zWzJdIHx8IFwiaW5kZXhcIixcbiAgICAgICAgICAgIGNvbG9yQnk6IGNvbHVtbnNbMF0gfHwgXCJpbmRleFwiLFxuICAgICAgICAgICAgc2l6ZUJ5OiBjb2x1bW5zWzFdIHx8IFwiaW5kZXhcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbnVtZXJpY0NvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgICAgY2F0ZWdvcmljYWxDb2x1bW5zOiBbXSxcbiAgICAgICAgICB0ZW1wb3JhbENvbHVtbnM6IFtdLFxuICAgICAgICAgIGRhdGFSYW5nZXM6IHt9LFxuICAgICAgICAgIGNhdGVnb3JpZXM6IHt9LFxuICAgICAgICAgIGRhdGFUeXBlczoge31cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVWaXN1YWxpemF0aW9uKClcbiAgfSwgW3Bsb3RseUxvYWRlZCwgZGF0YSwgY29sdW1ucywgdmlzdWFsaXphdGlvblR5cGUsIGdlbmVyYXRlZENvbmZpZ10pXG5cbiAgLy8gQW5hbHlzZSBjb21wbMOodGUgZXQgaW50ZWxsaWdlbnRlIGRlcyBkb25uw6llc1xuICBjb25zdCBhbmFseXplRGF0YUludGVsbGlnZW50bHkgPSAoKTogRGF0YUFuYWx5c2lzIHwgbnVsbCA9PiB7XG4gICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwIHx8ICFjb2x1bW5zIHx8IGNvbHVtbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMgPSB7XG4gICAgICBtYXBwaW5nOiB7fSBhcyBEYXRhTWFwcGluZyxcbiAgICAgIG51bWVyaWNDb2x1bW5zOiBbXSxcbiAgICAgIGNhdGVnb3JpY2FsQ29sdW1uczogW10sXG4gICAgICB0ZW1wb3JhbENvbHVtbnM6IFtdLFxuICAgICAgZGF0YVJhbmdlczoge30sXG4gICAgICBjYXRlZ29yaWVzOiB7fSxcbiAgICAgIGRhdGFUeXBlczoge30sXG4gICAgfVxuXG4gICAgLy8gQW5hbHlzZXIgY2hhcXVlIGNvbG9ubmUgZW4gZMOpdGFpbFxuICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBkYXRhLm1hcCgocm93KSA9PiByb3dbY29sXSkuZmlsdGVyKCh2YWwpID0+IHZhbCAhPSBudWxsICYmIHZhbCAhPT0gXCJcIilcblxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYW5hbHlzaXMuZGF0YVR5cGVzW2NvbF0gPSBcIm1peGVkXCJcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFRlc3QgbnVtw6lyaXF1ZVxuICAgICAgY29uc3QgbnVtZXJpY1ZhbHVlcyA9IHZhbHVlcy5tYXAoKHZhbCkgPT4gTnVtYmVyLnBhcnNlRmxvYXQodmFsKSkuZmlsdGVyKCh2YWwpID0+ICFpc05hTih2YWwpICYmIGlzRmluaXRlKHZhbCkpXG4gICAgICBjb25zdCBudW1lcmljUmF0aW8gPSBudW1lcmljVmFsdWVzLmxlbmd0aCAvIHZhbHVlcy5sZW5ndGhcblxuICAgICAgLy8gVGVzdCB0ZW1wb3JlbFxuICAgICAgY29uc3QgZGF0ZVZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoKHZhbCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsKVxuICAgICAgICByZXR1cm4gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSAmJiBkYXRlLmdldEZ1bGxZZWFyKCkgPiAxOTAwICYmIGRhdGUuZ2V0RnVsbFllYXIoKSA8IDIxMDBcbiAgICAgIH0pXG4gICAgICBjb25zdCB0ZW1wb3JhbFJhdGlvID0gZGF0ZVZhbHVlcy5sZW5ndGggLyB2YWx1ZXMubGVuZ3RoXG5cbiAgICAgIC8vIFRlc3QgY2F0w6lnb3JpZWxcbiAgICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IFsuLi5uZXcgU2V0KHZhbHVlcyldXG4gICAgICBjb25zdCB1bmlxdWVSYXRpbyA9IHVuaXF1ZVZhbHVlcy5sZW5ndGggLyB2YWx1ZXMubGVuZ3RoXG5cbiAgICAgIC8vIENsYXNzaWZpY2F0aW9uIGludGVsbGlnZW50ZVxuICAgICAgaWYgKHRlbXBvcmFsUmF0aW8gPiAwLjcpIHtcbiAgICAgICAgYW5hbHlzaXMuZGF0YVR5cGVzW2NvbF0gPSBcInRlbXBvcmFsXCJcbiAgICAgICAgYW5hbHlzaXMudGVtcG9yYWxDb2x1bW5zLnB1c2goY29sKVxuICAgICAgICAvLyBDb252ZXJ0aXIgZW4gdGltZXN0YW1wcyBwb3VyIGxlcyBjYWxjdWxzXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBkYXRlVmFsdWVzLm1hcCgodmFsKSA9PiBuZXcgRGF0ZSh2YWwpLmdldFRpbWUoKSlcbiAgICAgICAgYW5hbHlzaXMuZGF0YVJhbmdlc1tjb2xdID0ge1xuICAgICAgICAgIG1pbjogTWF0aC5taW4oLi4udGltZXN0YW1wcyksXG4gICAgICAgICAgbWF4OiBNYXRoLm1heCguLi50aW1lc3RhbXBzKSxcbiAgICAgICAgICB2YWx1ZXM6IHRpbWVzdGFtcHMsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobnVtZXJpY1JhdGlvID4gMC43KSB7XG4gICAgICAgIGFuYWx5c2lzLmRhdGFUeXBlc1tjb2xdID0gXCJudW1lcmljXCJcbiAgICAgICAgYW5hbHlzaXMubnVtZXJpY0NvbHVtbnMucHVzaChjb2wpXG4gICAgICAgIGFuYWx5c2lzLmRhdGFSYW5nZXNbY29sXSA9IHtcbiAgICAgICAgICBtaW46IE1hdGgubWluKC4uLm51bWVyaWNWYWx1ZXMpLFxuICAgICAgICAgIG1heDogTWF0aC5tYXgoLi4ubnVtZXJpY1ZhbHVlcyksXG4gICAgICAgICAgdmFsdWVzOiBudW1lcmljVmFsdWVzLFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVuaXF1ZVJhdGlvIDwgMC4zIHx8IHVuaXF1ZVZhbHVlcy5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgYW5hbHlzaXMuZGF0YVR5cGVzW2NvbF0gPSBcImNhdGVnb3JpY2FsXCJcbiAgICAgICAgYW5hbHlzaXMuY2F0ZWdvcmljYWxDb2x1bW5zLnB1c2goY29sKVxuICAgICAgICBhbmFseXNpcy5jYXRlZ29yaWVzW2NvbF0gPSB1bmlxdWVWYWx1ZXMuc2xpY2UoMCwgMjApIC8vIExpbWl0ZXIgw6AgMjAgY2F0w6lnb3JpZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuYWx5c2lzLmRhdGFUeXBlc1tjb2xdID0gXCJtaXhlZFwiXG4gICAgICAgIGlmIChudW1lcmljVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhbmFseXNpcy5kYXRhUmFuZ2VzW2NvbF0gPSB7XG4gICAgICAgICAgICBtaW46IE1hdGgubWluKC4uLm51bWVyaWNWYWx1ZXMpLFxuICAgICAgICAgICAgbWF4OiBNYXRoLm1heCguLi5udW1lcmljVmFsdWVzKSxcbiAgICAgICAgICAgIHZhbHVlczogbnVtZXJpY1ZhbHVlcyxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gQ3LDqWVyIHVuIG1hcHBpbmcgaW50ZWxsaWdlbnQgYmFzw6kgc3VyIGxlcyB0eXBlcyBkZSBkb25uw6llc1xuICAgIGNvbnN0IGFsbE51bWVyaWNDb2xzID0gWy4uLmFuYWx5c2lzLm51bWVyaWNDb2x1bW5zLCAuLi5hbmFseXNpcy50ZW1wb3JhbENvbHVtbnNdXG5cbiAgICBpZiAoYWxsTnVtZXJpY0NvbHMubGVuZ3RoID49IDMpIHtcbiAgICAgIGFuYWx5c2lzLm1hcHBpbmcgPSB7XG4gICAgICAgIHhBeGlzOiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgeUF4aXM6IGFsbE51bWVyaWNDb2xzWzFdLFxuICAgICAgICB6QXhpczogYWxsTnVtZXJpY0NvbHNbMl0sXG4gICAgICAgIGNvbG9yQnk6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICBzaXplQnk6IGFsbE51bWVyaWNDb2xzLmxlbmd0aCA+IDMgPyBhbGxOdW1lcmljQ29sc1szXSA6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICBjYXRlZ29yeUJ5OiBhbmFseXNpcy5jYXRlZ29yaWNhbENvbHVtbnNbMF0sXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbGxOdW1lcmljQ29scy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGFuYWx5c2lzLm1hcHBpbmcgPSB7XG4gICAgICAgIHhBeGlzOiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgeUF4aXM6IGFsbE51bWVyaWNDb2xzWzFdLFxuICAgICAgICB6QXhpczogYWxsTnVtZXJpY0NvbHNbMF0sXG4gICAgICAgIGNvbG9yQnk6IGFsbE51bWVyaWNDb2xzWzFdLFxuICAgICAgICBzaXplQnk6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICBjYXRlZ29yeUJ5OiBhbmFseXNpcy5jYXRlZ29yaWNhbENvbHVtbnNbMF0sXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbGxOdW1lcmljQ29scy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGFuYWx5c2lzLm1hcHBpbmcgPSB7XG4gICAgICAgIHhBeGlzOiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgeUF4aXM6IFwiaW5kZXhcIixcbiAgICAgICAgekF4aXM6IGFsbE51bWVyaWNDb2xzWzBdLFxuICAgICAgICBjb2xvckJ5OiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgc2l6ZUJ5OiBhbGxOdW1lcmljQ29sc1swXSxcbiAgICAgICAgY2F0ZWdvcnlCeTogYW5hbHlzaXMuY2F0ZWdvcmljYWxDb2x1bW5zWzBdLFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVdGlsaXNlciBsZXMgaW5kaWNlcyBldCBjYXTDqWdvcmllc1xuICAgICAgYW5hbHlzaXMubWFwcGluZyA9IHtcbiAgICAgICAgeEF4aXM6IFwiaW5kZXhcIixcbiAgICAgICAgeUF4aXM6IGFuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1uc1swXSB8fCBcImluZGV4XCIsXG4gICAgICAgIHpBeGlzOiBcImNvdW50XCIsXG4gICAgICAgIGNvbG9yQnk6IGFuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1uc1swXSB8fCBcImluZGV4XCIsXG4gICAgICAgIHNpemVCeTogXCJjb3VudFwiLFxuICAgICAgICBjYXRlZ29yeUJ5OiBhbmFseXNpcy5jYXRlZ29yaWNhbENvbHVtbnNbMF0sXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuYWx5c2lzXG4gIH1cblxuICAvLyBGb25jdGlvbiBwcmluY2lwYWxlIHF1aSByb3V0ZSB2ZXJzIGxhIGJvbm5lIHZpc3VhbGlzYXRpb24gc2Vsb24gbGUgbW9kw6hsZVxuICBjb25zdCByZW5kZXJNb2RlbFNwZWNpZmljVmlzdWFsaXphdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlbmRlckRlbW9WaXN1YWxpemF0aW9uKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFuYWx5c2lzID0gYW5hbHl6ZURhdGFJbnRlbGxpZ2VudGx5KClcbiAgICBpZiAoIWFuYWx5c2lzKSB7XG4gICAgICByZW5kZXJEZW1vVmlzdWFsaXphdGlvbigpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXREYXRhQW5hbHlzaXMoYW5hbHlzaXMpXG4gICAgc2V0RGF0YU1hcHBpbmcoYW5hbHlzaXMubWFwcGluZylcblxuICAgIC8vIFJvdXRlciB2ZXJzIGxhIGZvbmN0aW9uIHNww6ljaWFsaXPDqWUgc2Vsb24gbGUgbW9kw6hsZSBleGFjdFxuICAgIHN3aXRjaCAodmlzdWFsaXphdGlvblR5cGUpIHtcbiAgICAgIC8vIE5VQUdFU1xuICAgICAgY2FzZSBcInNjYXR0ZXIzZFwiOlxuICAgICAgICByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzY2F0dGVyX2J1YmJsZVwiOlxuICAgICAgICByZW5kZXJCdWJibGVTY2F0dGVyKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInNjYXR0ZXJfYW5pbWF0ZWRcIjpcbiAgICAgICAgcmVuZGVyQW5pbWF0ZWRTY2F0dGVyKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInNjYXR0ZXJfY2x1c3RlcmVkXCI6XG4gICAgICAgIHJlbmRlckNsdXN0ZXJlZFNjYXR0ZXIoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhdHRlcl9kZW5zaXR5XCI6XG4gICAgICAgIHJlbmRlckRlbnNpdHlTY2F0dGVyKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBTVVJGQUNFU1xuICAgICAgY2FzZSBcInN1cmZhY2UzZFwiOlxuICAgICAgICByZW5kZXJDbGFzc2ljU3VyZmFjZShhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzdXJmYWNlX2NvbnRvdXJcIjpcbiAgICAgICAgcmVuZGVyQ29udG91clN1cmZhY2UoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic3VyZmFjZV9tZXNoXCI6XG4gICAgICAgIHJlbmRlck1lc2hTdXJmYWNlKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInN1cmZhY2VfZ3JhZGllbnRcIjpcbiAgICAgICAgcmVuZGVyR3JhZGllbnRTdXJmYWNlKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBBUkNISVRFQ1RVUkVcbiAgICAgIGNhc2UgXCJiYXJzM2RcIjpcbiAgICAgICAgcmVuZGVyQ2xhc3NpY0JhcnMoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiYmFyc19ncm91cGVkXCI6XG4gICAgICAgIHJlbmRlckdyb3VwZWRCYXJzKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImJhcnNfY3lsaW5kcmljYWxcIjpcbiAgICAgICAgcmVuZGVyQ3lsaW5kcmljYWxCYXJzKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImJhcnNfcHlyYW1pZFwiOlxuICAgICAgICByZW5kZXJQeXJhbWlkQmFycyhhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gR8OJT03DiVRSSVFVRVNcbiAgICAgIGNhc2UgXCJzcGhlcmVfcGFja1wiOlxuICAgICAgICByZW5kZXJTcGhlcmVQYWNrKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImN1YmVfbWF0cml4XCI6XG4gICAgICAgIHJlbmRlckN1YmVNYXRyaXgoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiY29uZV9maWVsZFwiOlxuICAgICAgICByZW5kZXJDb25lRmllbGQoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiaGVsaXhfc3BpcmFsXCI6XG4gICAgICAgIHJlbmRlckhlbGl4U3BpcmFsKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBBUlRJU1RJUVVFU1xuICAgICAgY2FzZSBcIm1hbmRhbGFfM2RcIjpcbiAgICAgICAgcmVuZGVyTWFuZGFsYTNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImZyYWN0YWxfM2RcIjpcbiAgICAgICAgcmVuZGVyRnJhY3RhbDNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImNyeXN0YWxfM2RcIjpcbiAgICAgICAgcmVuZGVyQ3J5c3RhbDNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcImdhbGF4eV8zZFwiOlxuICAgICAgICByZW5kZXJHYWxheHkzRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJkbmFfaGVsaXhcIjpcbiAgICAgICAgcmVuZGVyRE5BSGVsaXgoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIFLDiVNFQVVYXG4gICAgICBjYXNlIFwibmV0d29ya18zZFwiOlxuICAgICAgICByZW5kZXJOZXR3b3JrM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwidHJlZV8zZFwiOlxuICAgICAgICByZW5kZXJUcmVlM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIFRFTVBPUkVMU1xuICAgICAgY2FzZSBcInRpbWVsaW5lXzNkXCI6XG4gICAgICAgIHJlbmRlclRpbWVsaW5lM0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwid2F2ZV90ZW1wb3JhbFwiOlxuICAgICAgICByZW5kZXJXYXZlVGVtcG9yYWwoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic3BpcmFsX3RpbWVcIjpcbiAgICAgICAgcmVuZGVyU3BpcmFsVGltZShhbmFseXNpcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gR8OJT0dSQVBISVFVRVNcbiAgICAgIGNhc2UgXCJnbG9iZV8zZFwiOlxuICAgICAgICByZW5kZXJHbG9iZTNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInRlcnJhaW5fM2RcIjpcbiAgICAgICAgcmVuZGVyVGVycmFpbjNEKGFuYWx5c2lzKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBTQ0lFTlRJRklRVUVTXG4gICAgICBjYXNlIFwibW9sZWN1bGVfM2RcIjpcbiAgICAgICAgcmVuZGVyTW9sZWN1bGUzRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJ2ZWN0b3JfZmllbGRcIjpcbiAgICAgICAgcmVuZGVyVmVjdG9yRmllbGQoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIFNUQVRJU1RJUVVFU1xuICAgICAgY2FzZSBcImhpc3RvZ3JhbV8zZFwiOlxuICAgICAgICByZW5kZXJIaXN0b2dyYW0zRChhbmFseXNpcylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJib3hfcGxvdF8zZFwiOlxuICAgICAgICByZW5kZXJCb3hQbG90M0QoYW5hbHlzaXMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICAgIH1cbiAgfVxuXG4gIC8vIEZvbmN0aW9uIHV0aWxpdGFpcmUgcG91ciBleHRyYWlyZSBsZXMgdmFsZXVycyBhdmVjIGwnYW5hbHlzZVxuICBjb25zdCBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcywga2V5OiBrZXlvZiBEYXRhTWFwcGluZyk6IG51bWJlcltdID0+IHtcbiAgICBjb25zdCBjb2x1bW4gPSBhbmFseXNpcy5tYXBwaW5nW2tleV1cblxuICAgIGlmIChjb2x1bW4gPT09IFwiaW5kZXhcIikge1xuICAgICAgcmV0dXJuIGRhdGEubWFwKChfLCBpKSA9PiBpKVxuICAgIH0gZWxzZSBpZiAoY29sdW1uID09PSBcImNvdW50XCIpIHtcbiAgICAgIHJldHVybiBkYXRhLm1hcCgoKSA9PiAxKVxuICAgIH0gZWxzZSBpZiAoY29sdW1uICYmIGNvbHVtbnMuaW5jbHVkZXMoY29sdW1uKSkge1xuICAgICAgaWYgKGFuYWx5c2lzLmRhdGFSYW5nZXNbY29sdW1uXSkge1xuICAgICAgICAvLyBVdGlsaXNlciBsZXMgdmFsZXVycyBwcsOpLWNhbGN1bMOpZXMgcG91ciBsZXMgY29sb25uZXMgbnVtw6lyaXF1ZXMvdGVtcG9yZWxsZXNcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2NvbHVtbl1cbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChyb3csIGkpID0+IHtcbiAgICAgICAgICBjb25zdCB2YWwgPSByb3dbY29sdW1uXVxuICAgICAgICAgIGlmIChhbmFseXNpcy5kYXRhVHlwZXNbY29sdW1uXSA9PT0gXCJ0ZW1wb3JhbFwiKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSh2YWwpLmdldFRpbWUoKVxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHRpbWVzdGFtcCkgPyByYW5nZS5taW4gOiB0aW1lc3RhbXBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbnVtVmFsID0gTnVtYmVyLnBhcnNlRmxvYXQodmFsKVxuICAgICAgICAgICAgcmV0dXJuICFpc05hTihudW1WYWwpICYmIGlzRmluaXRlKG51bVZhbCkgPyBudW1WYWwgOiByYW5nZS5taW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGFuYWx5c2lzLmNhdGVnb3JpZXNbY29sdW1uXSkge1xuICAgICAgICAvLyBDb252ZXJ0aXIgbGVzIGNhdMOpZ29yaWVzIGVuIGluZGljZXMgbnVtw6lyaXF1ZXNcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IGFuYWx5c2lzLmNhdGVnb3JpZXNbY29sdW1uXVxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IHJvd1tjb2x1bW5dXG4gICAgICAgICAgY29uc3QgaW5kZXggPSBjYXRlZ29yaWVzLmluZGV4T2YodmFsKVxuICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gaW5kZXggOiAwXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEubWFwKChfLCBpKSA9PiBpKVxuICB9XG5cbiAgLy8gVklTVUFMSVNBVElPTlMgU1DDiUNJQUxJU8OJRVMgQVZFQyBET05Ow4lFUyBEWU5BTUlRVUVTXG5cbiAgLy8gMS4gTlVBR0UgQ0xBU1NJUVVFIC0gQWRhcHTDqSBhdXggZG9ubsOpZXNcbiAgY29uc3QgcmVuZGVyQ2xhc3NpY1NjYXR0ZXIgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4ge1xuICAgIGNvbnN0IHhWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieEF4aXNcIilcbiAgICBjb25zdCB5VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInlBeGlzXCIpXG4gICAgY29uc3QgelZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ6QXhpc1wiKVxuICAgIGNvbnN0IGNvbG9yVmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcImNvbG9yQnlcIilcblxuICAgIC8vIEFkYXB0ZXIgbGEgdGFpbGxlIGRlcyBtYXJxdWV1cnMgc2Vsb24gbGEgZGVuc2l0w6kgZGVzIGRvbm7DqWVzXG4gICAgY29uc3QgbWFya2VyU2l6ZSA9IE1hdGgubWF4KDMsIE1hdGgubWluKDEyLCAxMDAgLyBNYXRoLnNxcnQoZGF0YS5sZW5ndGgpKSlcblxuICAgIGNvbnN0IHBsb3REYXRhID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnNcIixcbiAgICAgICAgeDogeFZhbHVlcyxcbiAgICAgICAgeTogeVZhbHVlcyxcbiAgICAgICAgejogelZhbHVlcyxcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgc2l6ZTogbWFya2VyU2l6ZSxcbiAgICAgICAgICBjb2xvcjogY29sb3JWYWx1ZXMsXG4gICAgICAgICAgY29sb3JzY2FsZTogXCJWaXJpZGlzXCIsXG4gICAgICAgICAgb3BhY2l0eTogTWF0aC5tYXgoMC42LCAxIC0gZGF0YS5sZW5ndGggLyAxMDAwKSwgLy8gVHJhbnNwYXJlbmNlIGFkYXB0w6llXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBhbmFseXNpcy5tYXBwaW5nLmNvbG9yQnksXG4gICAgICAgICAgICB0aXRsZWZvbnQ6IHsgc2l6ZTogMTAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0OiBkYXRhLm1hcCgocm93LCBpKSA9PiB7XG4gICAgICAgICAgbGV0IHRvb2x0aXAgPSBgPGI+UG9pbnQgJHtpICsgMX08L2I+PGJyPmBcbiAgICAgICAgICB0b29sdGlwICs9IGA8Yj4ke2FuYWx5c2lzLm1hcHBpbmcueEF4aXN9OjwvYj4gJHtyb3dbYW5hbHlzaXMubWFwcGluZy54QXhpc10gfHwgXCJOL0FcIn08YnI+YFxuICAgICAgICAgIHRvb2x0aXAgKz0gYDxiPiR7YW5hbHlzaXMubWFwcGluZy55QXhpc306PC9iPiAke3Jvd1thbmFseXNpcy5tYXBwaW5nLnlBeGlzXSB8fCBcIk4vQVwifTxicj5gXG4gICAgICAgICAgdG9vbHRpcCArPSBgPGI+JHthbmFseXNpcy5tYXBwaW5nLnpBeGlzfTo8L2I+ICR7cm93W2FuYWx5c2lzLm1hcHBpbmcuekF4aXNdIHx8IFwiTi9BXCJ9PGJyPmBcbiAgICAgICAgICBpZiAoYW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5ICYmIHJvd1thbmFseXNpcy5tYXBwaW5nLmNhdGVnb3J5QnldKSB7XG4gICAgICAgICAgICB0b29sdGlwICs9IGA8Yj4ke2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeX06PC9iPiAke3Jvd1thbmFseXNpcy5tYXBwaW5nLmNhdGVnb3J5QnldfTxicj5gXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b29sdGlwXG4gICAgICAgIH0pLFxuICAgICAgICBob3ZlcnRlbXBsYXRlOiBcIiV7dGV4dH08ZXh0cmE+PC9leHRyYT5cIixcbiAgICAgICAgbmFtZTogYE51YWdlIDNEIC0gJHtkYXRhLmxlbmd0aH0gcG9pbnRzYCxcbiAgICAgIH0sXG4gICAgXVxuXG4gICAgY29uc3QgbGF5b3V0ID0gY3JlYXRlRHluYW1pY0xheW91dChcIk51YWdlIDNEIENsYXNzaXF1ZVwiLCBhbmFseXNpcylcbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICAvLyAyLiBERU5TSVTDiSAzRCAtIFZyYWllIGRlbnNpdMOpIGJhc8OpZSBzdXIgbGVzIGRvbm7DqWVzIHLDqWVsbGVzXG4gIGNvbnN0IHJlbmRlckRlbnNpdHlTY2F0dGVyID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICBjb25zdCB4VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInhBeGlzXCIpXG4gICAgY29uc3QgeVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ5QXhpc1wiKVxuICAgIGNvbnN0IHpWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiekF4aXNcIilcblxuICAgIC8vIEFkYXB0ZXIgbGEgcsOpc29sdXRpb24gZGUgbGEgZ3JpbGxlIHNlbG9uIGxlIG5vbWJyZSBkZSBkb25uw6llc1xuICAgIGNvbnN0IGdyaWRTaXplID0gTWF0aC5taW4oMjUsIE1hdGgubWF4KDEwLCBNYXRoLnNxcnQoZGF0YS5sZW5ndGgpKSlcblxuICAgIGNvbnN0IHhSYW5nZSA9IGFuYWx5c2lzLmRhdGFSYW5nZXNbYW5hbHlzaXMubWFwcGluZy54QXhpc11cbiAgICBjb25zdCB5UmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcueUF4aXNdXG4gICAgY29uc3QgelJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLnpBeGlzXVxuXG4gICAgaWYgKCF4UmFuZ2UgfHwgIXlSYW5nZSB8fCAhelJhbmdlKSB7XG4gICAgICByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRlbnNpdHlYID0gW11cbiAgICBjb25zdCBkZW5zaXR5WSA9IFtdXG4gICAgY29uc3QgZGVuc2l0eVogPSBbXVxuICAgIGNvbnN0IGRlbnNpdHlDb2xvcnMgPSBbXVxuICAgIGNvbnN0IGRlbnNpdHlTaXplcyA9IFtdXG5cbiAgICAvLyBDYWxjdWxlciBsZSByYXlvbiBhZGFwdGF0aWYgYmFzw6kgc3VyIGxlcyB2cmFpZXMgZG9ubsOpZXNcbiAgICBjb25zdCB4U3BhbiA9IHhSYW5nZS5tYXggLSB4UmFuZ2UubWluXG4gICAgY29uc3QgeVNwYW4gPSB5UmFuZ2UubWF4IC0geVJhbmdlLm1pblxuICAgIGNvbnN0IHpTcGFuID0gelJhbmdlLm1heCAtIHpSYW5nZS5taW5cbiAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1heCh4U3BhbiwgeVNwYW4sIHpTcGFuKSAvIChncmlkU2l6ZSAqIDAuOClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZFNpemU7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmlkU2l6ZTsgaisrKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZ3JpZFNpemU7IGsrKykge1xuICAgICAgICAgIGNvbnN0IHggPSB4UmFuZ2UubWluICsgKGkgLyAoZ3JpZFNpemUgLSAxKSkgKiB4U3BhblxuICAgICAgICAgIGNvbnN0IHkgPSB5UmFuZ2UubWluICsgKGogLyAoZ3JpZFNpemUgLSAxKSkgKiB5U3BhblxuICAgICAgICAgIGNvbnN0IHogPSB6UmFuZ2UubWluICsgKGsgLyAoZ3JpZFNpemUgLSAxKSkgKiB6U3BhblxuXG4gICAgICAgICAgLy8gQ2FsY3VsZXIgbGEgZGVuc2l0w6kgbG9jYWxlIGF2ZWMgbGVzIHZyYWllcyBkb25uw6llc1xuICAgICAgICAgIGxldCBkZW5zaXR5ID0gMFxuICAgICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgZGF0YS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgY29uc3QgZHggPSB4VmFsdWVzW3BdIC0geFxuICAgICAgICAgICAgY29uc3QgZHkgPSB5VmFsdWVzW3BdIC0geVxuICAgICAgICAgICAgY29uc3QgZHogPSB6VmFsdWVzW3BdIC0gelxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgcmFkaXVzKSB7XG4gICAgICAgICAgICAgIGRlbnNpdHkgKz0gTWF0aC5leHAoLShkaXN0YW5jZSAqIGRpc3RhbmNlKSAvIChyYWRpdXMgKiByYWRpdXMpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldWlsIGFkYXB0YXRpZiBiYXPDqSBzdXIgbGEgZGVuc2l0w6kgbW95ZW5uZVxuICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IChkYXRhLmxlbmd0aCAvIChncmlkU2l6ZSAqIGdyaWRTaXplICogZ3JpZFNpemUpKSAqIDAuNVxuICAgICAgICAgIGlmIChkZW5zaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBkZW5zaXR5WC5wdXNoKHgpXG4gICAgICAgICAgICBkZW5zaXR5WS5wdXNoKHkpXG4gICAgICAgICAgICBkZW5zaXR5Wi5wdXNoKHopXG4gICAgICAgICAgICBkZW5zaXR5Q29sb3JzLnB1c2goZGVuc2l0eSlcbiAgICAgICAgICAgIGRlbnNpdHlTaXplcy5wdXNoKE1hdGgubWF4KDQsIE1hdGgubWluKDIwLCBkZW5zaXR5ICogMTUpKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwbG90RGF0YSA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzY2F0dGVyM2RcIixcbiAgICAgICAgbW9kZTogXCJtYXJrZXJzXCIsXG4gICAgICAgIHg6IGRlbnNpdHlYLFxuICAgICAgICB5OiBkZW5zaXR5WSxcbiAgICAgICAgejogZGVuc2l0eVosXG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgIHNpemU6IGRlbnNpdHlTaXplcyxcbiAgICAgICAgICBjb2xvcjogZGVuc2l0eUNvbG9ycyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIkhvdFwiLFxuICAgICAgICAgIG9wYWNpdHk6IDAuNyxcbiAgICAgICAgICBjb2xvcmJhcjoge1xuICAgICAgICAgICAgdGl0bGU6IFwiRGVuc2l0w6kgTG9jYWxlXCIsXG4gICAgICAgICAgICB0aXRsZWZvbnQ6IHsgc2l6ZTogMTAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0OiBkZW5zaXR5WC5tYXAoXG4gICAgICAgICAgKF8sIGkpID0+XG4gICAgICAgICAgICBgPGI+Wm9uZSBEZW5zZSAke2kgKyAxfTwvYj48YnI+RGVuc2l0w6k6ICR7ZGVuc2l0eUNvbG9yc1tpXS50b0ZpeGVkKDIpfTxicj5Qb3NpdGlvbjogKCR7ZGVuc2l0eVhbaV0udG9GaXhlZCgxKX0sICR7ZGVuc2l0eVlbaV0udG9GaXhlZCgxKX0sICR7ZGVuc2l0eVpbaV0udG9GaXhlZCgxKX0pYCxcbiAgICAgICAgKSxcbiAgICAgICAgaG92ZXJ0ZW1wbGF0ZTogXCIle3RleHR9PGV4dHJhPjwvZXh0cmE+XCIsXG4gICAgICAgIG5hbWU6IGBEZW5zaXTDqSAzRCAtICR7ZGVuc2l0eVgubGVuZ3RofSB6b25lc2AsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZUR5bmFtaWNMYXlvdXQoXCJEZW5zaXTDqSAzRCAtIFpvbmVzIGRlIENvbmNlbnRyYXRpb25cIiwgYW5hbHlzaXMpXG4gICAgd2luZG93LlBsb3RseS5uZXdQbG90KHBsb3RSZWYuY3VycmVudCwgcGxvdERhdGEsIGxheW91dCwgZ2V0UGxvdENvbmZpZygpKVxuICB9XG5cbiAgLy8gMy4gQlVMTEVTIDNEIC0gVGFpbGxlcyB2cmFpbWVudCBwcm9wb3J0aW9ubmVsbGVzIGF1eCBkb25uw6llc1xuICBjb25zdCByZW5kZXJCdWJibGVTY2F0dGVyID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICBjb25zdCB4VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInhBeGlzXCIpXG4gICAgY29uc3QgeVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ5QXhpc1wiKVxuICAgIGNvbnN0IHpWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiekF4aXNcIilcbiAgICBjb25zdCBjb2xvclZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJjb2xvckJ5XCIpXG4gICAgY29uc3Qgc2l6ZVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJzaXplQnlcIilcblxuICAgIC8vIEFkYXB0ZXIgbGEgdGFpbGxlIGRlcyBidWxsZXMgc2Vsb24gbGVzIGRvbm7DqWVzXG4gICAgY29uc3QgbWluU2l6ZSA9IDEwXG4gICAgY29uc3QgbWF4U2l6ZSA9IDUwXG4gICAgY29uc3Qgbm9ybWFsaXplZFNpemVzID0gc2l6ZVZhbHVlcy5tYXAodiA9PiB7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi5zaXplVmFsdWVzKVxuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4uc2l6ZVZhbHVlcylcbiAgICAgIHJldHVybiBtaW5TaXplICsgKCh2IC0gbWluKSAvIChtYXggLSBtaW4pKSAqIChtYXhTaXplIC0gbWluU2l6ZSlcbiAgICB9KVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2Vyc1wiLFxuICAgICAgICB4OiB4VmFsdWVzLFxuICAgICAgICB5OiB5VmFsdWVzLFxuICAgICAgICB6OiB6VmFsdWVzLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBzaXplOiBub3JtYWxpemVkU2l6ZXMsXG4gICAgICAgICAgY29sb3I6IGNvbG9yVmFsdWVzLFxuICAgICAgICAgIGNvbG9yc2NhbGU6IFwiUGxhc21hXCIsXG4gICAgICAgICAgb3BhY2l0eTogMC43NSxcbiAgICAgICAgICBjb2xvcmJhcjoge1xuICAgICAgICAgICAgdGl0bGU6IGFuYWx5c2lzLm1hcHBpbmcuY29sb3JCeSxcbiAgICAgICAgICAgIHRpdGxlZm9udDogeyBzaXplOiAxMCB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGluZTogeyBjb2xvcjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMylcIiwgd2lkdGg6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogZGF0YS5tYXAoKHJvdywgaSkgPT4ge1xuICAgICAgICAgIGxldCB0b29sdGlwID0gYDxiPkJ1bGxlICR7aSArIDF9PC9iPjxicj5gXG4gICAgICAgICAgdG9vbHRpcCArPSBgPGI+VGFpbGxlICgke2FuYWx5c2lzLm1hcHBpbmcuc2l6ZUJ5fSk6PC9iPiAke3Jvd1thbmFseXNpcy5tYXBwaW5nLnNpemVCeV0gfHwgXCJOL0FcIn08YnI+YFxuICAgICAgICAgIHRvb2x0aXAgKz0gYDxiPkNvdWxldXIgKCR7YW5hbHlzaXMubWFwcGluZy5jb2xvckJ5fSk6PC9iPiAke3Jvd1thbmFseXNpcy5tYXBwaW5nLmNvbG9yQnldIHx8IFwiTi9BXCJ9PGJyPmBcbiAgICAgICAgICBpZiAoYW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5ICYmIHJvd1thbmFseXNpcy5tYXBwaW5nLmNhdGVnb3J5QnldKSB7XG4gICAgICAgICAgICB0b29sdGlwICs9IGA8Yj5DYXTDqWdvcmllOjwvYj4gJHtyb3dbYW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5XX08YnI+YFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9vbHRpcFxuICAgICAgICB9KSxcbiAgICAgICAgaG92ZXJ0ZW1wbGF0ZTogXCIle3RleHR9PGV4dHJhPjwvZXh0cmE+XCIsXG4gICAgICAgIG5hbWU6IGBCdWxsZXMgM0QgLSAke2RhdGEubGVuZ3RofSDDqWzDqW1lbnRzYCxcbiAgICAgIH0sXG4gICAgXVxuXG4gICAgY29uc3QgbGF5b3V0ID0gY3JlYXRlRHluYW1pY0xheW91dChcIkJ1bGxlcyAzRCAtIFRhaWxsZXMgUHJvcG9ydGlvbm5lbGxlc1wiLCBhbmFseXNpcylcbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICAvLyA0LiBNQU5EQUxBIDNEIC0gQmFzw6kgc3VyIGxlcyBwYXR0ZXJucyBkZXMgZG9ubsOpZXNcbiAgY29uc3QgcmVuZGVyTWFuZGFsYTNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICBjb25zdCBjb2xvclZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJjb2xvckJ5XCIpXG4gICAgY29uc3Qgc2l6ZVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJzaXplQnlcIilcblxuICAgIGNvbnN0IG1hbmRhbGFYID0gW11cbiAgICBjb25zdCBtYW5kYWxhWSA9IFtdXG4gICAgY29uc3QgbWFuZGFsYVogPSBbXVxuICAgIGNvbnN0IG1hbmRhbGFDb2xvcnMgPSBbXVxuICAgIGNvbnN0IG1hbmRhbGFTaXplcyA9IFtdXG5cbiAgICAvLyBVdGlsaXNlciBsZXMgdnJhaWVzIGRvbm7DqWVzIHBvdXIgY3LDqWVyIGxlcyBwYXR0ZXJuc1xuICAgIGRhdGEuZm9yRWFjaCgocm93LCBpKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkSW5kZXggPSBpIC8gZGF0YS5sZW5ndGhcbiAgICAgIGNvbnN0IGNvbG9yVmFsID0gY29sb3JWYWx1ZXNbaV1cbiAgICAgIGNvbnN0IHNpemVWYWwgPSBzaXplVmFsdWVzW2ldXG5cbiAgICAgIC8vIE5vbWJyZSBkZSB0b3VycyBiYXPDqSBzdXIgbGEgdmFyaWFuY2UgZGVzIGRvbm7DqWVzXG4gICAgICBjb25zdCBjb2xvclJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLmNvbG9yQnldXG4gICAgICBjb25zdCB0b3VycyA9IGNvbG9yUmFuZ2UgPyA0ICsgKChjb2xvclZhbCAtIGNvbG9yUmFuZ2UubWluKSAvIChjb2xvclJhbmdlLm1heCAtIGNvbG9yUmFuZ2UubWluKSkgKiA0IDogNlxuXG4gICAgICBjb25zdCBhbmdsZSA9IG5vcm1hbGl6ZWRJbmRleCAqIHRvdXJzICogTWF0aC5QSVxuICAgICAgY29uc3QgcmFkaXVzID0gMSArIE1hdGguc2luKGFuZ2xlICogMykgKiAwLjVcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguc2luKGFuZ2xlICogMikgKiAwLjNcblxuICAgICAgLy8gUG9pbnQgcHJpbmNpcGFsXG4gICAgICBtYW5kYWxhWC5wdXNoKE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cylcbiAgICAgIG1hbmRhbGFZLnB1c2goTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzKVxuICAgICAgbWFuZGFsYVoucHVzaChoZWlnaHQpXG4gICAgICBtYW5kYWxhQ29sb3JzLnB1c2goY29sb3JWYWwpXG4gICAgICBtYW5kYWxhU2l6ZXMucHVzaChNYXRoLm1heCgzLCBNYXRoLm1pbig4LCAoc2l6ZVZhbCAvIChjb2xvclJhbmdlPy5tYXggfHwgMSkpICogNiArIDMpKSlcblxuICAgICAgLy8gUMOpdGFsZXMgYmFzw6lzIHN1ciBsZXMgY2F0w6lnb3JpZXNcbiAgICAgIGNvbnN0IG51bVBldGFscyA9XG4gICAgICAgIGFuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeSAmJiBhbmFseXNpcy5jYXRlZ29yaWVzW2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeV1cbiAgICAgICAgICA/IE1hdGgubWluKDYsIGFuYWx5c2lzLmNhdGVnb3JpZXNbYW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5XS5sZW5ndGgpXG4gICAgICAgICAgOiA1XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtUGV0YWxzOyBqKyspIHtcbiAgICAgICAgY29uc3QgcGV0YWxBbmdsZSA9IGFuZ2xlICsgKGogKiAyICogTWF0aC5QSSkgLyBudW1QZXRhbHNcbiAgICAgICAgY29uc3QgcGV0YWxSYWRpdXMgPSByYWRpdXMgKiAwLjNcbiAgICAgICAgbWFuZGFsYVgucHVzaChNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKyBNYXRoLmNvcyhwZXRhbEFuZ2xlKSAqIHBldGFsUmFkaXVzKVxuICAgICAgICBtYW5kYWxhWS5wdXNoKE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyArIE1hdGguc2luKHBldGFsQW5nbGUpICogcGV0YWxSYWRpdXMpXG4gICAgICAgIG1hbmRhbGFaLnB1c2goaGVpZ2h0ICsgTWF0aC5zaW4ocGV0YWxBbmdsZSAqIDIpICogMC4xKVxuICAgICAgICBtYW5kYWxhQ29sb3JzLnB1c2goY29sb3JWYWwgKiAwLjgpXG4gICAgICAgIG1hbmRhbGFTaXplcy5wdXNoKE1hdGgubWF4KDIsIG1hbmRhbGFTaXplc1ttYW5kYWxhU2l6ZXMubGVuZ3RoIC0gMV0gKiAwLjYpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBwbG90RGF0YSA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzY2F0dGVyM2RcIixcbiAgICAgICAgbW9kZTogXCJtYXJrZXJzXCIsXG4gICAgICAgIHg6IG1hbmRhbGFYLFxuICAgICAgICB5OiBtYW5kYWxhWSxcbiAgICAgICAgejogbWFuZGFsYVosXG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgIHNpemU6IG1hbmRhbGFTaXplcyxcbiAgICAgICAgICBjb2xvcjogbWFuZGFsYUNvbG9ycyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlJhaW5ib3dcIixcbiAgICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBgSGFybW9uaWUgKCR7YW5hbHlzaXMubWFwcGluZy5jb2xvckJ5fSlgLFxuICAgICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogYE1hbmRhbGEgM0QgLSAke2RhdGEubGVuZ3RofSDDqWzDqW1lbnRzIHNvdXJjZWAsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZUR5bmFtaWNMYXlvdXQoXCJNYW5kYWxhIDNEIC0gTW90aWZzIFNhY3LDqXNcIiwgYW5hbHlzaXMpXG4gICAgbGF5b3V0LnNjZW5lLmNhbWVyYSA9IHsgZXllOiB7IHg6IDAsIHk6IDAsIHo6IDIuNSB9IH1cbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICAvLyA1LiBHQUxBWElFIDNEIC0gU3RydWN0dXJlIGJhc8OpZSBzdXIgbGVzIGRvbm7DqWVzXG4gIGNvbnN0IHJlbmRlckdhbGF4eTNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICBjb25zdCBjb2xvclZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJjb2xvckJ5XCIpXG4gICAgY29uc3Qgc2l6ZVZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJzaXplQnlcIilcblxuICAgIGNvbnN0IGdhbGF4eVggPSBbXVxuICAgIGNvbnN0IGdhbGF4eVkgPSBbXVxuICAgIGNvbnN0IGdhbGF4eVogPSBbXVxuICAgIGNvbnN0IGdhbGF4eUNvbG9ycyA9IFtdXG4gICAgY29uc3QgZ2FsYXh5U2l6ZXMgPSBbXVxuXG4gICAgLy8gQW5hbHlzZXIgbGEgZGlzdHJpYnV0aW9uIHBvdXIgY3LDqWVyIGxlcyBicmFzIGdhbGFjdGlxdWVzXG4gICAgY29uc3QgY29sb3JSYW5nZSA9IGFuYWx5c2lzLmRhdGFSYW5nZXNbYW5hbHlzaXMubWFwcGluZy5jb2xvckJ5XVxuICAgIGNvbnN0IHNpemVSYW5nZSA9IGFuYWx5c2lzLmRhdGFSYW5nZXNbYW5hbHlzaXMubWFwcGluZy5zaXplQnldXG5cbiAgICBkYXRhLmZvckVhY2goKHJvdywgaSkgPT4ge1xuICAgICAgY29uc3QgdCA9IGkgLyBkYXRhLmxlbmd0aFxuICAgICAgY29uc3QgY29sb3JWYWwgPSBjb2xvclZhbHVlc1tpXVxuICAgICAgY29uc3Qgc2l6ZVZhbCA9IHNpemVWYWx1ZXNbaV1cblxuICAgICAgLy8gUG9zaXRpb24gZGFucyBsYSBnYWxheGllIGJhc8OpZSBzdXIgbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzXG4gICAgICBjb25zdCBub3JtYWxpemVkQ29sb3IgPSBjb2xvclJhbmdlID8gKGNvbG9yVmFsIC0gY29sb3JSYW5nZS5taW4pIC8gKGNvbG9yUmFuZ2UubWF4IC0gY29sb3JSYW5nZS5taW4pIDogdFxuICAgICAgY29uc3Qgbm9ybWFsaXplZFNpemUgPSBzaXplUmFuZ2UgPyAoc2l6ZVZhbCAtIHNpemVSYW5nZS5taW4pIC8gKHNpemVSYW5nZS5tYXggLSBzaXplUmFuZ2UubWluKSA6IDAuNVxuXG4gICAgICAvLyBBbmdsZSBldCByYXlvbiBiYXPDqXMgc3VyIGxlcyBkb25uw6llc1xuICAgICAgY29uc3QgYW5nbGUgPSBub3JtYWxpemVkQ29sb3IgKiA2ICogTWF0aC5QSSArIHQgKiAyICogTWF0aC5QSVxuICAgICAgY29uc3QgcmFkaXVzID0gbm9ybWFsaXplZFNpemUgKiAzICsgdCAqIDAuNVxuICAgICAgY29uc3QgaGVpZ2h0ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4yICogKDEgLSB0KSAvLyBQbHVzIHBsYXQgdmVycyBsJ2V4dMOpcmlldXJcblxuICAgICAgLy8gQnJhcyBwcmluY2lwYWxcbiAgICAgIGdhbGF4eVgucHVzaChNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMpXG4gICAgICBnYWxheHlZLnB1c2goTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzKVxuICAgICAgZ2FsYXh5Wi5wdXNoKGhlaWdodClcbiAgICAgIGdhbGF4eUNvbG9ycy5wdXNoKGNvbG9yVmFsKVxuICAgICAgZ2FsYXh5U2l6ZXMucHVzaChNYXRoLm1heCgyLCBNYXRoLm1pbigxMiwgKDEgLSBub3JtYWxpemVkU2l6ZSkgKiA4ICsgMykpKVxuXG4gICAgICAvLyBCcmFzIHNlY29uZGFpcmUgc2kgYXNzZXogZGUgZG9ubsOpZXNcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgIGNvbnN0IGFuZ2xlMiA9IGFuZ2xlICsgTWF0aC5QSSAqIDAuOFxuICAgICAgICBjb25zdCByYWRpdXMyID0gcmFkaXVzICogMC43XG4gICAgICAgIGdhbGF4eVgucHVzaChNYXRoLmNvcyhhbmdsZTIpICogcmFkaXVzMilcbiAgICAgICAgZ2FsYXh5WS5wdXNoKE1hdGguc2luKGFuZ2xlMikgKiByYWRpdXMyKVxuICAgICAgICBnYWxheHlaLnB1c2goaGVpZ2h0ICogMC41KVxuICAgICAgICBnYWxheHlDb2xvcnMucHVzaChjb2xvclZhbCAqIDAuOClcbiAgICAgICAgZ2FsYXh5U2l6ZXMucHVzaChNYXRoLm1heCgxLCBnYWxheHlTaXplc1tnYWxheHlTaXplcy5sZW5ndGggLSAxXSAqIDAuNykpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IHBsb3REYXRhID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnNcIixcbiAgICAgICAgeDogZ2FsYXh5WCxcbiAgICAgICAgeTogZ2FsYXh5WSxcbiAgICAgICAgejogZ2FsYXh5WixcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgc2l6ZTogZ2FsYXh5U2l6ZXMsXG4gICAgICAgICAgY29sb3I6IGdhbGF4eUNvbG9ycyxcbiAgICAgICAgICBjb2xvcnNjYWxlOiBcIlZpcmlkaXNcIixcbiAgICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBgTHVtaW5vc2l0w6kgKCR7YW5hbHlzaXMubWFwcGluZy5jb2xvckJ5fSlgLFxuICAgICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogYEdhbGF4aWUgM0QgLSAke2RhdGEubGVuZ3RofSDDqXRvaWxlc2AsXG4gICAgICB9LFxuICAgIF1cblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZUR5bmFtaWNMYXlvdXQoXCJHYWxheGllIDNEIC0gU3BpcmFsZSBDb3NtaXF1ZVwiLCBhbmFseXNpcylcbiAgICBsYXlvdXQuc2NlbmUuYmdjb2xvciA9IFwicmdiYSgwLCAwLCAyMCwgMC45KVwiXG4gICAgbGF5b3V0LnNjZW5lLmNhbWVyYSA9IHsgZXllOiB7IHg6IDEuNSwgeTogMS41LCB6OiAxIH0gfVxuICAgIHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90UmVmLmN1cnJlbnQsIHBsb3REYXRhLCBsYXlvdXQsIGdldFBsb3RDb25maWcoKSlcbiAgfVxuXG4gIC8vIDYuIFRJTUVMSU5FIDNEIC0gUG91ciBkb25uw6llcyB0ZW1wb3JlbGxlc1xuICBjb25zdCByZW5kZXJUaW1lbGluZTNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICAvLyBDaGVyY2hlciB1bmUgY29sb25uZSB0ZW1wb3JlbGxlXG4gICAgY29uc3QgdGltZUNvbHVtbiA9IGFuYWx5c2lzLnRlbXBvcmFsQ29sdW1uc1swXSB8fCBhbmFseXNpcy5tYXBwaW5nLnhBeGlzXG4gICAgY29uc3QgdmFsdWVDb2x1bW4gPSBhbmFseXNpcy5tYXBwaW5nLnlBeGlzXG4gICAgY29uc3QgY29sb3JDb2x1bW4gPSBhbmFseXNpcy5tYXBwaW5nLmNvbG9yQnlcblxuICAgIGNvbnN0IHRpbWVWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieEF4aXNcIilcbiAgICBjb25zdCB2YWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieUF4aXNcIilcbiAgICBjb25zdCBjb2xvclZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJjb2xvckJ5XCIpXG5cbiAgICAvLyBUcmllciBwYXIgdGVtcHMgc2kgYydlc3QgdGVtcG9yZWxcbiAgICBjb25zdCBzb3J0ZWRJbmRpY2VzID0gdGltZVZhbHVlcy5tYXAoKF8sIGkpID0+IGkpLnNvcnQoKGEsIGIpID0+IHRpbWVWYWx1ZXNbYV0gLSB0aW1lVmFsdWVzW2JdKVxuXG4gICAgY29uc3QgdGltZWxpbmVYID0gc29ydGVkSW5kaWNlcy5tYXAoKGkpID0+IHRpbWVWYWx1ZXNbaV0pXG4gICAgY29uc3QgdGltZWxpbmVZID0gc29ydGVkSW5kaWNlcy5tYXAoKGkpID0+IHZhbHVlc1tpXSlcbiAgICBjb25zdCB0aW1lbGluZVogPSBzb3J0ZWRJbmRpY2VzLm1hcCgoXywgaSkgPT4gaSAqIDAuMSkgLy8gw4lsw6l2YXRpb24gcHJvZ3Jlc3NpdmVcbiAgICBjb25zdCB0aW1lbGluZUNvbG9ycyA9IHNvcnRlZEluZGljZXMubWFwKChpKSA9PiBjb2xvclZhbHVlc1tpXSlcblxuICAgIGNvbnN0IHBsb3REYXRhID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInNjYXR0ZXIzZFwiLFxuICAgICAgICBtb2RlOiBcIm1hcmtlcnMrbGluZXNcIixcbiAgICAgICAgeDogdGltZWxpbmVYLFxuICAgICAgICB5OiB0aW1lbGluZVksXG4gICAgICAgIHo6IHRpbWVsaW5lWixcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgc2l6ZTogNixcbiAgICAgICAgICBjb2xvcjogdGltZWxpbmVDb2xvcnMsXG4gICAgICAgICAgY29sb3JzY2FsZTogXCJWaXJpZGlzXCIsXG4gICAgICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgICAgIGNvbG9yYmFyOiB7XG4gICAgICAgICAgICB0aXRsZTogYW5hbHlzaXMubWFwcGluZy5jb2xvckJ5LFxuICAgICAgICAgICAgdGl0bGVmb250OiB7IHNpemU6IDEwIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIGNvbG9yOiBcInJnYmEoMTAwLCAxMDAsIDEwMCwgMC42KVwiLFxuICAgICAgICAgIHdpZHRoOiAzLFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0OiBzb3J0ZWRJbmRpY2VzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJvdyA9IGRhdGFbaV1cbiAgICAgICAgICBsZXQgdG9vbHRpcCA9IGA8Yj5Qb2ludCB0ZW1wb3JlbCAke2kgKyAxfTwvYj48YnI+YFxuICAgICAgICAgIHRvb2x0aXAgKz0gYDxiPlRlbXBzOjwvYj4gJHtyb3dbdGltZUNvbHVtbl0gfHwgXCJOL0FcIn08YnI+YFxuICAgICAgICAgIHRvb2x0aXAgKz0gYDxiPlZhbGV1cjo8L2I+ICR7cm93W3ZhbHVlQ29sdW1uXSB8fCBcIk4vQVwifTxicj5gXG4gICAgICAgICAgcmV0dXJuIHRvb2x0aXBcbiAgICAgICAgfSksXG4gICAgICAgIGhvdmVydGVtcGxhdGU6IFwiJXt0ZXh0fTxleHRyYT48L2V4dHJhPlwiLFxuICAgICAgICBuYW1lOiBgVGltZWxpbmUgM0QgLSAke2RhdGEubGVuZ3RofSBwb2ludHNgLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVEeW5hbWljTGF5b3V0KFwiVGltZWxpbmUgM0QgLSDDiXZvbHV0aW9uIFRlbXBvcmVsbGVcIiwgYW5hbHlzaXMpXG4gICAgd2luZG93LlBsb3RseS5uZXdQbG90KHBsb3RSZWYuY3VycmVudCwgcGxvdERhdGEsIGxheW91dCwgZ2V0UGxvdENvbmZpZygpKVxuICB9XG5cbiAgLy8gRm9uY3Rpb25zIGRlIHJlbmR1IHNpbXBsaWZpw6llcyBwb3VyIGxlcyBhdXRyZXMgbW9kw6hsZXNcbiAgY29uc3QgcmVuZGVyQW5pbWF0ZWRTY2F0dGVyID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJDbHVzdGVyZWRTY2F0dGVyID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckJ1YmJsZVNjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckNsYXNzaWNTdXJmYWNlID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNvbnRvdXJTdXJmYWNlKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJNZXNoU3VyZmFjZSA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDb250b3VyU3VyZmFjZShhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyR3JhZGllbnRTdXJmYWNlID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNvbnRvdXJTdXJmYWNlKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJDbGFzc2ljQmFycyA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJCdWJibGVTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJHcm91cGVkQmFycyA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJCdWJibGVTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJDeWxpbmRyaWNhbEJhcnMgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQnViYmxlU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyUHlyYW1pZEJhcnMgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQnViYmxlU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyU3BoZXJlUGFjayA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJCdWJibGVTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJDdWJlTWF0cml4ID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJDb25lRmllbGQgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlckhlbGl4U3BpcmFsID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckROQUhlbGl4KGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJGcmFjdGFsM0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyTWFuZGFsYTNEKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJDcnlzdGFsM0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlck5ldHdvcmszRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJDbGFzc2ljU2NhdHRlcihhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyVHJlZTNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJXYXZlVGVtcG9yYWwgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyVGltZWxpbmUzRChhbmFseXNpcylcbiAgY29uc3QgcmVuZGVyU3BpcmFsVGltZSA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJUaW1lbGluZTNEKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJHbG9iZTNEID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJUZXJyYWluM0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ29udG91clN1cmZhY2UoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlck1vbGVjdWxlM0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQ2xhc3NpY1NjYXR0ZXIoYW5hbHlzaXMpXG4gIGNvbnN0IHJlbmRlclZlY3RvckZpZWxkID0gKGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJIaXN0b2dyYW0zRCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiByZW5kZXJCdWJibGVTY2F0dGVyKGFuYWx5c2lzKVxuICBjb25zdCByZW5kZXJCb3hQbG90M0QgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4gcmVuZGVyQnViYmxlU2NhdHRlcihhbmFseXNpcylcblxuICAvLyA3LiBTVVJGQUNFIEFWRUMgQ09OVE9VUlMgLSBCYXPDqWUgc3VyIGxlcyB2cmFpZXMgZG9ubsOpZXNcbiAgY29uc3QgcmVuZGVyQ29udG91clN1cmZhY2UgPSAoYW5hbHlzaXM6IERhdGFBbmFseXNpcykgPT4ge1xuICAgIGNvbnN0IHhWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwieEF4aXNcIilcbiAgICBjb25zdCB5VmFsdWVzID0gZ2V0VmFsdWVzRnJvbUFuYWx5c2lzKGFuYWx5c2lzLCBcInlBeGlzXCIpXG4gICAgY29uc3QgelZhbHVlcyA9IGdldFZhbHVlc0Zyb21BbmFseXNpcyhhbmFseXNpcywgXCJ6QXhpc1wiKVxuXG4gICAgY29uc3QgeFJhbmdlID0gYW5hbHlzaXMuZGF0YVJhbmdlc1thbmFseXNpcy5tYXBwaW5nLnhBeGlzXVxuICAgIGNvbnN0IHlSYW5nZSA9IGFuYWx5c2lzLmRhdGFSYW5nZXNbYW5hbHlzaXMubWFwcGluZy55QXhpc11cblxuICAgIGlmICgheFJhbmdlIHx8ICF5UmFuZ2UpIHtcbiAgICAgIHJlbmRlckNsYXNzaWNTY2F0dGVyKGFuYWx5c2lzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQWRhcHRlciBsYSByw6lzb2x1dGlvbiBzZWxvbiBsYSBkZW5zaXTDqSBkZXMgZG9ubsOpZXNcbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4oMzAsIE1hdGgubWF4KDE1LCBNYXRoLnNxcnQoZGF0YS5sZW5ndGgpKSlcbiAgICBjb25zdCB4TWluID0geFJhbmdlLm1pblxuICAgIGNvbnN0IHhNYXggPSB4UmFuZ2UubWF4XG4gICAgY29uc3QgeU1pbiA9IHlSYW5nZS5taW5cbiAgICBjb25zdCB5TWF4ID0geVJhbmdlLm1heFxuXG4gICAgY29uc3QgeEdyaWQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzaXplIH0sIChfLCBpKSA9PiB4TWluICsgKGkgLyAoc2l6ZSAtIDEpKSAqICh4TWF4IC0geE1pbikpXG4gICAgY29uc3QgeUdyaWQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzaXplIH0sIChfLCBpKSA9PiB5TWluICsgKGkgLyAoc2l6ZSAtIDEpKSAqICh5TWF4IC0geU1pbikpXG5cbiAgICBjb25zdCBzdXJmYWNlID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgY29uc3Qgcm93ID0gW11cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZTsgaisrKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFggPSB4R3JpZFtqXVxuICAgICAgICBjb25zdCB0YXJnZXRZID0geUdyaWRbaV1cblxuICAgICAgICAvLyBJbnRlcnBvbGF0aW9uIHBvbmTDqXLDqWUgcGFyIGxhIGRpc3RhbmNlXG4gICAgICAgIGxldCB3ZWlnaHRlZFN1bSA9IDBcbiAgICAgICAgbGV0IHRvdGFsV2VpZ2h0ID0gMFxuICAgICAgICBjb25zdCBtYXhEaXN0YW5jZSA9IE1hdGguc3FydCgoeE1heCAtIHhNaW4pICoqIDIgKyAoeU1heCAtIHlNaW4pICoqIDIpIC8gNVxuXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGR4ID0geFZhbHVlc1trXSAtIHRhcmdldFhcbiAgICAgICAgICBjb25zdCBkeSA9IHlWYWx1ZXNba10gLSB0YXJnZXRZXG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gTWF0aC5leHAoLShkaXN0YW5jZSAqIGRpc3RhbmNlKSAvIChtYXhEaXN0YW5jZSAqIG1heERpc3RhbmNlKSlcbiAgICAgICAgICAgIHdlaWdodGVkU3VtICs9IHpWYWx1ZXNba10gKiB3ZWlnaHRcbiAgICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJvdy5wdXNoKHRvdGFsV2VpZ2h0ID4gMCA/IHdlaWdodGVkU3VtIC8gdG90YWxXZWlnaHQgOiAwKVxuICAgICAgfVxuICAgICAgc3VyZmFjZS5wdXNoKHJvdylcbiAgICB9XG5cbiAgICBjb25zdCBwbG90RGF0YSA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzdXJmYWNlXCIsXG4gICAgICAgIHo6IHN1cmZhY2UsXG4gICAgICAgIHg6IHhHcmlkLFxuICAgICAgICB5OiB5R3JpZCxcbiAgICAgICAgY29sb3JzY2FsZTogXCJFYXJ0aFwiLFxuICAgICAgICBjb250b3Vyczoge1xuICAgICAgICAgIHo6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICB1c2Vjb2xvcm1hcDogdHJ1ZSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGNvbG9yOiBcIiM0MmY0NjJcIixcbiAgICAgICAgICAgIHByb2plY3Q6IHsgejogdHJ1ZSB9LFxuICAgICAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICB0aXRsZTogYW5hbHlzaXMubWFwcGluZy56QXhpcyxcbiAgICAgICAgICB0aXRsZWZvbnQ6IHsgc2l6ZTogMTAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogYFN1cmZhY2UgLSAke2RhdGEubGVuZ3RofSBwb2ludHMgc291cmNlYCxcbiAgICAgIH0sXG4gICAgXVxuXG4gICAgY29uc3QgbGF5b3V0ID0gY3JlYXRlRHluYW1pY0xheW91dChcIlN1cmZhY2UgM0QgLSBMaWduZXMgZGUgTml2ZWF1XCIsIGFuYWx5c2lzKVxuICAgIHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90UmVmLmN1cnJlbnQsIHBsb3REYXRhLCBsYXlvdXQsIGdldFBsb3RDb25maWcoKSlcbiAgfVxuXG4gIC8vIDguIEjDiUxJQ0UgQUROIC0gQmFzw6llIHN1ciBsZXMgc8OpcXVlbmNlcyBkZSBkb25uw6llc1xuICBjb25zdCByZW5kZXJETkFIZWxpeCA9IChhbmFseXNpczogRGF0YUFuYWx5c2lzKSA9PiB7XG4gICAgY29uc3QgY29sb3JWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwiY29sb3JCeVwiKVxuICAgIGNvbnN0IHNpemVWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tQW5hbHlzaXMoYW5hbHlzaXMsIFwic2l6ZUJ5XCIpXG5cbiAgICBjb25zdCBkbmFYMSA9IFtdXG4gICAgY29uc3QgZG5hWTEgPSBbXVxuICAgIGNvbnN0IGRuYVoxID0gW11cbiAgICBjb25zdCBkbmFYMiA9IFtdXG4gICAgY29uc3QgZG5hWTIgPSBbXVxuICAgIGNvbnN0IGRuYVoyID0gW11cbiAgICBjb25zdCBkbmFDb2xvcnMgPSBbXVxuICAgIGNvbnN0IGRuYVNpemVzID0gW11cblxuICAgIC8vIFV0aWxpc2VyIGxlcyB2cmFpZXMgZG9ubsOpZXMgcG91ciBtb2R1bGVyIGwnaMOpbGljZVxuICAgIGNvbnN0IGNvbG9yUmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcuY29sb3JCeV1cbiAgICBjb25zdCBzaXplUmFuZ2UgPSBhbmFseXNpcy5kYXRhUmFuZ2VzW2FuYWx5c2lzLm1hcHBpbmcuc2l6ZUJ5XVxuXG4gICAgZGF0YS5mb3JFYWNoKChyb3csIGkpID0+IHtcbiAgICAgIGNvbnN0IHQgPSAoaSAvIGRhdGEubGVuZ3RoKSAqIDggKiBNYXRoLlBJXG4gICAgICBjb25zdCB6ID0gKGkgLyBkYXRhLmxlbmd0aCkgKiA0XG5cbiAgICAgIC8vIE1vZHVsYXRpb24gYmFzw6llIHN1ciBsZXMgZG9ubsOpZXNcbiAgICAgIGNvbnN0IGNvbG9yVmFsID0gY29sb3JWYWx1ZXNbaV1cbiAgICAgIGNvbnN0IHNpemVWYWwgPSBzaXplVmFsdWVzW2ldXG5cbiAgICAgIGNvbnN0IHJhZGl1c01vZHVsYXRpb24gPSBjb2xvclJhbmdlXG4gICAgICAgID8gMSArICgwLjMgKiAoY29sb3JWYWwgLSBjb2xvclJhbmdlLm1pbikpIC8gKGNvbG9yUmFuZ2UubWF4IC0gY29sb3JSYW5nZS5taW4pXG4gICAgICAgIDogMVxuICAgICAgY29uc3QgaGVpZ2h0TW9kdWxhdGlvbiA9IHNpemVSYW5nZSA/ICgwLjEgKiAoc2l6ZVZhbCAtIHNpemVSYW5nZS5taW4pKSAvIChzaXplUmFuZ2UubWF4IC0gc2l6ZVJhbmdlLm1pbikgOiAwXG5cbiAgICAgIC8vIFByZW1pZXIgYnJpblxuICAgICAgZG5hWDEucHVzaChNYXRoLmNvcyh0KSAqIHJhZGl1c01vZHVsYXRpb24pXG4gICAgICBkbmFZMS5wdXNoKE1hdGguc2luKHQpICogcmFkaXVzTW9kdWxhdGlvbilcbiAgICAgIGRuYVoxLnB1c2goeiArIGhlaWdodE1vZHVsYXRpb24pXG5cbiAgICAgIC8vIERldXhpw6htZSBicmluIChkw6ljYWzDqSBkZSDPgClcbiAgICAgIGRuYVgyLnB1c2goTWF0aC5jb3ModCArIE1hdGguUEkpICogcmFkaXVzTW9kdWxhdGlvbilcbiAgICAgIGRuYVkyLnB1c2goTWF0aC5zaW4odCArIE1hdGguUEkpICogcmFkaXVzTW9kdWxhdGlvbilcbiAgICAgIGRuYVoyLnB1c2goeiArIGhlaWdodE1vZHVsYXRpb24pXG5cbiAgICAgIGRuYUNvbG9ycy5wdXNoKGNvbG9yVmFsKVxuICAgICAgZG5hU2l6ZXMucHVzaChNYXRoLm1heCg0LCBNYXRoLm1pbigxMCwgKHNpemVWYWwgLyAoc2l6ZVJhbmdlPy5tYXggfHwgMSkpICogNiArIDQpKSlcbiAgICB9KVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2VycytsaW5lc1wiLFxuICAgICAgICB4OiBkbmFYMSxcbiAgICAgICAgeTogZG5hWTEsXG4gICAgICAgIHo6IGRuYVoxLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBzaXplOiBkbmFTaXplcyxcbiAgICAgICAgICBjb2xvcjogZG5hQ29sb3JzLFxuICAgICAgICAgIGNvbG9yc2NhbGU6IFwiUmRZbEJ1XCIsXG4gICAgICAgICAgY29sb3JiYXI6IHtcbiAgICAgICAgICAgIHRpdGxlOiBhbmFseXNpcy5tYXBwaW5nLmNvbG9yQnksXG4gICAgICAgICAgICB0aXRsZWZvbnQ6IHsgc2l6ZTogMTAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBsaW5lOiB7IGNvbG9yOiBcInJnYmEoMjU1LCAxMDAsIDEwMCwgMC44KVwiLCB3aWR0aDogNCB9LFxuICAgICAgICBuYW1lOiBgQnJpbiBBRE4gMSAtICR7ZGF0YS5sZW5ndGh9IGJhc2VzYCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2VycytsaW5lc1wiLFxuICAgICAgICB4OiBkbmFYMixcbiAgICAgICAgeTogZG5hWTIsXG4gICAgICAgIHo6IGRuYVoyLFxuICAgICAgICBtYXJrZXI6IHsgc2l6ZTogZG5hU2l6ZXMsIGNvbG9yOiBkbmFDb2xvcnMsIGNvbG9yc2NhbGU6IFwiUmRZbEJ1XCIgfSxcbiAgICAgICAgbGluZTogeyBjb2xvcjogXCJyZ2JhKDEwMCwgMTAwLCAyNTUsIDAuOClcIiwgd2lkdGg6IDQgfSxcbiAgICAgICAgbmFtZTogYEJyaW4gQUROIDIgLSAke2RhdGEubGVuZ3RofSBiYXNlc2AsXG4gICAgICAgIHNob3dsZWdlbmQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVEeW5hbWljTGF5b3V0KFwiRG91YmxlIEjDqWxpY2UgQUROXCIsIGFuYWx5c2lzKVxuICAgIGxheW91dC5zY2VuZS5jYW1lcmEgPSB7IGV5ZTogeyB4OiAyLCB5OiAwLCB6OiAxIH0gfVxuICAgIHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90UmVmLmN1cnJlbnQsIHBsb3REYXRhLCBsYXlvdXQsIGdldFBsb3RDb25maWcoKSlcbiAgfVxuXG4gIC8vIEZvbmN0aW9uIHBvdXIgY3LDqWVyIHVuIGxheW91dCBkeW5hbWlxdWUgYmFzw6kgc3VyIGwnYW5hbHlzZVxuICBjb25zdCBjcmVhdGVEeW5hbWljTGF5b3V0ID0gKHRpdGxlOiBzdHJpbmcsIGFuYWx5c2lzOiBEYXRhQW5hbHlzaXMpID0+IHtcbiAgICBjb25zdCBkYXRhSW5mbyA9IGAke2RhdGEubGVuZ3RofSBlbnRyw6llcyDigKIgJHthbmFseXNpcy5udW1lcmljQ29sdW1ucy5sZW5ndGh9IG51bS4g4oCiICR7YW5hbHlzaXMuY2F0ZWdvcmljYWxDb2x1bW5zLmxlbmd0aH0gY2F0LmBcblxuICAgIHJldHVybiB7XG4gICAgICBzY2VuZToge1xuICAgICAgICB4YXhpczoge1xuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0ZXh0OiBgJHthbmFseXNpcy5tYXBwaW5nLnhBeGlzfSAke2FuYWx5c2lzLmRhdGFUeXBlc1thbmFseXNpcy5tYXBwaW5nLnhBeGlzXSA/IGAoJHthbmFseXNpcy5kYXRhVHlwZXNbYW5hbHlzaXMubWFwcGluZy54QXhpc119KWAgOiBcIlwifWAsXG4gICAgICAgICAgICBmb250OiB7IHNpemU6IDEyLCBjb2xvcjogXCIjZWE1ODBjXCIgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNob3diYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgIGJhY2tncm91bmRjb2xvcjogXCJyZ2JhKDI0MCwgMjQwLCAyNDAsIDAuOClcIixcbiAgICAgICAgfSxcbiAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgdGV4dDogYCR7YW5hbHlzaXMubWFwcGluZy55QXhpc30gJHthbmFseXNpcy5kYXRhVHlwZXNbYW5hbHlzaXMubWFwcGluZy55QXhpc10gPyBgKCR7YW5hbHlzaXMuZGF0YVR5cGVzW2FuYWx5c2lzLm1hcHBpbmcueUF4aXNdfSlgIDogXCJcIn1gLFxuICAgICAgICAgICAgZm9udDogeyBzaXplOiAxMiwgY29sb3I6IFwiI2VhNTgwY1wiIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaG93YmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICBiYWNrZ3JvdW5kY29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjQwLCAwLjgpXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHpheGlzOiB7XG4gICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIHRleHQ6IGAke2FuYWx5c2lzLm1hcHBpbmcuekF4aXN9ICR7YW5hbHlzaXMuZGF0YVR5cGVzW2FuYWx5c2lzLm1hcHBpbmcuekF4aXNdID8gYCgke2FuYWx5c2lzLmRhdGFUeXBlc1thbmFseXNpcy5tYXBwaW5nLnpBeGlzXX0pYCA6IFwiXCJ9YCxcbiAgICAgICAgICAgIGZvbnQ6IHsgc2l6ZTogMTIsIGNvbG9yOiBcIiNlYTU4MGNcIiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2hvd2JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgYmFja2dyb3VuZGNvbG9yOiBcInJnYmEoMjQwLCAyNDAsIDI0MCwgMC44KVwiLFxuICAgICAgICB9LFxuICAgICAgICBjYW1lcmE6IHsgZXllOiB7IHg6IDEuMjUsIHk6IDEuMjUsIHo6IDEuMjUgfSB9LFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7IHRleHQ6IHRpdGxlLCBmb250OiB7IHNpemU6IDE4LCBjb2xvcjogXCIjZWE1ODBjXCIgfSB9LFxuICAgICAgcGFwZXJfYmdjb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICBtYXJnaW46IHsgbDogMCwgcjogMCwgdDogNjAsIGI6IDAgfSxcbiAgICAgIGFubm90YXRpb25zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0ZXh0OiBgPGI+TW9kw6hsZTo8L2I+ICR7dGl0bGV9PGJyPjxiPkRvbm7DqWVzOjwvYj4gJHtkYXRhSW5mb308YnI+PGI+TWFwcGluZzo8L2I+PGJyPuKAoiBYOiAke2FuYWx5c2lzLm1hcHBpbmcueEF4aXN9PGJyPuKAoiBZOiAke2FuYWx5c2lzLm1hcHBpbmcueUF4aXN9PGJyPuKAoiBaOiAke2FuYWx5c2lzLm1hcHBpbmcuekF4aXN9PGJyPuKAoiBDb3VsZXVyOiAke2FuYWx5c2lzLm1hcHBpbmcuY29sb3JCeX08YnI+4oCiIFRhaWxsZTogJHthbmFseXNpcy5tYXBwaW5nLnNpemVCeX0ke2FuYWx5c2lzLm1hcHBpbmcuY2F0ZWdvcnlCeSA/IGA8YnI+4oCiIENhdMOpZ29yaWU6ICR7YW5hbHlzaXMubWFwcGluZy5jYXRlZ29yeUJ5fWAgOiBcIlwifWAsXG4gICAgICAgICAgc2hvd2Fycm93OiBmYWxzZSxcbiAgICAgICAgICB4cmVmOiBcInBhcGVyXCIsXG4gICAgICAgICAgeXJlZjogXCJwYXBlclwiLFxuICAgICAgICAgIHg6IC0wLjE1LFxuICAgICAgICAgIHk6IDAuOTUsXG4gICAgICAgICAgeGFuY2hvcjogXCJsZWZ0XCIsXG4gICAgICAgICAgeWFuY2hvcjogXCJ0b3BcIixcbiAgICAgICAgICBiZ2NvbG9yOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KVwiLFxuICAgICAgICAgIGJvcmRlcmNvbG9yOiBcInJnYmEoMjM0LCA4OCwgMTIsIDAuMylcIixcbiAgICAgICAgICBib3JkZXJ3aWR0aDogMSxcbiAgICAgICAgICBmb250OiB7IHNpemU6IDgsIGNvbG9yOiBcIiM2NjZcIiB9LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9XG4gIH1cblxuICBjb25zdCBnZXRQbG90Q29uZmlnID0gKCkgPT4gKHtcbiAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgIGRpc3BsYXlNb2RlQmFyOiBmYWxzZSxcbiAgICBzdGF0aWNQbG90OiBmYWxzZSxcbiAgICBzY3JvbGxab29tOiB0cnVlLFxuICAgIGRvdWJsZUNsaWNrOiBcInJlc2V0XCIsXG4gIH0pXG5cbiAgY29uc3QgcmVuZGVyVjBWaXN1YWxpemF0aW9uID0gKGNvbmZpZzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5QbG90bHkubmV3UGxvdChwbG90UmVmLmN1cnJlbnQsIGNvbmZpZy5jb25maWcuZGF0YSwgY29uZmlnLmNvbmZpZy5sYXlvdXQsIGdldFBsb3RDb25maWcoKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycmV1ciByZW5kdSB2MDpcIiwgZXJyb3IpXG4gICAgICByZW5kZXJNb2RlbFNwZWNpZmljVmlzdWFsaXphdGlvbigpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVuZGVyRGVtb1Zpc3VhbGl6YXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgZGVtb0RhdGEgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA1MCB9LCAoXywgaSkgPT4gKHtcbiAgICAgIHg6IE1hdGgucmFuZG9tKCkgKiAxMCxcbiAgICAgIHk6IE1hdGgucmFuZG9tKCkgKiAxMCxcbiAgICAgIHo6IE1hdGgucmFuZG9tKCkgKiAxMCxcbiAgICAgIHZhbHVlOiBNYXRoLnJhbmRvbSgpICogMTAwLFxuICAgICAgY2F0ZWdvcnk6IGBDYXQke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUpICsgMX1gLFxuICAgIH0pKVxuXG4gICAgc2V0RGF0YU1hcHBpbmcoe1xuICAgICAgeEF4aXM6IFwiRGltZW5zaW9uIFhcIixcbiAgICAgIHlBeGlzOiBcIkRpbWVuc2lvbiBZXCIsXG4gICAgICB6QXhpczogXCJEaW1lbnNpb24gWlwiLFxuICAgICAgY29sb3JCeTogXCJWYWxldXJcIixcbiAgICAgIHNpemVCeTogXCJWYWxldXJcIixcbiAgICB9KVxuXG4gICAgY29uc3QgcGxvdERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic2NhdHRlcjNkXCIsXG4gICAgICAgIG1vZGU6IFwibWFya2Vyc1wiLFxuICAgICAgICB4OiBkZW1vRGF0YS5tYXAoKGQpID0+IGQueCksXG4gICAgICAgIHk6IGRlbW9EYXRhLm1hcCgoZCkgPT4gZC55KSxcbiAgICAgICAgejogZGVtb0RhdGEubWFwKChkKSA9PiBkLnopLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBzaXplOiA4LFxuICAgICAgICAgIGNvbG9yOiBkZW1vRGF0YS5tYXAoKGQpID0+IGQudmFsdWUpLFxuICAgICAgICAgIGNvbG9yc2NhbGU6IFwiUmFpbmJvd1wiLFxuICAgICAgICAgIG9wYWNpdHk6IDAuOCxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogXCJEw6ltb25zdHJhdGlvblwiLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBsYXlvdXQgPSB7XG4gICAgICBzY2VuZToge1xuICAgICAgICB4YXhpczogeyB0aXRsZTogXCJEaW1lbnNpb24gWFwiLCBzaG93YmFja2dyb3VuZDogdHJ1ZSwgYmFja2dyb3VuZGNvbG9yOiBcInJnYmEoMjQwLCAyNDAsIDI0MCwgMC44KVwiIH0sXG4gICAgICAgIHlheGlzOiB7IHRpdGxlOiBcIkRpbWVuc2lvbiBZXCIsIHNob3diYWNrZ3JvdW5kOiB0cnVlLCBiYWNrZ3JvdW5kY29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjQwLCAwLjgpXCIgfSxcbiAgICAgICAgemF4aXM6IHsgdGl0bGU6IFwiRGltZW5zaW9uIFpcIiwgc2hvd2JhY2tncm91bmQ6IHRydWUsIGJhY2tncm91bmRjb2xvcjogXCJyZ2JhKDI0MCwgMjQwLCAyNDAsIDAuOClcIiB9LFxuICAgICAgICBjYW1lcmE6IHsgZXllOiB7IHg6IDEuMjUsIHk6IDEuMjUsIHo6IDEuMjUgfSB9LFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7IHRleHQ6IGBEw6ltb25zdHJhdGlvbiAtICR7Z2V0TW9kZWxOYW1lKHZpc3VhbGl6YXRpb25UeXBlKX1gLCBmb250OiB7IHNpemU6IDE4LCBjb2xvcjogXCIjZWE1ODBjXCIgfSB9LFxuICAgICAgcGFwZXJfYmdjb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICBtYXJnaW46IHsgbDogMCwgcjogMCwgdDogNjAsIGI6IDAgfSxcbiAgICB9XG5cbiAgICB3aW5kb3cuUGxvdGx5Lm5ld1Bsb3QocGxvdFJlZi5jdXJyZW50LCBwbG90RGF0YSwgbGF5b3V0LCBnZXRQbG90Q29uZmlnKCkpXG4gIH1cblxuICBjb25zdCBnZXRNb2RlbE5hbWUgPSAobW9kZWxJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbmFtZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICBzY2F0dGVyM2Q6IFwiTnVhZ2UgM0QgQ2xhc3NpcXVlXCIsXG4gICAgICBzY2F0dGVyX2RlbnNpdHk6IFwiRGVuc2l0w6kgM0RcIixcbiAgICAgIHNjYXR0ZXJfYnViYmxlOiBcIkJ1bGxlcyAzRFwiLFxuICAgICAgbWFuZGFsYV8zZDogXCJNYW5kYWxhIDNEXCIsXG4gICAgICBnYWxheHlfM2Q6IFwiR2FsYXhpZSAzRFwiLFxuICAgICAgc3VyZmFjZV9jb250b3VyOiBcIlN1cmZhY2UgQ29udG91cnNcIixcbiAgICAgIGRuYV9oZWxpeDogXCJIw6lsaWNlIEFETlwiLFxuICAgICAgdGltZWxpbmVfM2Q6IFwiVGltZWxpbmUgM0RcIixcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzW21vZGVsSWRdIHx8IFwiVmlzdWFsaXNhdGlvbiAzRFwiXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiaC1mdWxsIGJnLWdyYWRpZW50LXRvLWJyIGZyb20tb3JhbmdlLTUwIHRvLXdoaXRlIHJvdW5kZWQteGwgYm9yZGVyLTIgYm9yZGVyLW9yYW5nZS0yMDAgb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICB7LyogSGVhZGVyICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTYgYm9yZGVyLWIgYm9yZGVyLW9yYW5nZS0yMDAgYmctd2hpdGVcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtM1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTEyIGgtMTIgYmctZ3JhZGllbnQtdG8tYnIgZnJvbS1vcmFuZ2UtNjAwIHRvLW9yYW5nZS01MDAgcm91bmRlZC14bCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICA8VHJlbmRpbmdVcCBjbGFzc05hbWU9XCJ3LTYgaC02IHRleHQtd2hpdGVcIiAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LWJvbGQgdGV4dC1ncmF5LTgwMFwiPkNhbnZhcyBJQSDigKIgVmlzdWFsaXNhdGlvbiBEeW5hbWlxdWU8L2gyPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS02MDBcIj5cbiAgICAgICAgICAgICAgICB7ZGF0YS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICA/IGAke2RhdGEubGVuZ3RofSDDqWNoYW50aWxsb25zIOKAoiAke2NvbHVtbnMubGVuZ3RofSB2YXJpYWJsZXMg4oCiICR7Z2V0TW9kZWxOYW1lKGN1cnJlbnRNb2RlbCl9YFxuICAgICAgICAgICAgICAgICAgOiBgTW9kZSBkw6ltb25zdHJhdGlvbiDigKIgJHtnZXRNb2RlbE5hbWUoY3VycmVudE1vZGVsKX1gfVxuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIHtkYXRhQW5hbHlzaXMgJiYgKFxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTUwMFwiPlxuICAgICAgICAgICAgICAgICAge2RhdGFBbmFseXNpcy5udW1lcmljQ29sdW1ucy5sZW5ndGh9IG51bcOpcmlxdWVzIOKAoiB7ZGF0YUFuYWx5c2lzLmNhdGVnb3JpY2FsQ29sdW1ucy5sZW5ndGh9e1wiIFwifVxuICAgICAgICAgICAgICAgICAgY2F0w6lnb3JpZWxsZXMg4oCiIHtkYXRhQW5hbHlzaXMudGVtcG9yYWxDb2x1bW5zLmxlbmd0aH0gdGVtcG9yZWxsZXNcbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yXCI+XG4gICAgICAgICAgICB7aXNWMEdlbmVyYXRlZCAmJiAoXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBweC0zIHB5LTEgcm91bmRlZC1mdWxsIHRleHQteHMgZm9udC1tZWRpdW0gYmctYmx1ZS0xMDAgdGV4dC1ibHVlLTgwMFwiPlxuICAgICAgICAgICAgICAgIDxDb2RlIGNsYXNzTmFtZT1cInctMyBoLTMgbXItMVwiIC8+XG4gICAgICAgICAgICAgICAgR8OpbsOpcsOpIHBhciB2MFxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIHB4LTMgcHktMSByb3VuZGVkLWZ1bGwgdGV4dC14cyBmb250LW1lZGl1bSBiZy1vcmFuZ2UtMTAwIHRleHQtb3JhbmdlLTgwMFwiPlxuICAgICAgICAgICAgICA8WmFwIGNsYXNzTmFtZT1cInctMyBoLTMgbXItMVwiIC8+XG4gICAgICAgICAgICAgIFBsb3RseSB2Mi4zNVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIHB4LTMgcHktMSByb3VuZGVkLWZ1bGwgdGV4dC14cyBmb250LW1lZGl1bSBiZy1ncmVlbi0xMDAgdGV4dC1ncmVlbi04MDBcIj5cbiAgICAgICAgICAgICAgQWRhcHRhdGlmIER5bmFtaXF1ZVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogQ2FudmFzICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBoLVtjYWxjKDEwMCUtMTIwcHgpXVwiPlxuICAgICAgICB7IXBsb3RseUxvYWRlZCA/IChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGgtZnVsbFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctOCBoLTggYm9yZGVyLTIgYm9yZGVyLW9yYW5nZS01MDAgYm9yZGVyLXQtdHJhbnNwYXJlbnQgcm91bmRlZC1mdWxsIGFuaW1hdGUtc3BpbiBteC1hdXRvIG1iLTRcIj48L2Rpdj5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTYwMFwiPkNoYXJnZW1lbnQgZGUgUGxvdGx5LmpzIHYyLjM1Li4uPC9wPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS01MDAgbXQtMlwiPkFuYWx5c2UgZHluYW1pcXVlIGRlcyBkb25uw6llcyBlbiBjb3Vycy4uLjwvcD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApIDogKFxuICAgICAgICAgIDxkaXYgcmVmPXtwbG90UmVmfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsXCIgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJUcmVuZGluZ1VwIiwiWmFwIiwiQ29kZSIsIkNhbnZhczNEVmlzdWFsaXphdGlvbiIsImRhdGEiLCJjb2x1bW5zIiwidmlzdWFsaXphdGlvblR5cGUiLCJnZW5lcmF0ZWRDb25maWciLCJwbG90UmVmIiwiaXNWMEdlbmVyYXRlZCIsInNldElzVjBHZW5lcmF0ZWQiLCJwbG90bHlMb2FkZWQiLCJzZXRQbG90bHlMb2FkZWQiLCJkYXRhTWFwcGluZyIsInNldERhdGFNYXBwaW5nIiwiY3VycmVudE1vZGVsIiwic2V0Q3VycmVudE1vZGVsIiwiZGF0YUFuYWx5c2lzIiwic2V0RGF0YUFuYWx5c2lzIiwid2luZG93IiwiUGxvdGx5Iiwic2NyaXB0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwib25sb2FkIiwib25lcnJvciIsImNvbnNvbGUiLCJlcnJvciIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImN1cnJlbnQiLCJ1cGRhdGVWaXN1YWxpemF0aW9uIiwicGxvdEVsZW1lbnQiLCJjaGlsZHJlbiIsImxlbmd0aCIsInB1cmdlIiwicmVuZGVyVjBWaXN1YWxpemF0aW9uIiwicmVuZGVyTW9kZWxTcGVjaWZpY1Zpc3VhbGl6YXRpb24iLCJyZW5kZXJDbGFzc2ljU2NhdHRlciIsImFuYWx5emVEYXRhSW50ZWxsaWdlbnRseSIsIm1hcHBpbmciLCJ4QXhpcyIsInlBeGlzIiwiekF4aXMiLCJjb2xvckJ5Iiwic2l6ZUJ5IiwibnVtZXJpY0NvbHVtbnMiLCJjYXRlZ29yaWNhbENvbHVtbnMiLCJ0ZW1wb3JhbENvbHVtbnMiLCJkYXRhUmFuZ2VzIiwiY2F0ZWdvcmllcyIsImRhdGFUeXBlcyIsImFuYWx5c2lzIiwiZm9yRWFjaCIsImNvbCIsInZhbHVlcyIsIm1hcCIsInJvdyIsImZpbHRlciIsInZhbCIsIm51bWVyaWNWYWx1ZXMiLCJOdW1iZXIiLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJpc0Zpbml0ZSIsIm51bWVyaWNSYXRpbyIsImRhdGVWYWx1ZXMiLCJkYXRlIiwiRGF0ZSIsImdldFRpbWUiLCJnZXRGdWxsWWVhciIsInRlbXBvcmFsUmF0aW8iLCJ1bmlxdWVWYWx1ZXMiLCJTZXQiLCJ1bmlxdWVSYXRpbyIsInB1c2giLCJ0aW1lc3RhbXBzIiwibWluIiwiTWF0aCIsIm1heCIsInNsaWNlIiwiYWxsTnVtZXJpY0NvbHMiLCJjYXRlZ29yeUJ5IiwicmVuZGVyRGVtb1Zpc3VhbGl6YXRpb24iLCJyZW5kZXJCdWJibGVTY2F0dGVyIiwicmVuZGVyQW5pbWF0ZWRTY2F0dGVyIiwicmVuZGVyQ2x1c3RlcmVkU2NhdHRlciIsInJlbmRlckRlbnNpdHlTY2F0dGVyIiwicmVuZGVyQ2xhc3NpY1N1cmZhY2UiLCJyZW5kZXJDb250b3VyU3VyZmFjZSIsInJlbmRlck1lc2hTdXJmYWNlIiwicmVuZGVyR3JhZGllbnRTdXJmYWNlIiwicmVuZGVyQ2xhc3NpY0JhcnMiLCJyZW5kZXJHcm91cGVkQmFycyIsInJlbmRlckN5bGluZHJpY2FsQmFycyIsInJlbmRlclB5cmFtaWRCYXJzIiwicmVuZGVyU3BoZXJlUGFjayIsInJlbmRlckN1YmVNYXRyaXgiLCJyZW5kZXJDb25lRmllbGQiLCJyZW5kZXJIZWxpeFNwaXJhbCIsInJlbmRlck1hbmRhbGEzRCIsInJlbmRlckZyYWN0YWwzRCIsInJlbmRlckNyeXN0YWwzRCIsInJlbmRlckdhbGF4eTNEIiwicmVuZGVyRE5BSGVsaXgiLCJyZW5kZXJOZXR3b3JrM0QiLCJyZW5kZXJUcmVlM0QiLCJyZW5kZXJUaW1lbGluZTNEIiwicmVuZGVyV2F2ZVRlbXBvcmFsIiwicmVuZGVyU3BpcmFsVGltZSIsInJlbmRlckdsb2JlM0QiLCJyZW5kZXJUZXJyYWluM0QiLCJyZW5kZXJNb2xlY3VsZTNEIiwicmVuZGVyVmVjdG9yRmllbGQiLCJyZW5kZXJIaXN0b2dyYW0zRCIsInJlbmRlckJveFBsb3QzRCIsImdldFZhbHVlc0Zyb21BbmFseXNpcyIsImtleSIsImNvbHVtbiIsIl8iLCJpIiwiaW5jbHVkZXMiLCJyYW5nZSIsInRpbWVzdGFtcCIsIm51bVZhbCIsImluZGV4IiwiaW5kZXhPZiIsInhWYWx1ZXMiLCJ5VmFsdWVzIiwielZhbHVlcyIsImNvbG9yVmFsdWVzIiwibWFya2VyU2l6ZSIsInNxcnQiLCJwbG90RGF0YSIsInR5cGUiLCJtb2RlIiwieCIsInkiLCJ6IiwibWFya2VyIiwic2l6ZSIsImNvbG9yIiwiY29sb3JzY2FsZSIsIm9wYWNpdHkiLCJjb2xvcmJhciIsInRpdGxlIiwidGl0bGVmb250IiwidGV4dCIsInRvb2x0aXAiLCJob3ZlcnRlbXBsYXRlIiwibmFtZSIsImxheW91dCIsImNyZWF0ZUR5bmFtaWNMYXlvdXQiLCJuZXdQbG90IiwiZ2V0UGxvdENvbmZpZyIsImdyaWRTaXplIiwieFJhbmdlIiwieVJhbmdlIiwielJhbmdlIiwiZGVuc2l0eVgiLCJkZW5zaXR5WSIsImRlbnNpdHlaIiwiZGVuc2l0eUNvbG9ycyIsImRlbnNpdHlTaXplcyIsInhTcGFuIiwieVNwYW4iLCJ6U3BhbiIsInJhZGl1cyIsImoiLCJrIiwiZGVuc2l0eSIsInAiLCJkeCIsImR5IiwiZHoiLCJkaXN0YW5jZSIsImV4cCIsInRocmVzaG9sZCIsInRvRml4ZWQiLCJzaXplVmFsdWVzIiwibWluU2l6ZSIsIm1heFNpemUiLCJub3JtYWxpemVkU2l6ZXMiLCJ2IiwibGluZSIsIndpZHRoIiwibWFuZGFsYVgiLCJtYW5kYWxhWSIsIm1hbmRhbGFaIiwibWFuZGFsYUNvbG9ycyIsIm1hbmRhbGFTaXplcyIsIm5vcm1hbGl6ZWRJbmRleCIsImNvbG9yVmFsIiwic2l6ZVZhbCIsImNvbG9yUmFuZ2UiLCJ0b3VycyIsImFuZ2xlIiwiUEkiLCJzaW4iLCJoZWlnaHQiLCJjb3MiLCJudW1QZXRhbHMiLCJwZXRhbEFuZ2xlIiwicGV0YWxSYWRpdXMiLCJzY2VuZSIsImNhbWVyYSIsImV5ZSIsImdhbGF4eVgiLCJnYWxheHlZIiwiZ2FsYXh5WiIsImdhbGF4eUNvbG9ycyIsImdhbGF4eVNpemVzIiwic2l6ZVJhbmdlIiwidCIsIm5vcm1hbGl6ZWRDb2xvciIsIm5vcm1hbGl6ZWRTaXplIiwicmFuZG9tIiwiYW5nbGUyIiwicmFkaXVzMiIsImJnY29sb3IiLCJ0aW1lQ29sdW1uIiwidmFsdWVDb2x1bW4iLCJjb2xvckNvbHVtbiIsInRpbWVWYWx1ZXMiLCJzb3J0ZWRJbmRpY2VzIiwic29ydCIsImEiLCJiIiwidGltZWxpbmVYIiwidGltZWxpbmVZIiwidGltZWxpbmVaIiwidGltZWxpbmVDb2xvcnMiLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwieEdyaWQiLCJBcnJheSIsImZyb20iLCJ5R3JpZCIsInN1cmZhY2UiLCJ0YXJnZXRYIiwidGFyZ2V0WSIsIndlaWdodGVkU3VtIiwidG90YWxXZWlnaHQiLCJtYXhEaXN0YW5jZSIsIndlaWdodCIsImNvbnRvdXJzIiwic2hvdyIsInVzZWNvbG9ybWFwIiwiaGlnaGxpZ2h0Y29sb3IiLCJwcm9qZWN0IiwiZG5hWDEiLCJkbmFZMSIsImRuYVoxIiwiZG5hWDIiLCJkbmFZMiIsImRuYVoyIiwiZG5hQ29sb3JzIiwiZG5hU2l6ZXMiLCJyYWRpdXNNb2R1bGF0aW9uIiwiaGVpZ2h0TW9kdWxhdGlvbiIsInNob3dsZWdlbmQiLCJkYXRhSW5mbyIsInhheGlzIiwiZm9udCIsInNob3diYWNrZ3JvdW5kIiwiYmFja2dyb3VuZGNvbG9yIiwieWF4aXMiLCJ6YXhpcyIsInBhcGVyX2JnY29sb3IiLCJtYXJnaW4iLCJsIiwiciIsImFubm90YXRpb25zIiwic2hvd2Fycm93IiwieHJlZiIsInlyZWYiLCJ4YW5jaG9yIiwieWFuY2hvciIsImJvcmRlcmNvbG9yIiwiYm9yZGVyd2lkdGgiLCJyZXNwb25zaXZlIiwiZGlzcGxheU1vZGVCYXIiLCJzdGF0aWNQbG90Iiwic2Nyb2xsWm9vbSIsImRvdWJsZUNsaWNrIiwiY29uZmlnIiwiZGVtb0RhdGEiLCJ2YWx1ZSIsImNhdGVnb3J5IiwiZmxvb3IiLCJkIiwiZ2V0TW9kZWxOYW1lIiwibW9kZWxJZCIsIm5hbWVzIiwic2NhdHRlcjNkIiwic2NhdHRlcl9kZW5zaXR5Iiwic2NhdHRlcl9idWJibGUiLCJtYW5kYWxhXzNkIiwiZ2FsYXh5XzNkIiwic3VyZmFjZV9jb250b3VyIiwiZG5hX2hlbGl4IiwidGltZWxpbmVfM2QiLCJkaXYiLCJjbGFzc05hbWUiLCJoMiIsInNwYW4iLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Canvas3DVisualization.tsx\n"));

/***/ })

});